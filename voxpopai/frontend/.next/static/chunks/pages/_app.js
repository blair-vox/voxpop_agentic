/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "(pages-dir-browser)/./node_modules/jwt-decode/build/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/jwt-decode/build/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidTokenError: () => (/* binding */ InvalidTokenError),\n/* harmony export */   jwtDecode: () => (/* binding */ jwtDecode)\n/* harmony export */ });\nclass InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nfunction jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qd3QtZGVjb2RlL2J1aWxkL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFFBQVE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFNBQVMsR0FBRyxVQUFVO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsU0FBUyxHQUFHLFVBQVU7QUFDN0c7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2Jjb25uL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9jb21+YXBwbGV+Q2xvdWREb2NzL1Byb2plY3RzL1ZveFBvcF9BZ2VudGljL3ZveHBvcGFpL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9qd3QtZGVjb2RlL2J1aWxkL2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgSW52YWxpZFRva2VuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5JbnZhbGlkVG9rZW5FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiSW52YWxpZFRva2VuRXJyb3JcIjtcbmZ1bmN0aW9uIGI2NERlY29kZVVuaWNvZGUoc3RyKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChhdG9iKHN0cikucmVwbGFjZSgvKC4pL2csIChtLCBwKSA9PiB7XG4gICAgICAgIGxldCBjb2RlID0gcC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoY29kZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIiVcIiArIGNvZGU7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gYmFzZTY0VXJsRGVjb2RlKHN0cikge1xuICAgIGxldCBvdXRwdXQgPSBzdHIucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gICAgc3dpdGNoIChvdXRwdXQubGVuZ3RoICUgNCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgb3V0cHV0ICs9IFwiPT1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCI9XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2U2NCBzdHJpbmcgaXMgbm90IG9mIHRoZSBjb3JyZWN0IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGI2NERlY29kZVVuaWNvZGUob3V0cHV0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gYXRvYihvdXRwdXQpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBqd3REZWNvZGUodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcihcIkludmFsaWQgdG9rZW4gc3BlY2lmaWVkOiBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGNvbnN0IHBvcyA9IG9wdGlvbnMuaGVhZGVyID09PSB0cnVlID8gMCA6IDE7XG4gICAgY29uc3QgcGFydCA9IHRva2VuLnNwbGl0KFwiLlwiKVtwb3NdO1xuICAgIGlmICh0eXBlb2YgcGFydCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3IoYEludmFsaWQgdG9rZW4gc3BlY2lmaWVkOiBtaXNzaW5nIHBhcnQgIyR7cG9zICsgMX1gKTtcbiAgICB9XG4gICAgbGV0IGRlY29kZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlZCA9IGJhc2U2NFVybERlY29kZShwYXJ0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUb2tlbkVycm9yKGBJbnZhbGlkIHRva2VuIHNwZWNpZmllZDogaW52YWxpZCBiYXNlNjQgZm9yIHBhcnQgIyR7cG9zICsgMX0gKCR7ZS5tZXNzYWdlfSlgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcihgSW52YWxpZCB0b2tlbiBzcGVjaWZpZWQ6IGludmFsaWQganNvbiBmb3IgcGFydCAjJHtwb3MgKyAxfSAoJHtlLm1lc3NhZ2V9KWApO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/jwt-decode/build/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"(pages-dir-browser)/./src/pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcz9hYnNvbHV0ZVBhZ2VQYXRoPXByaXZhdGUtbmV4dC1wYWdlcyUyRl9hcHAmcGFnZT0lMkZfYXBwISIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHlFQUF5QjtBQUNoRDtBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js":
/*!****************************************************************!*\
  !*** ./node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessTokenEvents: () => (/* binding */ AccessTokenEvents),\n/* harmony export */   CheckSessionIFrame: () => (/* binding */ CheckSessionIFrame),\n/* harmony export */   DPoPState: () => (/* binding */ DPoPState),\n/* harmony export */   ErrorResponse: () => (/* binding */ ErrorResponse),\n/* harmony export */   ErrorTimeout: () => (/* binding */ ErrorTimeout),\n/* harmony export */   InMemoryWebStorage: () => (/* binding */ InMemoryWebStorage),\n/* harmony export */   IndexedDbDPoPStore: () => (/* binding */ IndexedDbDPoPStore),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   MetadataService: () => (/* binding */ MetadataService),\n/* harmony export */   OidcClient: () => (/* binding */ OidcClient),\n/* harmony export */   OidcClientSettingsStore: () => (/* binding */ OidcClientSettingsStore),\n/* harmony export */   SessionMonitor: () => (/* binding */ SessionMonitor),\n/* harmony export */   SigninResponse: () => (/* binding */ SigninResponse),\n/* harmony export */   SigninState: () => (/* binding */ SigninState),\n/* harmony export */   SignoutResponse: () => (/* binding */ SignoutResponse),\n/* harmony export */   State: () => (/* binding */ State),\n/* harmony export */   User: () => (/* binding */ User),\n/* harmony export */   UserManager: () => (/* binding */ UserManager),\n/* harmony export */   UserManagerSettingsStore: () => (/* binding */ UserManagerSettingsStore),\n/* harmony export */   Version: () => (/* binding */ Version),\n/* harmony export */   WebStorageStateStore: () => (/* binding */ WebStorageStateStore)\n/* harmony export */ });\n/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jwt-decode */ \"(pages-dir-browser)/./node_modules/jwt-decode/build/esm/index.js\");\n// src/utils/Logger.ts\nvar nopLogger = {\n  debug: () => void 0,\n  info: () => void 0,\n  warn: () => void 0,\n  error: () => void 0\n};\nvar level;\nvar logger;\nvar Log = /* @__PURE__ */ ((Log2) => {\n  Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n  Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n  Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n  Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n  Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n  return Log2;\n})(Log || {});\n((Log2) => {\n  function reset() {\n    level = 3 /* INFO */;\n    logger = nopLogger;\n  }\n  Log2.reset = reset;\n  function setLevel(value) {\n    if (!(0 /* NONE */ <= value && value <= 4 /* DEBUG */)) {\n      throw new Error(\"Invalid log level\");\n    }\n    level = value;\n  }\n  Log2.setLevel = setLevel;\n  function setLogger(value) {\n    logger = value;\n  }\n  Log2.setLogger = setLogger;\n})(Log || (Log = {}));\nvar Logger = class _Logger {\n  constructor(_name) {\n    this._name = _name;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  debug(...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  info(...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  warn(...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  error(...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n  throw(err) {\n    this.error(err);\n    throw err;\n  }\n  create(method) {\n    const methodLogger = Object.create(this);\n    methodLogger._method = method;\n    methodLogger.debug(\"begin\");\n    return methodLogger;\n  }\n  static createStatic(name, staticMethod) {\n    const staticLogger = new _Logger(`${name}.${staticMethod}`);\n    staticLogger.debug(\"begin\");\n    return staticLogger;\n  }\n  static _format(name, method) {\n    const prefix = `[${name}]`;\n    return method ? `${prefix} ${method}:` : prefix;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  // helpers for static class methods\n  static debug(name, ...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(_Logger._format(name), ...args);\n    }\n  }\n  static info(name, ...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(_Logger._format(name), ...args);\n    }\n  }\n  static warn(name, ...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(_Logger._format(name), ...args);\n    }\n  }\n  static error(name, ...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(_Logger._format(name), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n};\nLog.reset();\n\n// src/utils/JwtUtils.ts\n\nvar JwtUtils = class {\n  // IMPORTANT: doesn't validate the token\n  static decode(token) {\n    try {\n      return (0,jwt_decode__WEBPACK_IMPORTED_MODULE_0__.jwtDecode)(token);\n    } catch (err) {\n      Logger.error(\"JwtUtils.decode\", err);\n      throw err;\n    }\n  }\n  static async generateSignedJwt(header, payload, privateKey) {\n    const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n    const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n    const encodedToken = `${encodedHeader}.${encodedPayload}`;\n    const signature = await window.crypto.subtle.sign(\n      {\n        name: \"ECDSA\",\n        hash: { name: \"SHA-256\" }\n      },\n      privateKey,\n      new TextEncoder().encode(encodedToken)\n    );\n    const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n    return `${encodedToken}.${encodedSignature}`;\n  }\n};\n\n// src/utils/CryptoUtils.ts\nvar UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar toBase64 = (val) => btoa([...new Uint8Array(val)].map((chr) => String.fromCharCode(chr)).join(\"\"));\nvar _CryptoUtils = class _CryptoUtils {\n  static _randomWord() {\n    const arr = new Uint32Array(1);\n    crypto.getRandomValues(arr);\n    return arr[0];\n  }\n  /**\n   * Generates RFC4122 version 4 guid\n   */\n  static generateUUIDv4() {\n    const uuid = UUID_V4_TEMPLATE.replace(\n      /[018]/g,\n      (c) => (+c ^ _CryptoUtils._randomWord() & 15 >> +c / 4).toString(16)\n    );\n    return uuid.replace(/-/g, \"\");\n  }\n  /**\n   * PKCE: Generate a code verifier\n   */\n  static generateCodeVerifier() {\n    return _CryptoUtils.generateUUIDv4() + _CryptoUtils.generateUUIDv4() + _CryptoUtils.generateUUIDv4();\n  }\n  /**\n   * PKCE: Generate a code challenge\n   */\n  static async generateCodeChallenge(code_verifier) {\n    if (!crypto.subtle) {\n      throw new Error(\"Crypto.subtle is available only in secure contexts (HTTPS).\");\n    }\n    try {\n      const encoder = new TextEncoder();\n      const data = encoder.encode(code_verifier);\n      const hashed = await crypto.subtle.digest(\"SHA-256\", data);\n      return toBase64(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (err) {\n      Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n      throw err;\n    }\n  }\n  /**\n   * Generates a base64-encoded string for a basic auth header\n   */\n  static generateBasicAuth(client_id, client_secret) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode([client_id, client_secret].join(\":\"));\n    return toBase64(data);\n  }\n  /**\n   * Generates a hash of a string using a given algorithm\n   * @param alg\n   * @param message\n   */\n  static async hash(alg, message) {\n    const msgUint8 = new TextEncoder().encode(message);\n    const hashBuffer = await crypto.subtle.digest(alg, msgUint8);\n    return new Uint8Array(hashBuffer);\n  }\n  /**\n   * Generates a rfc7638 compliant jwk thumbprint\n   * @param jwk\n   */\n  static async customCalculateJwkThumbprint(jwk) {\n    let jsonObject;\n    switch (jwk.kty) {\n      case \"RSA\":\n        jsonObject = {\n          \"e\": jwk.e,\n          \"kty\": jwk.kty,\n          \"n\": jwk.n\n        };\n        break;\n      case \"EC\":\n        jsonObject = {\n          \"crv\": jwk.crv,\n          \"kty\": jwk.kty,\n          \"x\": jwk.x,\n          \"y\": jwk.y\n        };\n        break;\n      case \"OKP\":\n        jsonObject = {\n          \"crv\": jwk.crv,\n          \"kty\": jwk.kty,\n          \"x\": jwk.x\n        };\n        break;\n      case \"oct\":\n        jsonObject = {\n          \"crv\": jwk.k,\n          \"kty\": jwk.kty\n        };\n        break;\n      default:\n        throw new Error(\"Unknown jwk type\");\n    }\n    const utf8encodedAndHashed = await _CryptoUtils.hash(\"SHA-256\", JSON.stringify(jsonObject));\n    return _CryptoUtils.encodeBase64Url(utf8encodedAndHashed);\n  }\n  static async generateDPoPProof({\n    url,\n    accessToken,\n    httpMethod,\n    keyPair,\n    nonce\n  }) {\n    let hashedToken;\n    let encodedHash;\n    const payload = {\n      \"jti\": window.crypto.randomUUID(),\n      \"htm\": httpMethod != null ? httpMethod : \"GET\",\n      \"htu\": url,\n      \"iat\": Math.floor(Date.now() / 1e3)\n    };\n    if (accessToken) {\n      hashedToken = await _CryptoUtils.hash(\"SHA-256\", accessToken);\n      encodedHash = _CryptoUtils.encodeBase64Url(hashedToken);\n      payload.ath = encodedHash;\n    }\n    if (nonce) {\n      payload.nonce = nonce;\n    }\n    try {\n      const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n      const header = {\n        \"alg\": \"ES256\",\n        \"typ\": \"dpop+jwt\",\n        \"jwk\": {\n          \"crv\": publicJwk.crv,\n          \"kty\": publicJwk.kty,\n          \"x\": publicJwk.x,\n          \"y\": publicJwk.y\n        }\n      };\n      return await JwtUtils.generateSignedJwt(header, payload, keyPair.privateKey);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw new Error(`Error exporting dpop public key: ${err.message}`);\n      } else {\n        throw err;\n      }\n    }\n  }\n  static async generateDPoPJkt(keyPair) {\n    try {\n      const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n      return await _CryptoUtils.customCalculateJwkThumbprint(publicJwk);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw new Error(`Could not retrieve dpop keys from storage: ${err.message}`);\n      } else {\n        throw err;\n      }\n    }\n  }\n  static async generateDPoPKeys() {\n    return await window.crypto.subtle.generateKey(\n      {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\"\n      },\n      false,\n      [\"sign\", \"verify\"]\n    );\n  }\n};\n/**\n * Generates a base64url encoded string\n */\n_CryptoUtils.encodeBase64Url = (input) => {\n  return toBase64(input).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n};\nvar CryptoUtils = _CryptoUtils;\n\n// src/utils/Event.ts\nvar Event = class {\n  constructor(_name) {\n    this._name = _name;\n    this._callbacks = [];\n    this._logger = new Logger(`Event('${this._name}')`);\n  }\n  addHandler(cb) {\n    this._callbacks.push(cb);\n    return () => this.removeHandler(cb);\n  }\n  removeHandler(cb) {\n    const idx = this._callbacks.lastIndexOf(cb);\n    if (idx >= 0) {\n      this._callbacks.splice(idx, 1);\n    }\n  }\n  async raise(...ev) {\n    this._logger.debug(\"raise:\", ...ev);\n    for (const cb of this._callbacks) {\n      await cb(...ev);\n    }\n  }\n};\n\n// src/utils/PopupUtils.ts\nvar PopupUtils = class {\n  /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */\n  static center({ ...features }) {\n    var _a, _b, _c;\n    if (features.width == null)\n      features.width = (_a = [800, 720, 600, 480].find((width) => width <= window.outerWidth / 1.618)) != null ? _a : 360;\n    (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n    if (features.height != null)\n      (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n    return features;\n  }\n  static serialize(features) {\n    return Object.entries(features).filter(([, value]) => value != null).map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`).join(\",\");\n  }\n};\n\n// src/utils/Timer.ts\nvar Timer = class _Timer extends Event {\n  constructor() {\n    super(...arguments);\n    this._logger = new Logger(`Timer('${this._name}')`);\n    this._timerHandle = null;\n    this._expiration = 0;\n    this._callback = () => {\n      const diff = this._expiration - _Timer.getEpochTime();\n      this._logger.debug(\"timer completes in\", diff);\n      if (this._expiration <= _Timer.getEpochTime()) {\n        this.cancel();\n        void super.raise();\n      }\n    };\n  }\n  // get the time\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n  init(durationInSeconds) {\n    const logger2 = this._logger.create(\"init\");\n    durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n    const expiration = _Timer.getEpochTime() + durationInSeconds;\n    if (this.expiration === expiration && this._timerHandle) {\n      logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n    this.cancel();\n    logger2.debug(\"using duration\", durationInSeconds);\n    this._expiration = expiration;\n    const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n    this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n  }\n  get expiration() {\n    return this._expiration;\n  }\n  cancel() {\n    this._logger.create(\"cancel\");\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle);\n      this._timerHandle = null;\n    }\n  }\n};\n\n// src/utils/UrlUtils.ts\nvar UrlUtils = class {\n  static readParams(url, responseMode = \"query\") {\n    if (!url) throw new TypeError(\"Invalid URL\");\n    const parsedUrl = new URL(url, \"http://127.0.0.1\");\n    const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(params.slice(1));\n  }\n};\nvar URL_STATE_DELIMITER = \";\";\n\n// src/errors/ErrorResponse.ts\nvar ErrorResponse = class extends Error {\n  constructor(args, form) {\n    var _a, _b, _c;\n    super(args.error_description || args.error || \"\");\n    this.form = form;\n    /** Marker to detect class: \"ErrorResponse\" */\n    this.name = \"ErrorResponse\";\n    if (!args.error) {\n      Logger.error(\"ErrorResponse\", \"No error passed\");\n      throw new Error(\"No error passed\");\n    }\n    this.error = args.error;\n    this.error_description = (_a = args.error_description) != null ? _a : null;\n    this.error_uri = (_b = args.error_uri) != null ? _b : null;\n    this.state = args.userState;\n    this.session_state = (_c = args.session_state) != null ? _c : null;\n    this.url_state = args.url_state;\n  }\n};\n\n// src/errors/ErrorTimeout.ts\nvar ErrorTimeout = class extends Error {\n  constructor(message) {\n    super(message);\n    /** Marker to detect class: \"ErrorTimeout\" */\n    this.name = \"ErrorTimeout\";\n  }\n};\n\n// src/AccessTokenEvents.ts\nvar AccessTokenEvents = class {\n  constructor(args) {\n    this._logger = new Logger(\"AccessTokenEvents\");\n    this._expiringTimer = new Timer(\"Access token expiring\");\n    this._expiredTimer = new Timer(\"Access token expired\");\n    this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n  }\n  async load(container) {\n    const logger2 = this._logger.create(\"load\");\n    if (container.access_token && container.expires_in !== void 0) {\n      const duration = container.expires_in;\n      logger2.debug(\"access token present, remaining duration:\", duration);\n      if (duration > 0) {\n        let expiring = duration - this._expiringNotificationTimeInSeconds;\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n        logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n        this._expiringTimer.init(expiring);\n      } else {\n        logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n        this._expiringTimer.cancel();\n      }\n      const expired = duration + 1;\n      logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n      this._expiredTimer.init(expired);\n    } else {\n      this._expiringTimer.cancel();\n      this._expiredTimer.cancel();\n    }\n  }\n  async unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\");\n    this._expiringTimer.cancel();\n    this._expiredTimer.cancel();\n  }\n  /**\n   * Add callback: Raised prior to the access token expiring.\n   */\n  addAccessTokenExpiring(cb) {\n    return this._expiringTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised prior to the access token expiring.\n   */\n  removeAccessTokenExpiring(cb) {\n    this._expiringTimer.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised after the access token has expired.\n   */\n  addAccessTokenExpired(cb) {\n    return this._expiredTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised after the access token has expired.\n   */\n  removeAccessTokenExpired(cb) {\n    this._expiredTimer.removeHandler(cb);\n  }\n};\n\n// src/CheckSessionIFrame.ts\nvar CheckSessionIFrame = class {\n  constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {\n    this._callback = _callback;\n    this._client_id = _client_id;\n    this._intervalInSeconds = _intervalInSeconds;\n    this._stopOnError = _stopOnError;\n    this._logger = new Logger(\"CheckSessionIFrame\");\n    this._timer = null;\n    this._session_state = null;\n    this._message = (e) => {\n      if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n        if (e.data === \"error\") {\n          this._logger.error(\"error message from check session op iframe\");\n          if (this._stopOnError) {\n            this.stop();\n          }\n        } else if (e.data === \"changed\") {\n          this._logger.debug(\"changed message from check session op iframe\");\n          this.stop();\n          void this._callback();\n        } else {\n          this._logger.debug(e.data + \" message from check session op iframe\");\n        }\n      }\n    };\n    const parsedUrl = new URL(url);\n    this._frame_origin = parsedUrl.origin;\n    this._frame = window.document.createElement(\"iframe\");\n    this._frame.style.visibility = \"hidden\";\n    this._frame.style.position = \"fixed\";\n    this._frame.style.left = \"-1000px\";\n    this._frame.style.top = \"0\";\n    this._frame.width = \"0\";\n    this._frame.height = \"0\";\n    this._frame.src = parsedUrl.href;\n  }\n  load() {\n    return new Promise((resolve) => {\n      this._frame.onload = () => {\n        resolve();\n      };\n      window.document.body.appendChild(this._frame);\n      window.addEventListener(\"message\", this._message, false);\n    });\n  }\n  start(session_state) {\n    if (this._session_state === session_state) {\n      return;\n    }\n    this._logger.create(\"start\");\n    this.stop();\n    this._session_state = session_state;\n    const send = () => {\n      if (!this._frame.contentWindow || !this._session_state) {\n        return;\n      }\n      this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n    send();\n    this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n  }\n  stop() {\n    this._logger.create(\"stop\");\n    this._session_state = null;\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n};\n\n// src/InMemoryWebStorage.ts\nvar InMemoryWebStorage = class {\n  constructor() {\n    this._logger = new Logger(\"InMemoryWebStorage\");\n    this._data = {};\n  }\n  clear() {\n    this._logger.create(\"clear\");\n    this._data = {};\n  }\n  getItem(key) {\n    this._logger.create(`getItem('${key}')`);\n    return this._data[key];\n  }\n  setItem(key, value) {\n    this._logger.create(`setItem('${key}')`);\n    this._data[key] = value;\n  }\n  removeItem(key) {\n    this._logger.create(`removeItem('${key}')`);\n    delete this._data[key];\n  }\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n  key(index) {\n    return Object.getOwnPropertyNames(this._data)[index];\n  }\n};\n\n// src/errors/ErrorDPoPNonce.ts\nvar ErrorDPoPNonce = class extends Error {\n  constructor(nonce, message) {\n    super(message);\n    /** Marker to detect class: \"ErrorDPoPNonce\" */\n    this.name = \"ErrorDPoPNonce\";\n    this.nonce = nonce;\n  }\n};\n\n// src/JsonService.ts\nvar JsonService = class {\n  constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}) {\n    this._jwtHandler = _jwtHandler;\n    this._extraHeaders = _extraHeaders;\n    this._logger = new Logger(\"JsonService\");\n    this._contentTypes = [];\n    this._contentTypes.push(...additionalContentTypes, \"application/json\");\n    if (_jwtHandler) {\n      this._contentTypes.push(\"application/jwt\");\n    }\n  }\n  async fetchWithTimeout(input, init = {}) {\n    const { timeoutInSeconds, ...initFetch } = init;\n    if (!timeoutInSeconds) {\n      return await fetch(input, initFetch);\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);\n    try {\n      const response = await fetch(input, {\n        ...init,\n        signal: controller.signal\n      });\n      return response;\n    } catch (err) {\n      if (err instanceof DOMException && err.name === \"AbortError\") {\n        throw new ErrorTimeout(\"Network timed out\");\n      }\n      throw err;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n  async getJson(url, {\n    token,\n    credentials,\n    timeoutInSeconds\n  } = {}) {\n    const logger2 = this._logger.create(\"getJson\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \")\n    };\n    if (token) {\n      logger2.debug(\"token passed, setting Authorization header\");\n      headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n    this._appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"GET\", headers, timeoutInSeconds, credentials });\n    } catch (err) {\n      logger2.error(\"Network Error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n    }\n    if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) {\n      return await this._jwtHandler(await response.text());\n    }\n    let json;\n    try {\n      json = await response.json();\n    } catch (err) {\n      logger2.error(\"Error parsing JSON response\", err);\n      if (response.ok) throw err;\n      throw new Error(`${response.statusText} (${response.status})`);\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  async postForm(url, {\n    body,\n    basicAuth,\n    timeoutInSeconds,\n    initCredentials,\n    extraHeaders\n  }) {\n    const logger2 = this._logger.create(\"postForm\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      ...extraHeaders\n    };\n    if (basicAuth !== void 0) {\n      headers[\"Authorization\"] = \"Basic \" + basicAuth;\n    }\n    this._appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n    } catch (err) {\n      logger2.error(\"Network error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find((item) => contentType.startsWith(item))) {\n      throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n    }\n    const responseText = await response.text();\n    let json = {};\n    if (responseText) {\n      try {\n        json = JSON.parse(responseText);\n      } catch (err) {\n        logger2.error(\"Error parsing JSON response\", err);\n        if (response.ok) throw err;\n        throw new Error(`${response.statusText} (${response.status})`);\n      }\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (response.headers.has(\"dpop-nonce\")) {\n        const nonce = response.headers.get(\"dpop-nonce\");\n        throw new ErrorDPoPNonce(nonce, `${JSON.stringify(json)}`);\n      }\n      if (json.error) {\n        throw new ErrorResponse(json, body);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  _appendExtraHeaders(headers) {\n    const logger2 = this._logger.create(\"appendExtraHeaders\");\n    const customKeys = Object.keys(this._extraHeaders);\n    const protectedHeaders = [\n      \"accept\",\n      \"content-type\"\n    ];\n    const preventOverride = [\n      \"authorization\"\n    ];\n    if (customKeys.length === 0) {\n      return;\n    }\n    customKeys.forEach((headerName) => {\n      if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n        logger2.warn(\"Protected header could not be set\", headerName, protectedHeaders);\n        return;\n      }\n      if (preventOverride.includes(headerName.toLocaleLowerCase()) && Object.keys(headers).includes(headerName)) {\n        logger2.warn(\"Header could not be overridden\", headerName, preventOverride);\n        return;\n      }\n      const content = typeof this._extraHeaders[headerName] === \"function\" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];\n      if (content && content !== \"\") {\n        headers[headerName] = content;\n      }\n    });\n  }\n};\n\n// src/MetadataService.ts\nvar MetadataService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"MetadataService\");\n    this._signingKeys = null;\n    this._metadata = null;\n    this._metadataUrl = this._settings.metadataUrl;\n    this._jsonService = new JsonService(\n      [\"application/jwk-set+json\"],\n      null,\n      this._settings.extraHeaders\n    );\n    if (this._settings.signingKeys) {\n      this._logger.debug(\"using signingKeys from settings\");\n      this._signingKeys = this._settings.signingKeys;\n    }\n    if (this._settings.metadata) {\n      this._logger.debug(\"using metadata from settings\");\n      this._metadata = this._settings.metadata;\n    }\n    if (this._settings.fetchRequestCredentials) {\n      this._logger.debug(\"using fetchRequestCredentials from settings\");\n      this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n    }\n  }\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n  async getMetadata() {\n    const logger2 = this._logger.create(\"getMetadata\");\n    if (this._metadata) {\n      logger2.debug(\"using cached values\");\n      return this._metadata;\n    }\n    if (!this._metadataUrl) {\n      logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n      throw null;\n    }\n    logger2.debug(\"getting metadata from\", this._metadataUrl);\n    const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n    logger2.debug(\"merging remote JSON with seed metadata\");\n    this._metadata = Object.assign({}, metadata, this._settings.metadataSeed);\n    return this._metadata;\n  }\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n  getTokenEndpoint(optional = true) {\n    return this._getMetadataProperty(\"token_endpoint\", optional);\n  }\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", true);\n  }\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", true);\n  }\n  getRevocationEndpoint(optional = true) {\n    return this._getMetadataProperty(\"revocation_endpoint\", optional);\n  }\n  getKeysEndpoint(optional = true) {\n    return this._getMetadataProperty(\"jwks_uri\", optional);\n  }\n  async _getMetadataProperty(name, optional = false) {\n    const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n    const metadata = await this.getMetadata();\n    logger2.debug(\"resolved\");\n    if (metadata[name] === void 0) {\n      if (optional === true) {\n        logger2.warn(\"Metadata does not contain optional property\");\n        return void 0;\n      }\n      logger2.throw(new Error(\"Metadata does not contain property \" + name));\n    }\n    return metadata[name];\n  }\n  async getSigningKeys() {\n    const logger2 = this._logger.create(\"getSigningKeys\");\n    if (this._signingKeys) {\n      logger2.debug(\"returning signingKeys from cache\");\n      return this._signingKeys;\n    }\n    const jwks_uri = await this.getKeysEndpoint(false);\n    logger2.debug(\"got jwks_uri\", jwks_uri);\n    const keySet = await this._jsonService.getJson(jwks_uri, { timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n    logger2.debug(\"got key set\", keySet);\n    if (!Array.isArray(keySet.keys)) {\n      logger2.throw(new Error(\"Missing keys on keyset\"));\n      throw null;\n    }\n    this._signingKeys = keySet.keys;\n    return this._signingKeys;\n  }\n};\n\n// src/WebStorageStateStore.ts\nvar WebStorageStateStore = class {\n  constructor({\n    prefix = \"oidc.\",\n    store = localStorage\n  } = {}) {\n    this._logger = new Logger(\"WebStorageStateStore\");\n    this._store = store;\n    this._prefix = prefix;\n  }\n  async set(key, value) {\n    this._logger.create(`set('${key}')`);\n    key = this._prefix + key;\n    await this._store.setItem(key, value);\n  }\n  async get(key) {\n    this._logger.create(`get('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    return item;\n  }\n  async remove(key) {\n    this._logger.create(`remove('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    await this._store.removeItem(key);\n    return item;\n  }\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n    const len = await this._store.length;\n    const keys = [];\n    for (let index = 0; index < len; index++) {\n      const key = await this._store.key(index);\n      if (key && key.indexOf(this._prefix) === 0) {\n        keys.push(key.substr(this._prefix.length));\n      }\n    }\n    return keys;\n  }\n};\n\n// src/OidcClientSettings.ts\nvar DefaultResponseType = \"code\";\nvar DefaultScope = \"openid\";\nvar DefaultClientAuthentication = \"client_secret_post\";\nvar DefaultStaleStateAgeInSeconds = 60 * 15;\nvar OidcClientSettingsStore = class {\n  constructor({\n    // metadata related\n    authority,\n    metadataUrl,\n    metadata,\n    signingKeys,\n    metadataSeed,\n    // client related\n    client_id,\n    client_secret,\n    response_type = DefaultResponseType,\n    scope = DefaultScope,\n    redirect_uri,\n    post_logout_redirect_uri,\n    client_authentication = DefaultClientAuthentication,\n    // optional protocol\n    prompt,\n    display,\n    max_age,\n    ui_locales,\n    acr_values,\n    resource,\n    response_mode,\n    // behavior flags\n    filterProtocolClaims = true,\n    loadUserInfo = false,\n    requestTimeoutInSeconds,\n    staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n    mergeClaimsStrategy = { array: \"replace\" },\n    disablePKCE = false,\n    // other behavior\n    stateStore,\n    revokeTokenAdditionalContentTypes,\n    fetchRequestCredentials,\n    refreshTokenAllowedScope,\n    // extra\n    extraQueryParams = {},\n    extraTokenParams = {},\n    extraHeaders = {},\n    dpop,\n    omitScopeWhenRequesting = false\n  }) {\n    var _a;\n    this.authority = authority;\n    if (metadataUrl) {\n      this.metadataUrl = metadataUrl;\n    } else {\n      this.metadataUrl = authority;\n      if (authority) {\n        if (!this.metadataUrl.endsWith(\"/\")) {\n          this.metadataUrl += \"/\";\n        }\n        this.metadataUrl += \".well-known/openid-configuration\";\n      }\n    }\n    this.metadata = metadata;\n    this.metadataSeed = metadataSeed;\n    this.signingKeys = signingKeys;\n    this.client_id = client_id;\n    this.client_secret = client_secret;\n    this.response_type = response_type;\n    this.scope = scope;\n    this.redirect_uri = redirect_uri;\n    this.post_logout_redirect_uri = post_logout_redirect_uri;\n    this.client_authentication = client_authentication;\n    this.prompt = prompt;\n    this.display = display;\n    this.max_age = max_age;\n    this.ui_locales = ui_locales;\n    this.acr_values = acr_values;\n    this.resource = resource;\n    this.response_mode = response_mode;\n    this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;\n    this.loadUserInfo = !!loadUserInfo;\n    this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n    this.mergeClaimsStrategy = mergeClaimsStrategy;\n    this.omitScopeWhenRequesting = omitScopeWhenRequesting;\n    this.disablePKCE = !!disablePKCE;\n    this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n    this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : \"same-origin\";\n    this.requestTimeoutInSeconds = requestTimeoutInSeconds;\n    if (stateStore) {\n      this.stateStore = stateStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n      this.stateStore = new WebStorageStateStore({ store });\n    }\n    this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n    this.extraQueryParams = extraQueryParams;\n    this.extraTokenParams = extraTokenParams;\n    this.extraHeaders = extraHeaders;\n    this.dpop = dpop;\n    if (this.dpop && !((_a = this.dpop) == null ? void 0 : _a.store)) {\n      throw new Error(\"A DPoPStore is required when dpop is enabled\");\n    }\n  }\n};\n\n// src/UserInfoService.ts\nvar UserInfoService = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"UserInfoService\");\n    this._getClaimsFromJwt = async (responseText) => {\n      const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n      try {\n        const payload = JwtUtils.decode(responseText);\n        logger2.debug(\"JWT decoding successful\");\n        return payload;\n      } catch (err) {\n        logger2.error(\"Error parsing JWT response\");\n        throw err;\n      }\n    };\n    this._jsonService = new JsonService(\n      void 0,\n      this._getClaimsFromJwt,\n      this._settings.extraHeaders\n    );\n  }\n  async getClaims(token) {\n    const logger2 = this._logger.create(\"getClaims\");\n    if (!token) {\n      this._logger.throw(new Error(\"No token passed\"));\n    }\n    const url = await this._metadataService.getUserInfoEndpoint();\n    logger2.debug(\"got userinfo url\", url);\n    const claims = await this._jsonService.getJson(url, {\n      token,\n      credentials: this._settings.fetchRequestCredentials,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds\n    });\n    logger2.debug(\"got claims\", claims);\n    return claims;\n  }\n};\n\n// src/TokenClient.ts\nvar TokenClient = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"TokenClient\");\n    this._jsonService = new JsonService(\n      this._settings.revokeTokenAdditionalContentTypes,\n      null,\n      this._settings.extraHeaders\n    );\n  }\n  /**\n   * Exchange code.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n   */\n  async exchangeCode({\n    grant_type = \"authorization_code\",\n    redirect_uri = this._settings.redirect_uri,\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    extraHeaders,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCode\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!redirect_uri) {\n      logger2.throw(new Error(\"A redirect_uri is required\"));\n    }\n    if (!args.code) {\n      logger2.throw(new Error(\"A code is required\"));\n    }\n    const params = new URLSearchParams({ grant_type, redirect_uri });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (client_secret === void 0 || client_secret === null) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n      initCredentials: this._settings.fetchRequestCredentials,\n      extraHeaders\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange credentials.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n   */\n  async exchangeCredentials({\n    grant_type = \"password\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    scope = this._settings.scope,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCredentials\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    const params = new URLSearchParams({ grant_type });\n    if (!this._settings.omitScopeWhenRequesting) {\n      params.set(\"scope\", scope);\n    }\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (client_secret === void 0 || client_secret === null) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds: this._settings.requestTimeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange a refresh token.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n   */\n  async exchangeRefreshToken({\n    grant_type = \"refresh_token\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    timeoutInSeconds,\n    extraHeaders,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeRefreshToken\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!args.refresh_token) {\n      logger2.throw(new Error(\"A refresh_token is required\"));\n    }\n    const params = new URLSearchParams({ grant_type });\n    for (const [key, value] of Object.entries(args)) {\n      if (Array.isArray(value)) {\n        value.forEach((param) => params.append(key, param));\n      } else if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (client_secret === void 0 || client_secret === null) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials, extraHeaders });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */\n  async revoke(args) {\n    var _a;\n    const logger2 = this._logger.create(\"revoke\");\n    if (!args.token) {\n      logger2.throw(new Error(\"A token is required\"));\n    }\n    const url = await this._metadataService.getRevocationEndpoint(false);\n    logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n    const params = new URLSearchParams();\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    params.set(\"client_id\", this._settings.client_id);\n    if (this._settings.client_secret) {\n      params.set(\"client_secret\", this._settings.client_secret);\n    }\n    await this._jsonService.postForm(url, { body: params, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n    logger2.debug(\"got response\");\n  }\n};\n\n// src/ResponseValidator.ts\nvar ResponseValidator = class {\n  constructor(_settings, _metadataService, _claimsService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._claimsService = _claimsService;\n    this._logger = new Logger(\"ResponseValidator\");\n    this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n    this._tokenClient = new TokenClient(this._settings, this._metadataService);\n  }\n  async validateSigninResponse(response, state, extraHeaders) {\n    const logger2 = this._logger.create(\"validateSigninResponse\");\n    this._processSigninState(response, state);\n    logger2.debug(\"state processed\");\n    await this._processCode(response, state, extraHeaders);\n    logger2.debug(\"code processed\");\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateCredentialsResponse(response, skipUserInfo) {\n    const logger2 = this._logger.create(\"validateCredentialsResponse\");\n    const shouldValidateSubClaim = response.isOpenId && !!response.id_token;\n    if (shouldValidateSubClaim) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, skipUserInfo, shouldValidateSubClaim);\n    logger2.debug(\"claims processed\");\n  }\n  async validateRefreshResponse(response, state) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"validateRefreshResponse\");\n    response.userState = state.data;\n    (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n    (_b = response.scope) != null ? _b : response.scope = state.scope;\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response, state.id_token);\n      logger2.debug(\"ID Token validated\");\n    }\n    if (!response.id_token) {\n      response.id_token = state.id_token;\n      response.profile = state.profile;\n    }\n    const hasIdToken = response.isOpenId && !!response.id_token;\n    await this._processClaims(response, false, hasIdToken);\n    logger2.debug(\"claims processed\");\n  }\n  validateSignoutResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSignoutResponse\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n  }\n  _processSigninState(response, state) {\n    var _a;\n    const logger2 = this._logger.create(\"_processSigninState\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    if (!state.client_id) {\n      logger2.throw(new Error(\"No client_id on state\"));\n    }\n    if (!state.authority) {\n      logger2.throw(new Error(\"No authority on state\"));\n    }\n    if (this._settings.authority !== state.authority) {\n      logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n    }\n    if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    response.url_state = state.url_state;\n    (_a = response.scope) != null ? _a : response.scope = state.scope;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n    if (state.code_verifier && !response.code) {\n      logger2.throw(new Error(\"Expected code in response\"));\n    }\n  }\n  async _processClaims(response, skipUserInfo = false, validateSub = true) {\n    const logger2 = this._logger.create(\"_processClaims\");\n    response.profile = this._claimsService.filterProtocolClaims(response.profile);\n    if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n      logger2.debug(\"not loading user info\");\n      return;\n    }\n    logger2.debug(\"loading user info\");\n    const claims = await this._userInfoService.getClaims(response.access_token);\n    logger2.debug(\"user info claims received from user info endpoint\");\n    if (validateSub && claims.sub !== response.profile.sub) {\n      logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n    }\n    response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));\n    logger2.debug(\"user info claims received, updated profile:\", response.profile);\n  }\n  async _processCode(response, state, extraHeaders) {\n    const logger2 = this._logger.create(\"_processCode\");\n    if (response.code) {\n      logger2.debug(\"Validating code\");\n      const tokenResponse = await this._tokenClient.exchangeCode({\n        client_id: state.client_id,\n        client_secret: state.client_secret,\n        code: response.code,\n        redirect_uri: state.redirect_uri,\n        code_verifier: state.code_verifier,\n        extraHeaders,\n        ...state.extraTokenParams\n      });\n      Object.assign(response, tokenResponse);\n    } else {\n      logger2.debug(\"No code to process\");\n    }\n  }\n  _validateIdTokenAttributes(response, existingToken) {\n    var _a;\n    const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n    logger2.debug(\"decoding ID Token JWT\");\n    const incoming = JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n    if (!incoming.sub) {\n      logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n    }\n    if (existingToken) {\n      const existing = JwtUtils.decode(existingToken);\n      if (incoming.sub !== existing.sub) {\n        logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n      }\n      if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n        logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n      }\n      if (incoming.azp && incoming.azp !== existing.azp) {\n        logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n      }\n      if (!incoming.azp && existing.azp) {\n        logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n      }\n    }\n    response.profile = incoming;\n  }\n};\n\n// src/State.ts\nvar State = class _State {\n  constructor(args) {\n    this.id = args.id || CryptoUtils.generateUUIDv4();\n    this.data = args.data;\n    if (args.created && args.created > 0) {\n      this.created = args.created;\n    } else {\n      this.created = Timer.getEpochTime();\n    }\n    this.request_type = args.request_type;\n    this.url_state = args.url_state;\n  }\n  toStorageString() {\n    new Logger(\"State\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"State\", \"fromStorageString\");\n    return Promise.resolve(new _State(JSON.parse(storageString)));\n  }\n  static async clearStaleState(storage, age) {\n    const logger2 = Logger.createStatic(\"State\", \"clearStaleState\");\n    const cutoff = Timer.getEpochTime() - age;\n    const keys = await storage.getAllKeys();\n    logger2.debug(\"got keys\", keys);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const item = await storage.get(key);\n      let remove = false;\n      if (item) {\n        try {\n          const state = await _State.fromStorageString(item);\n          logger2.debug(\"got item from key:\", key, state.created);\n          if (state.created <= cutoff) {\n            remove = true;\n          }\n        } catch (err) {\n          logger2.error(\"Error parsing state for key:\", key, err);\n          remove = true;\n        }\n      } else {\n        logger2.debug(\"no item in storage for key:\", key);\n        remove = true;\n      }\n      if (remove) {\n        logger2.debug(\"removed item for key:\", key);\n        void storage.remove(key);\n      }\n    }\n  }\n};\n\n// src/SigninState.ts\nvar SigninState = class _SigninState extends State {\n  constructor(args) {\n    super(args);\n    this.code_verifier = args.code_verifier;\n    this.code_challenge = args.code_challenge;\n    this.authority = args.authority;\n    this.client_id = args.client_id;\n    this.redirect_uri = args.redirect_uri;\n    this.scope = args.scope;\n    this.client_secret = args.client_secret;\n    this.extraTokenParams = args.extraTokenParams;\n    this.response_mode = args.response_mode;\n    this.skipUserInfo = args.skipUserInfo;\n  }\n  static async create(args) {\n    const code_verifier = args.code_verifier === true ? CryptoUtils.generateCodeVerifier() : args.code_verifier || void 0;\n    const code_challenge = code_verifier ? await CryptoUtils.generateCodeChallenge(code_verifier) : void 0;\n    return new _SigninState({\n      ...args,\n      code_verifier,\n      code_challenge\n    });\n  }\n  toStorageString() {\n    new Logger(\"SigninState\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"SigninState\", \"fromStorageString\");\n    const data = JSON.parse(storageString);\n    return _SigninState.create(data);\n  }\n};\n\n// src/SigninRequest.ts\nvar _SigninRequest = class _SigninRequest {\n  constructor(args) {\n    this.url = args.url;\n    this.state = args.state;\n  }\n  static async create({\n    // mandatory\n    url,\n    authority,\n    client_id,\n    redirect_uri,\n    response_type,\n    scope,\n    // optional\n    state_data,\n    response_mode,\n    request_type,\n    client_secret,\n    nonce,\n    url_state,\n    resource,\n    skipUserInfo,\n    extraQueryParams,\n    extraTokenParams,\n    disablePKCE,\n    dpopJkt,\n    omitScopeWhenRequesting,\n    ...optionalParams\n  }) {\n    if (!url) {\n      this._logger.error(\"create: No url passed\");\n      throw new Error(\"url\");\n    }\n    if (!client_id) {\n      this._logger.error(\"create: No client_id passed\");\n      throw new Error(\"client_id\");\n    }\n    if (!redirect_uri) {\n      this._logger.error(\"create: No redirect_uri passed\");\n      throw new Error(\"redirect_uri\");\n    }\n    if (!response_type) {\n      this._logger.error(\"create: No response_type passed\");\n      throw new Error(\"response_type\");\n    }\n    if (!scope) {\n      this._logger.error(\"create: No scope passed\");\n      throw new Error(\"scope\");\n    }\n    if (!authority) {\n      this._logger.error(\"create: No authority passed\");\n      throw new Error(\"authority\");\n    }\n    const state = await SigninState.create({\n      data: state_data,\n      request_type,\n      url_state,\n      code_verifier: !disablePKCE,\n      client_id,\n      authority,\n      redirect_uri,\n      response_mode,\n      client_secret,\n      scope,\n      extraTokenParams,\n      skipUserInfo\n    });\n    const parsedUrl = new URL(url);\n    parsedUrl.searchParams.append(\"client_id\", client_id);\n    parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n    parsedUrl.searchParams.append(\"response_type\", response_type);\n    if (!omitScopeWhenRequesting) {\n      parsedUrl.searchParams.append(\"scope\", scope);\n    }\n    if (nonce) {\n      parsedUrl.searchParams.append(\"nonce\", nonce);\n    }\n    if (dpopJkt) {\n      parsedUrl.searchParams.append(\"dpop_jkt\", dpopJkt);\n    }\n    let stateParam = state.id;\n    if (url_state) {\n      stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n    }\n    parsedUrl.searchParams.append(\"state\", stateParam);\n    if (state.code_challenge) {\n      parsedUrl.searchParams.append(\"code_challenge\", state.code_challenge);\n      parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n    }\n    if (resource) {\n      const resources = Array.isArray(resource) ? resource : [resource];\n      resources.forEach((r) => parsedUrl.searchParams.append(\"resource\", r));\n    }\n    for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    return new _SigninRequest({\n      url: parsedUrl.href,\n      state\n    });\n  }\n};\n_SigninRequest._logger = new Logger(\"SigninRequest\");\nvar SigninRequest = _SigninRequest;\n\n// src/SigninResponse.ts\nvar OidcScope = \"openid\";\nvar SigninResponse = class {\n  constructor(params) {\n    /** @see {@link User.access_token} */\n    this.access_token = \"\";\n    /** @see {@link User.token_type} */\n    this.token_type = \"\";\n    /** @see {@link User.profile} */\n    this.profile = {};\n    this.state = params.get(\"state\");\n    this.session_state = params.get(\"session_state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n    this.code = params.get(\"code\");\n  }\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (typeof value === \"string\") value = Number(value);\n    if (value !== void 0 && value >= 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  get isOpenId() {\n    var _a;\n    return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes(OidcScope)) || !!this.id_token;\n  }\n};\n\n// src/SignoutRequest.ts\nvar SignoutRequest = class {\n  constructor({\n    url,\n    state_data,\n    id_token_hint,\n    post_logout_redirect_uri,\n    extraQueryParams,\n    request_type,\n    client_id,\n    url_state\n  }) {\n    this._logger = new Logger(\"SignoutRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    const parsedUrl = new URL(url);\n    if (id_token_hint) {\n      parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n    }\n    if (client_id) {\n      parsedUrl.searchParams.append(\"client_id\", client_id);\n    }\n    if (post_logout_redirect_uri) {\n      parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n      if (state_data || url_state) {\n        this.state = new State({ data: state_data, request_type, url_state });\n        let stateParam = this.state.id;\n        if (url_state) {\n          stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n        }\n        parsedUrl.searchParams.append(\"state\", stateParam);\n      }\n    }\n    for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SignoutResponse.ts\nvar SignoutResponse = class {\n  constructor(params) {\n    this.state = params.get(\"state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n  }\n};\n\n// src/ClaimsService.ts\nvar DefaultProtocolClaims = [\n  \"nbf\",\n  \"jti\",\n  \"auth_time\",\n  \"nonce\",\n  \"acr\",\n  \"amr\",\n  \"azp\",\n  \"at_hash\"\n  // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n];\nvar InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\nvar ClaimsService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"ClaimsService\");\n  }\n  filterProtocolClaims(claims) {\n    const result = { ...claims };\n    if (this._settings.filterProtocolClaims) {\n      let protocolClaims;\n      if (Array.isArray(this._settings.filterProtocolClaims)) {\n        protocolClaims = this._settings.filterProtocolClaims;\n      } else {\n        protocolClaims = DefaultProtocolClaims;\n      }\n      for (const claim of protocolClaims) {\n        if (!InternalRequiredProtocolClaims.includes(claim)) {\n          delete result[claim];\n        }\n      }\n    }\n    return result;\n  }\n  mergeClaims(claims1, claims2) {\n    const result = { ...claims1 };\n    for (const [claim, values] of Object.entries(claims2)) {\n      if (result[claim] !== values) {\n        if (Array.isArray(result[claim]) || Array.isArray(values)) {\n          if (this._settings.mergeClaimsStrategy.array == \"replace\") {\n            result[claim] = values;\n          } else {\n            const mergedValues = Array.isArray(result[claim]) ? result[claim] : [result[claim]];\n            for (const value of Array.isArray(values) ? values : [values]) {\n              if (!mergedValues.includes(value)) {\n                mergedValues.push(value);\n              }\n            }\n            result[claim] = mergedValues;\n          }\n        } else if (typeof result[claim] === \"object\" && typeof values === \"object\") {\n          result[claim] = this.mergeClaims(result[claim], values);\n        } else {\n          result[claim] = values;\n        }\n      }\n    }\n    return result;\n  }\n};\n\n// src/DPoPStore.ts\nvar DPoPState = class {\n  constructor(keys, nonce) {\n    this.keys = keys;\n    this.nonce = nonce;\n  }\n};\n\n// src/OidcClient.ts\nvar OidcClient = class {\n  constructor(settings, metadataService) {\n    this._logger = new Logger(\"OidcClient\");\n    this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n    this.metadataService = metadataService != null ? metadataService : new MetadataService(this.settings);\n    this._claimsService = new ClaimsService(this.settings);\n    this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n    this._tokenClient = new TokenClient(this.settings, this.metadataService);\n  }\n  async createSigninRequest({\n    state,\n    request,\n    request_uri,\n    request_type,\n    id_token_hint,\n    login_hint,\n    skipUserInfo,\n    nonce,\n    url_state,\n    response_type = this.settings.response_type,\n    scope = this.settings.scope,\n    redirect_uri = this.settings.redirect_uri,\n    prompt = this.settings.prompt,\n    display = this.settings.display,\n    max_age = this.settings.max_age,\n    ui_locales = this.settings.ui_locales,\n    acr_values = this.settings.acr_values,\n    resource = this.settings.resource,\n    response_mode = this.settings.response_mode,\n    extraQueryParams = this.settings.extraQueryParams,\n    extraTokenParams = this.settings.extraTokenParams,\n    dpopJkt,\n    omitScopeWhenRequesting = this.settings.omitScopeWhenRequesting\n  }) {\n    const logger2 = this._logger.create(\"createSigninRequest\");\n    if (response_type !== \"code\") {\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    }\n    const url = await this.metadataService.getAuthorizationEndpoint();\n    logger2.debug(\"Received authorization endpoint\", url);\n    const signinRequest = await SigninRequest.create({\n      url,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data: state,\n      url_state,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      id_token_hint,\n      login_hint,\n      acr_values,\n      dpopJkt,\n      resource,\n      request,\n      request_uri,\n      extraQueryParams,\n      extraTokenParams,\n      request_type,\n      response_mode,\n      client_secret: this.settings.client_secret,\n      skipUserInfo,\n      nonce,\n      disablePKCE: this.settings.disablePKCE,\n      omitScopeWhenRequesting\n    });\n    await this.clearStaleState();\n    const signinState = signinRequest.state;\n    await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n    return signinRequest;\n  }\n  async readSigninResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSigninResponseState\");\n    const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.throw(new Error(\"No state in response\"));\n      throw null;\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = await SigninState.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSigninResponse(url, extraHeaders, removeState = true) {\n    const logger2 = this._logger.create(\"processSigninResponse\");\n    const { state, response } = await this.readSigninResponseState(url, removeState);\n    logger2.debug(\"received state from storage; validating response\");\n    if (this.settings.dpop && this.settings.dpop.store) {\n      const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n      extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n    }\n    try {\n      await this._validator.validateSigninResponse(response, state, extraHeaders);\n    } catch (err) {\n      if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n        const dpopProof = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n        extraHeaders[\"DPoP\"] = dpopProof;\n        await this._validator.validateSigninResponse(response, state, extraHeaders);\n      } else {\n        throw err;\n      }\n    }\n    return response;\n  }\n  async getDpopProof(dpopStore, nonce) {\n    let keyPair;\n    let dpopState;\n    if (!(await dpopStore.getAllKeys()).includes(this.settings.client_id)) {\n      keyPair = await CryptoUtils.generateDPoPKeys();\n      dpopState = new DPoPState(keyPair, nonce);\n      await dpopStore.set(this.settings.client_id, dpopState);\n    } else {\n      dpopState = await dpopStore.get(this.settings.client_id);\n      if (dpopState.nonce !== nonce && nonce) {\n        dpopState.nonce = nonce;\n        await dpopStore.set(this.settings.client_id, dpopState);\n      }\n    }\n    return await CryptoUtils.generateDPoPProof({\n      url: await this.metadataService.getTokenEndpoint(false),\n      httpMethod: \"POST\",\n      keyPair: dpopState.keys,\n      nonce: dpopState.nonce\n    });\n  }\n  async processResourceOwnerPasswordCredentials({\n    username,\n    password,\n    skipUserInfo = false,\n    extraTokenParams = {}\n  }) {\n    const tokenResponse = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n    const signinResponse = new SigninResponse(new URLSearchParams());\n    Object.assign(signinResponse, tokenResponse);\n    await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n    return signinResponse;\n  }\n  async useRefreshToken({\n    state,\n    redirect_uri,\n    resource,\n    timeoutInSeconds,\n    extraHeaders,\n    extraTokenParams\n  }) {\n    var _a;\n    const logger2 = this._logger.create(\"useRefreshToken\");\n    let scope;\n    if (this.settings.refreshTokenAllowedScope === void 0) {\n      scope = state.scope;\n    } else {\n      const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n      const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(\" \")) || [];\n      scope = providedScopes.filter((s) => allowableScopes.includes(s)).join(\" \");\n    }\n    if (this.settings.dpop && this.settings.dpop.store) {\n      const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n      extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n    }\n    let result;\n    try {\n      result = await this._tokenClient.exchangeRefreshToken({\n        refresh_token: state.refresh_token,\n        // provide the (possible filtered) scope list\n        scope,\n        redirect_uri,\n        resource,\n        timeoutInSeconds,\n        extraHeaders,\n        ...extraTokenParams\n      });\n    } catch (err) {\n      if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n        extraHeaders[\"DPoP\"] = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n        result = await this._tokenClient.exchangeRefreshToken({\n          refresh_token: state.refresh_token,\n          // provide the (possible filtered) scope list\n          scope,\n          redirect_uri,\n          resource,\n          timeoutInSeconds,\n          extraHeaders,\n          ...extraTokenParams\n        });\n      } else {\n        throw err;\n      }\n    }\n    const response = new SigninResponse(new URLSearchParams());\n    Object.assign(response, result);\n    logger2.debug(\"validating response\", response);\n    await this._validator.validateRefreshResponse(response, {\n      ...state,\n      // override the scope in the state handed over to the validator\n      // so it can set the granted scope to the requested scope in case none is included in the response\n      scope\n    });\n    return response;\n  }\n  async createSignoutRequest({\n    state,\n    id_token_hint,\n    client_id,\n    request_type,\n    url_state,\n    post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n    extraQueryParams = this.settings.extraQueryParams\n  } = {}) {\n    const logger2 = this._logger.create(\"createSignoutRequest\");\n    const url = await this.metadataService.getEndSessionEndpoint();\n    if (!url) {\n      logger2.throw(new Error(\"No end session endpoint\"));\n      throw null;\n    }\n    logger2.debug(\"Received end session endpoint\", url);\n    if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n      client_id = this.settings.client_id;\n    }\n    const request = new SignoutRequest({\n      url,\n      id_token_hint,\n      client_id,\n      post_logout_redirect_uri,\n      state_data: state,\n      extraQueryParams,\n      request_type,\n      url_state\n    });\n    await this.clearStaleState();\n    const signoutState = request.state;\n    if (signoutState) {\n      logger2.debug(\"Signout request has state to persist\");\n      await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n    }\n    return request;\n  }\n  async readSignoutResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSignoutResponseState\");\n    const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.debug(\"No state in response\");\n      if (response.error) {\n        logger2.warn(\"Response was error:\", response.error);\n        throw new ErrorResponse(response);\n      }\n      return { state: void 0, response };\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = await State.fromStorageString(storedStateString);\n    return { state, response };\n  }\n  async processSignoutResponse(url) {\n    const logger2 = this._logger.create(\"processSignoutResponse\");\n    const { state, response } = await this.readSignoutResponseState(url, true);\n    if (state) {\n      logger2.debug(\"Received state from storage; validating response\");\n      this._validator.validateSignoutResponse(response, state);\n    } else {\n      logger2.debug(\"No state from storage; skipping response validation\");\n    }\n    return response;\n  }\n  clearStaleState() {\n    this._logger.create(\"clearStaleState\");\n    return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n  async revokeToken(token, type) {\n    this._logger.create(\"revokeToken\");\n    return await this._tokenClient.revoke({\n      token,\n      token_type_hint: type\n    });\n  }\n};\n\n// src/SessionMonitor.ts\nvar SessionMonitor = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SessionMonitor\");\n    this._start = async (user) => {\n      const session_state = user.session_state;\n      if (!session_state) {\n        return;\n      }\n      const logger2 = this._logger.create(\"_start\");\n      if (user.profile) {\n        this._sub = user.profile.sub;\n        logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n      } else {\n        this._sub = void 0;\n        logger2.debug(\"session_state\", session_state, \", anonymous user\");\n      }\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(session_state);\n        return;\n      }\n      try {\n        const url = await this._userManager.metadataService.getCheckSessionIframe();\n        if (url) {\n          logger2.debug(\"initializing check session iframe\");\n          const client_id = this._userManager.settings.client_id;\n          const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n          const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n          const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n          await checkSessionIFrame.load();\n          this._checkSessionIFrame = checkSessionIFrame;\n          checkSessionIFrame.start(session_state);\n        } else {\n          logger2.warn(\"no check session iframe found in the metadata\");\n        }\n      } catch (err) {\n        logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n      }\n    };\n    this._stop = () => {\n      const logger2 = this._logger.create(\"_stop\");\n      this._sub = void 0;\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.stop();\n      }\n      if (this._userManager.settings.monitorAnonymousSession) {\n        const timerHandle = setInterval(async () => {\n          clearInterval(timerHandle);\n          try {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n              const tmpUser = {\n                session_state: session.session_state,\n                profile: session.sub ? {\n                  sub: session.sub\n                } : null\n              };\n              void this._start(tmpUser);\n            }\n          } catch (err) {\n            logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n          }\n        }, 1e3);\n      }\n    };\n    this._callback = async () => {\n      const logger2 = this._logger.create(\"_callback\");\n      try {\n        const session = await this._userManager.querySessionStatus();\n        let raiseEvent = true;\n        if (session && this._checkSessionIFrame) {\n          if (session.sub === this._sub) {\n            raiseEvent = false;\n            this._checkSessionIFrame.start(session.session_state);\n            logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n            await this._userManager.events._raiseUserSessionChanged();\n          } else {\n            logger2.debug(\"different subject signed into OP\", session.sub);\n          }\n        } else {\n          logger2.debug(\"subject no longer signed into OP\");\n        }\n        if (raiseEvent) {\n          if (this._sub) {\n            await this._userManager.events._raiseUserSignedOut();\n          } else {\n            await this._userManager.events._raiseUserSignedIn();\n          }\n        } else {\n          logger2.debug(\"no change in session detected, no event to raise\");\n        }\n      } catch (err) {\n        if (this._sub) {\n          logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n          await this._userManager.events._raiseUserSignedOut();\n        }\n      }\n    };\n    if (!_userManager) {\n      this._logger.throw(new Error(\"No user manager passed\"));\n    }\n    this._userManager.events.addUserLoaded(this._start);\n    this._userManager.events.addUserUnloaded(this._stop);\n    this._init().catch((err) => {\n      this._logger.error(err);\n    });\n  }\n  async _init() {\n    this._logger.create(\"_init\");\n    const user = await this._userManager.getUser();\n    if (user) {\n      void this._start(user);\n    } else if (this._userManager.settings.monitorAnonymousSession) {\n      const session = await this._userManager.querySessionStatus();\n      if (session) {\n        const tmpUser = {\n          session_state: session.session_state,\n          profile: session.sub ? {\n            sub: session.sub\n          } : null\n        };\n        void this._start(tmpUser);\n      }\n    }\n  }\n};\n\n// src/User.ts\nvar User = class _User {\n  constructor(args) {\n    var _a;\n    this.id_token = args.id_token;\n    this.session_state = (_a = args.session_state) != null ? _a : null;\n    this.access_token = args.access_token;\n    this.refresh_token = args.refresh_token;\n    this.token_type = args.token_type;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.expires_at = args.expires_at;\n    this.state = args.userState;\n    this.url_state = args.url_state;\n  }\n  /** Computed number of seconds the access token has remaining. */\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (value !== void 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  /** Computed value indicating if the access token is expired. */\n  get expired() {\n    const expires_in = this.expires_in;\n    if (expires_in === void 0) {\n      return void 0;\n    }\n    return expires_in <= 0;\n  }\n  /** Array representing the parsed values from the `scope`. */\n  get scopes() {\n    var _a, _b;\n    return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n  }\n  toStorageString() {\n    new Logger(\"User\").create(\"toStorageString\");\n    return JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"User\", \"fromStorageString\");\n    return new _User(JSON.parse(storageString));\n  }\n};\n\n// src/navigators/AbstractChildWindow.ts\nvar messageSource = \"oidc-client\";\nvar AbstractChildWindow = class {\n  constructor() {\n    this._abort = new Event(\"Window navigation aborted\");\n    this._disposeHandlers = /* @__PURE__ */ new Set();\n    this._window = null;\n  }\n  async navigate(params) {\n    const logger2 = this._logger.create(\"navigate\");\n    if (!this._window) {\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    }\n    logger2.debug(\"setting URL in window\");\n    this._window.location.replace(params.url);\n    const { url, keepOpen } = await new Promise((resolve, reject) => {\n      const listener = (e) => {\n        var _a;\n        const data = e.data;\n        const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n        if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {\n          return;\n        }\n        try {\n          const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n          if (!state) {\n            logger2.warn(\"no state found in response url\");\n          }\n          if (e.source !== this._window && state !== params.state) {\n            return;\n          }\n        } catch {\n          this._dispose();\n          reject(new Error(\"Invalid response from window\"));\n        }\n        resolve(data);\n      };\n      window.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n      this._disposeHandlers.add(this._abort.addHandler((reason) => {\n        this._dispose();\n        reject(reason);\n      }));\n    });\n    logger2.debug(\"got response from window\");\n    this._dispose();\n    if (!keepOpen) {\n      this.close();\n    }\n    return { url };\n  }\n  _dispose() {\n    this._logger.create(\"_dispose\");\n    for (const dispose of this._disposeHandlers) {\n      dispose();\n    }\n    this._disposeHandlers.clear();\n  }\n  static _notifyParent(parent, url, keepOpen = false, targetOrigin = window.location.origin) {\n    parent.postMessage({\n      source: messageSource,\n      url,\n      keepOpen\n    }, targetOrigin);\n  }\n};\n\n// src/UserManagerSettings.ts\nvar DefaultPopupWindowFeatures = {\n  location: false,\n  toolbar: false,\n  height: 640,\n  closePopupWindowAfterInSeconds: -1\n};\nvar DefaultPopupTarget = \"_blank\";\nvar DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar DefaultCheckSessionIntervalInSeconds = 2;\nvar DefaultSilentRequestTimeoutInSeconds = 10;\nvar UserManagerSettingsStore = class extends OidcClientSettingsStore {\n  constructor(args) {\n    const {\n      popup_redirect_uri = args.redirect_uri,\n      popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n      popupWindowFeatures = DefaultPopupWindowFeatures,\n      popupWindowTarget = DefaultPopupTarget,\n      redirectMethod = \"assign\",\n      redirectTarget = \"self\",\n      iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n      iframeScriptOrigin = args.iframeScriptOrigin,\n      requestTimeoutInSeconds,\n      silent_redirect_uri = args.redirect_uri,\n      silentRequestTimeoutInSeconds,\n      automaticSilentRenew = true,\n      validateSubOnSilentRenew = true,\n      includeIdTokenInSilentRenew = false,\n      monitorSession = false,\n      monitorAnonymousSession = false,\n      checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n      query_status_response_type = \"code\",\n      stopCheckSessionOnError = true,\n      revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout = false,\n      includeIdTokenInSilentSignout = false,\n      accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n      userStore\n    } = args;\n    super(args);\n    this.popup_redirect_uri = popup_redirect_uri;\n    this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n    this.popupWindowFeatures = popupWindowFeatures;\n    this.popupWindowTarget = popupWindowTarget;\n    this.redirectMethod = redirectMethod;\n    this.redirectTarget = redirectTarget;\n    this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n    this.iframeScriptOrigin = iframeScriptOrigin;\n    this.silent_redirect_uri = silent_redirect_uri;\n    this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds || requestTimeoutInSeconds || DefaultSilentRequestTimeoutInSeconds;\n    this.automaticSilentRenew = automaticSilentRenew;\n    this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n    this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n    this.monitorSession = monitorSession;\n    this.monitorAnonymousSession = monitorAnonymousSession;\n    this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n    this.stopCheckSessionOnError = stopCheckSessionOnError;\n    this.query_status_response_type = query_status_response_type;\n    this.revokeTokenTypes = revokeTokenTypes;\n    this.revokeTokensOnSignout = revokeTokensOnSignout;\n    this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n    this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n    if (userStore) {\n      this.userStore = userStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n      this.userStore = new WebStorageStateStore({ store });\n    }\n  }\n};\n\n// src/navigators/IFrameWindow.ts\nvar IFrameWindow = class _IFrameWindow extends AbstractChildWindow {\n  constructor({\n    silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds\n  }) {\n    super();\n    this._logger = new Logger(\"IFrameWindow\");\n    this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n    this._frame = _IFrameWindow.createHiddenIframe();\n    this._window = this._frame.contentWindow;\n  }\n  static createHiddenIframe() {\n    const iframe = window.document.createElement(\"iframe\");\n    iframe.style.visibility = \"hidden\";\n    iframe.style.position = \"fixed\";\n    iframe.style.left = \"-1000px\";\n    iframe.style.top = \"0\";\n    iframe.width = \"0\";\n    iframe.height = \"0\";\n    window.document.body.appendChild(iframe);\n    return iframe;\n  }\n  async navigate(params) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n    const timer = setTimeout(() => void this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n    this._disposeHandlers.add(() => clearTimeout(timer));\n    return await super.navigate(params);\n  }\n  close() {\n    var _a;\n    if (this._frame) {\n      if (this._frame.parentNode) {\n        this._frame.addEventListener(\"load\", (ev) => {\n          var _a2;\n          const frame = ev.target;\n          (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);\n          void this._abort.raise(new Error(\"IFrame removed from DOM\"));\n        }, true);\n        (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace(\"about:blank\");\n      }\n      this._frame = null;\n    }\n    this._window = null;\n  }\n  static notifyParent(url, targetOrigin) {\n    return super._notifyParent(window.parent, url, false, targetOrigin);\n  }\n};\n\n// src/navigators/IFrameNavigator.ts\nvar IFrameNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"IFrameNavigator\");\n  }\n  async prepare({\n    silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds\n  }) {\n    return new IFrameWindow({ silentRequestTimeoutInSeconds });\n  }\n  async callback(url) {\n    this._logger.create(\"callback\");\n    IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n  }\n};\n\n// src/navigators/PopupWindow.ts\nvar checkForPopupClosedInterval = 500;\nvar second = 1e3;\nvar PopupWindow = class extends AbstractChildWindow {\n  constructor({\n    popupWindowTarget = DefaultPopupTarget,\n    popupWindowFeatures = {},\n    popupSignal\n  }) {\n    super();\n    this._logger = new Logger(\"PopupWindow\");\n    const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n    this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n    if (popupSignal) {\n      popupSignal.addEventListener(\"abort\", () => {\n        var _a;\n        void this._abort.raise(new Error((_a = popupSignal.reason) != null ? _a : \"Popup aborted\"));\n      });\n    }\n    if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n      setTimeout(() => {\n        if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n          void this._abort.raise(new Error(\"Popup blocked by user\"));\n          return;\n        }\n        this.close();\n      }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n    }\n  }\n  async navigate(params) {\n    var _a;\n    (_a = this._window) == null ? void 0 : _a.focus();\n    const popupClosedInterval = setInterval(() => {\n      if (!this._window || this._window.closed) {\n        void this._abort.raise(new Error(\"Popup closed by user\"));\n      }\n    }, checkForPopupClosedInterval);\n    this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n    return await super.navigate(params);\n  }\n  close() {\n    if (this._window) {\n      if (!this._window.closed) {\n        this._window.close();\n        void this._abort.raise(new Error(\"Popup closed\"));\n      }\n    }\n    this._window = null;\n  }\n  static notifyOpener(url, keepOpen) {\n    if (!window.opener) {\n      throw new Error(\"No window.opener. Can't complete notification.\");\n    }\n    return super._notifyParent(window.opener, url, keepOpen);\n  }\n};\n\n// src/navigators/PopupNavigator.ts\nvar PopupNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"PopupNavigator\");\n  }\n  async prepare({\n    popupWindowFeatures = this._settings.popupWindowFeatures,\n    popupWindowTarget = this._settings.popupWindowTarget,\n    popupSignal\n  }) {\n    return new PopupWindow({ popupWindowFeatures, popupWindowTarget, popupSignal });\n  }\n  async callback(url, { keepOpen = false }) {\n    this._logger.create(\"callback\");\n    PopupWindow.notifyOpener(url, keepOpen);\n  }\n};\n\n// src/navigators/RedirectNavigator.ts\nvar RedirectNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"RedirectNavigator\");\n  }\n  async prepare({\n    redirectMethod = this._settings.redirectMethod,\n    redirectTarget = this._settings.redirectTarget\n  }) {\n    var _a;\n    this._logger.create(\"prepare\");\n    let targetWindow = window.self;\n    if (redirectTarget === \"top\") {\n      targetWindow = (_a = window.top) != null ? _a : window.self;\n    }\n    const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n    let abort;\n    return {\n      navigate: async (params) => {\n        this._logger.create(\"navigate\");\n        const promise = new Promise((resolve, reject) => {\n          abort = reject;\n        });\n        redirect(params.url);\n        return await promise;\n      },\n      close: () => {\n        this._logger.create(\"close\");\n        abort == null ? void 0 : abort(new Error(\"Redirect aborted\"));\n        targetWindow.stop();\n      }\n    };\n  }\n  async callback() {\n    return;\n  }\n};\n\n// src/UserManagerEvents.ts\nvar UserManagerEvents = class extends AccessTokenEvents {\n  constructor(settings) {\n    super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    this._logger = new Logger(\"UserManagerEvents\");\n    this._userLoaded = new Event(\"User loaded\");\n    this._userUnloaded = new Event(\"User unloaded\");\n    this._silentRenewError = new Event(\"Silent renew error\");\n    this._userSignedIn = new Event(\"User signed in\");\n    this._userSignedOut = new Event(\"User signed out\");\n    this._userSessionChanged = new Event(\"User session changed\");\n  }\n  async load(user, raiseEvent = true) {\n    await super.load(user);\n    if (raiseEvent) {\n      await this._userLoaded.raise(user);\n    }\n  }\n  async unload() {\n    await super.unload();\n    await this._userUnloaded.raise();\n  }\n  /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */\n  addUserLoaded(cb) {\n    return this._userLoaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */\n  removeUserLoaded(cb) {\n    return this._userLoaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when a user session has been terminated.\n   */\n  addUserUnloaded(cb) {\n    return this._userUnloaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been terminated.\n   */\n  removeUserUnloaded(cb) {\n    return this._userUnloaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */\n  addSilentRenewError(cb) {\n    return this._silentRenewError.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */\n  removeSilentRenewError(cb) {\n    return this._silentRenewError.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseSilentRenewError(e) {\n    await this._silentRenewError.raise(e);\n  }\n  /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedIn(cb) {\n    return this._userSignedIn.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */\n  removeUserSignedIn(cb) {\n    this._userSignedIn.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSignedIn() {\n    await this._userSignedIn.raise();\n  }\n  /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedOut(cb) {\n    return this._userSignedOut.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */\n  removeUserSignedOut(cb) {\n    this._userSignedOut.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSignedOut() {\n    await this._userSignedOut.raise();\n  }\n  /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSessionChanged(cb) {\n    return this._userSessionChanged.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */\n  removeUserSessionChanged(cb) {\n    this._userSessionChanged.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSessionChanged() {\n    await this._userSessionChanged.raise();\n  }\n};\n\n// src/SilentRenewService.ts\nvar SilentRenewService = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SilentRenewService\");\n    this._isStarted = false;\n    this._retryTimer = new Timer(\"Retry Silent Renew\");\n    this._tokenExpiring = async () => {\n      const logger2 = this._logger.create(\"_tokenExpiring\");\n      try {\n        await this._userManager.signinSilent();\n        logger2.debug(\"silent token renewal successful\");\n      } catch (err) {\n        if (err instanceof ErrorTimeout) {\n          logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n          this._retryTimer.init(5);\n          return;\n        }\n        logger2.error(\"Error from signinSilent:\", err);\n        await this._userManager.events._raiseSilentRenewError(err);\n      }\n    };\n  }\n  async start() {\n    const logger2 = this._logger.create(\"start\");\n    if (!this._isStarted) {\n      this._isStarted = true;\n      this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n      this._retryTimer.addHandler(this._tokenExpiring);\n      try {\n        await this._userManager.getUser();\n      } catch (err) {\n        logger2.error(\"getUser error\", err);\n      }\n    }\n  }\n  stop() {\n    if (this._isStarted) {\n      this._retryTimer.cancel();\n      this._retryTimer.removeHandler(this._tokenExpiring);\n      this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n      this._isStarted = false;\n    }\n  }\n};\n\n// src/RefreshState.ts\nvar RefreshState = class {\n  constructor(args) {\n    this.refresh_token = args.refresh_token;\n    this.id_token = args.id_token;\n    this.session_state = args.session_state;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.data = args.state;\n  }\n};\n\n// src/UserManager.ts\nvar UserManager = class {\n  constructor(settings, redirectNavigator, popupNavigator, iframeNavigator) {\n    this._logger = new Logger(\"UserManager\");\n    this.settings = new UserManagerSettingsStore(settings);\n    this._client = new OidcClient(settings);\n    this._redirectNavigator = redirectNavigator != null ? redirectNavigator : new RedirectNavigator(this.settings);\n    this._popupNavigator = popupNavigator != null ? popupNavigator : new PopupNavigator(this.settings);\n    this._iframeNavigator = iframeNavigator != null ? iframeNavigator : new IFrameNavigator(this.settings);\n    this._events = new UserManagerEvents(this.settings);\n    this._silentRenewService = new SilentRenewService(this);\n    if (this.settings.automaticSilentRenew) {\n      this.startSilentRenew();\n    }\n    this._sessionMonitor = null;\n    if (this.settings.monitorSession) {\n      this._sessionMonitor = new SessionMonitor(this);\n    }\n  }\n  /**\n   * Get object used to register for events raised by the `UserManager`.\n   */\n  get events() {\n    return this._events;\n  }\n  /**\n   * Get object used to access the metadata configuration of the identity provider.\n   */\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  /**\n   * Load the `User` object for the currently authenticated user.\n   *\n   * @param raiseEvent - If `true`, the `UserLoaded` event will be raised. Defaults to false.\n   * @returns A promise\n   */\n  async getUser(raiseEvent = false) {\n    const logger2 = this._logger.create(\"getUser\");\n    const user = await this._loadUser();\n    if (user) {\n      logger2.info(\"user loaded\");\n      await this._events.load(user, raiseEvent);\n      return user;\n    }\n    logger2.info(\"user not found in storage\");\n    return null;\n  }\n  /**\n   * Remove from any storage the currently authenticated user.\n   *\n   * @returns A promise\n   */\n  async removeUser() {\n    const logger2 = this._logger.create(\"removeUser\");\n    await this.storeUser(null);\n    logger2.info(\"user removed from storage\");\n    await this._events.unload();\n  }\n  /**\n   * Trigger a redirect of the current window to the authorization endpoint.\n   *\n   * @returns A promise\n   *\n   * @throws `Error` In cases of wrong authentication.\n   */\n  async signinRedirect(args = {}) {\n    var _a;\n    this._logger.create(\"signinRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signinStart({\n      request_type: \"si:r\",\n      dpopJkt,\n      ...requestArgs\n    }, handle);\n  }\n  /**\n   * Process the response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise containing the authenticated `User`.\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinRedirectCallback\");\n    const user = await this._signinEnd(url);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Trigger the signin with user/password.\n   *\n   * @returns A promise containing the authenticated `User`.\n   * @throws {@link ErrorResponse} In cases of wrong authentication.\n   */\n  async signinResourceOwnerCredentials({\n    username,\n    password,\n    skipUserInfo = false\n  }) {\n    const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n    const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n      username,\n      password,\n      skipUserInfo,\n      extraTokenParams: this.settings.extraTokenParams\n    });\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Trigger a request (via a popup window) to the authorization endpoint.\n   *\n   * @returns A promise containing the authenticated `User`.\n   * @throws `Error` In cases of wrong authentication.\n   */\n  async signinPopup(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signinPopup\");\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n    }\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal });\n    const user = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: url,\n      display: \"popup\",\n      dpopJkt,\n      ...requestArgs\n    }, handle);\n    if (user) {\n      if (user.profile && user.profile.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  /**\n   * Notify the opening window of response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signinPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  /**\n   * Trigger a silent request (via refresh token or an iframe) to the authorization endpoint.\n   *\n   * @returns A promise that contains the authenticated `User`.\n   */\n  async signinSilent(args = {}) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"signinSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    let user = await this._loadUser();\n    if (user == null ? void 0 : user.refresh_token) {\n      logger2.debug(\"using refresh token\");\n      const state = new RefreshState(user);\n      return await this._useRefreshToken({\n        state,\n        redirect_uri: requestArgs.redirect_uri,\n        resource: requestArgs.resource,\n        extraTokenParams: requestArgs.extraTokenParams,\n        timeoutInSeconds: silentRequestTimeoutInSeconds\n      });\n    }\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    let verifySub;\n    if (user && this.settings.validateSubOnSilentRenew) {\n      logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n      verifySub = user.profile.sub;\n    }\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    user = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      dpopJkt,\n      ...requestArgs\n    }, handle, verifySub);\n    if (user) {\n      if ((_b = user.profile) == null ? void 0 : _b.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  async _useRefreshToken(args) {\n    const response = await this._client.useRefreshToken({\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n      ...args\n    });\n    const user = new User({ ...args.state, ...response });\n    await this.storeUser(user);\n    await this._events.load(user);\n    return user;\n  }\n  /**\n   *\n   * Notify the parent window of response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process any response (callback) from the authorization endpoint, by dispatching the request_type\n   * and executing one of the following functions:\n   * - {@link UserManager.signinRedirectCallback}\n   * - {@link UserManager.signinPopupCallback}\n   * - {@link UserManager.signinSilentCallback}\n   *\n   * @throws `Error` If request_type is unknown or signin cannot be processed.\n   */\n  async signinCallback(url = window.location.href) {\n    const { state } = await this._client.readSigninResponseState(url);\n    switch (state.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(url);\n      case \"si:p\":\n        await this.signinPopupCallback(url);\n        break;\n      case \"si:s\":\n        await this.signinSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n    return void 0;\n  }\n  /**\n   * Process any response (callback) from the end session endpoint, by dispatching the request_type\n   * and executing one of the following functions:\n   * - {@link UserManager.signoutRedirectCallback}\n   * - {@link UserManager.signoutPopupCallback}\n   * - {@link UserManager.signoutSilentCallback}\n   *\n   * @throws `Error` If request_type is unknown or signout cannot be processed.\n   */\n  async signoutCallback(url = window.location.href, keepOpen = false) {\n    const { state } = await this._client.readSignoutResponseState(url);\n    if (!state) {\n      return void 0;\n    }\n    switch (state.request_type) {\n      case \"so:r\":\n        return await this.signoutRedirectCallback(url);\n      case \"so:p\":\n        await this.signoutPopupCallback(url, keepOpen);\n        break;\n      case \"so:s\":\n        await this.signoutSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n    return void 0;\n  }\n  /**\n   * Query OP for user's current signin status.\n   *\n   * @returns A promise object with session_state and subject identifier.\n   */\n  async querySessionStatus(args = {}) {\n    const logger2 = this._logger.create(\"querySessionStatus\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    const user = await this._loadUser();\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    const navResponse = await this._signinStart({\n      request_type: \"si:s\",\n      // this acts like a signin silent\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: true,\n      ...requestArgs\n    }, handle);\n    try {\n      const extraHeaders = {};\n      const signinResponse = await this._client.processSigninResponse(navResponse.url, extraHeaders);\n      logger2.debug(\"got signin response\");\n      if (signinResponse.session_state && signinResponse.profile.sub) {\n        logger2.info(\"success for subject\", signinResponse.profile.sub);\n        return {\n          session_state: signinResponse.session_state,\n          sub: signinResponse.profile.sub\n        };\n      }\n      logger2.info(\"success, user not authenticated\");\n      return null;\n    } catch (err) {\n      if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n        switch (err.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            logger2.info(\"success for anonymous user\");\n            return {\n              session_state: err.session_state\n            };\n        }\n      }\n      throw err;\n    }\n  }\n  async _signin(args, handle, verifySub) {\n    const navResponse = await this._signinStart(args, handle);\n    return await this._signinEnd(navResponse.url, verifySub);\n  }\n  async _signinStart(args, handle) {\n    const logger2 = this._logger.create(\"_signinStart\");\n    try {\n      const signinRequest = await this._client.createSigninRequest(args);\n      logger2.debug(\"got signin request\");\n      return await handle.navigate({\n        url: signinRequest.url,\n        state: signinRequest.state.id,\n        response_mode: signinRequest.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signinEnd(url, verifySub) {\n    const logger2 = this._logger.create(\"_signinEnd\");\n    const extraHeaders = {};\n    const signinResponse = await this._client.processSigninResponse(url, extraHeaders);\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse, verifySub);\n    return user;\n  }\n  async _buildUser(signinResponse, verifySub) {\n    const logger2 = this._logger.create(\"_buildUser\");\n    const user = new User(signinResponse);\n    if (verifySub) {\n      if (verifySub !== user.profile.sub) {\n        logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n        throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n      }\n      logger2.debug(\"current user matches user returned from signin\");\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    await this._events.load(user);\n    return user;\n  }\n  /**\n   * Trigger a redirect of the current window to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutRedirect(args = {}) {\n    const logger2 = this._logger.create(\"signoutRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({ redirectMethod });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process response (callback) from the end session endpoint.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise containing signout response\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutRedirectCallback\");\n    const response = await this._signoutEnd(url);\n    logger2.info(\"success\");\n    return response;\n  }\n  /**\n   * Trigger a redirect of a popup window to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutPopup(args = {}) {\n    const logger2 = this._logger.create(\"signoutPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: url,\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      state: url == null ? void 0 : {},\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process response (callback) from the end session endpoint from a popup window.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signoutPopupCallback\");\n    await this._popupNavigator.callback(url, { keepOpen });\n    logger2.info(\"success\");\n  }\n  async _signout(args, handle) {\n    const navResponse = await this._signoutStart(args, handle);\n    return await this._signoutEnd(navResponse.url);\n  }\n  async _signoutStart(args = {}, handle) {\n    var _a;\n    const logger2 = this._logger.create(\"_signoutStart\");\n    try {\n      const user = await this._loadUser();\n      logger2.debug(\"loaded current user from storage\");\n      if (this.settings.revokeTokensOnSignout) {\n        await this._revokeInternal(user);\n      }\n      const id_token = args.id_token_hint || user && user.id_token;\n      if (id_token) {\n        logger2.debug(\"setting id_token_hint in signout request\");\n        args.id_token_hint = id_token;\n      }\n      await this.removeUser();\n      logger2.debug(\"user removed, creating signout request\");\n      const signoutRequest = await this._client.createSignoutRequest(args);\n      logger2.debug(\"got signout request\");\n      return await handle.navigate({\n        url: signoutRequest.url,\n        state: (_a = signoutRequest.state) == null ? void 0 : _a.id,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signoutEnd(url) {\n    const logger2 = this._logger.create(\"_signoutEnd\");\n    const signoutResponse = await this._client.processSignoutResponse(url);\n    logger2.debug(\"got signout response\");\n    return signoutResponse;\n  }\n  /**\n   * Trigger a silent request (via an iframe) to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signoutSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: url,\n      id_token_hint,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Notify the parent window of response (callback) from the end session endpoint.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async revokeTokens(types) {\n    const user = await this._loadUser();\n    await this._revokeInternal(user, types);\n  }\n  async _revokeInternal(user, types = this.settings.revokeTokenTypes) {\n    const logger2 = this._logger.create(\"_revokeInternal\");\n    if (!user) return;\n    const typesPresent = types.filter((type) => typeof user[type] === \"string\");\n    if (!typesPresent.length) {\n      logger2.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n    for (const type of typesPresent) {\n      await this._client.revokeToken(\n        user[type],\n        type\n      );\n      logger2.info(`${type} revoked successfully`);\n      if (type !== \"access_token\") {\n        user[type] = null;\n      }\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    await this._events.load(user);\n  }\n  /**\n   * Enables silent renew for the `UserManager`.\n   */\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\");\n    void this._silentRenewService.start();\n  }\n  /**\n   * Disables silent renew for the `UserManager`.\n   */\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n  async _loadUser() {\n    const logger2 = this._logger.create(\"_loadUser\");\n    const storageString = await this.settings.userStore.get(this._userStoreKey);\n    if (storageString) {\n      logger2.debug(\"user storageString loaded\");\n      return User.fromStorageString(storageString);\n    }\n    logger2.debug(\"no user storageString\");\n    return null;\n  }\n  async storeUser(user) {\n    const logger2 = this._logger.create(\"storeUser\");\n    if (user) {\n      logger2.debug(\"storing user\");\n      const storageString = user.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, storageString);\n    } else {\n      this._logger.debug(\"removing user\");\n      await this.settings.userStore.remove(this._userStoreKey);\n      if (this.settings.dpop) {\n        await this.settings.dpop.store.remove(this.settings.client_id);\n      }\n    }\n  }\n  /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n  /**\n   * Dynamically generates a DPoP proof for a given user, URL and optional Http method.\n   * This method is useful when you need to make a request to a resource server\n   * with fetch or similar, and you need to include a DPoP proof in a DPoP header.\n   * @param url - The URL to generate the DPoP proof for\n   * @param user - The user to generate the DPoP proof for\n   * @param httpMethod - Optional, defaults to \"GET\"\n   * @param nonce - Optional nonce provided by the resource server\n   *\n   * @returns A promise containing the DPoP proof or undefined if DPoP is not enabled/no user is found.\n   */\n  async dpopProof(url, user, httpMethod, nonce) {\n    var _a, _b;\n    const dpopState = await ((_b = (_a = this.settings.dpop) == null ? void 0 : _a.store) == null ? void 0 : _b.get(this.settings.client_id));\n    if (dpopState) {\n      return await CryptoUtils.generateDPoPProof({\n        url,\n        accessToken: user == null ? void 0 : user.access_token,\n        httpMethod,\n        keyPair: dpopState.keys,\n        nonce\n      });\n    }\n    return void 0;\n  }\n  async generateDPoPJkt(dpopSettings) {\n    let dpopState = await dpopSettings.store.get(this.settings.client_id);\n    if (!dpopState) {\n      const dpopKeys = await CryptoUtils.generateDPoPKeys();\n      dpopState = new DPoPState(dpopKeys);\n      await dpopSettings.store.set(this.settings.client_id, dpopState);\n    }\n    return await CryptoUtils.generateDPoPJkt(dpopState.keys);\n  }\n};\n\n// package.json\nvar version = \"3.2.1\";\n\n// src/Version.ts\nvar Version = version;\n\n// src/IndexedDbDPoPStore.ts\nvar IndexedDbDPoPStore = class {\n  constructor() {\n    this._dbName = \"oidc\";\n    this._storeName = \"dpop\";\n  }\n  async set(key, value) {\n    const store = await this.createStore(this._dbName, this._storeName);\n    await store(\"readwrite\", (str) => {\n      str.put(value, key);\n      return this.promisifyRequest(str.transaction);\n    });\n  }\n  async get(key) {\n    const store = await this.createStore(this._dbName, this._storeName);\n    return await store(\"readonly\", (str) => {\n      return this.promisifyRequest(str.get(key));\n    });\n  }\n  async remove(key) {\n    const item = await this.get(key);\n    const store = await this.createStore(this._dbName, this._storeName);\n    await store(\"readwrite\", (str) => {\n      return this.promisifyRequest(str.delete(key));\n    });\n    return item;\n  }\n  async getAllKeys() {\n    const store = await this.createStore(this._dbName, this._storeName);\n    return await store(\"readonly\", (str) => {\n      return this.promisifyRequest(str.getAllKeys());\n    });\n  }\n  promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n      request.oncomplete = request.onsuccess = () => resolve(request.result);\n      request.onabort = request.onerror = () => reject(request.error);\n    });\n  }\n  async createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const db = await this.promisifyRequest(request);\n    return async (txMode, callback) => {\n      const tx = db.transaction(storeName, txMode);\n      const store = tx.objectStore(storeName);\n      return await callback(store);\n    };\n  }\n};\n\n//# sourceMappingURL=oidc-client-ts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vaWRjLWNsaWVudC10cy9kaXN0L2VzbS9vaWRjLWNsaWVudC10cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxXQUFXO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUssR0FBRyxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUIsdUJBQXVCLFFBQVEsRUFBRSxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFTO0FBQ3RCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjLEdBQUcsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLEdBQUcsaUJBQWlCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0REFBNEQsWUFBWTtBQUN4RSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNFQUFzRSxZQUFZO0FBQ2xGLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csSUFBSSxHQUFHLDBEQUEwRDtBQUNuSztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdURBQXVEO0FBQzNHLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsZ0RBQWdELGNBQWMsSUFBSTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixHQUFHLGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCLEdBQUcsZ0JBQWdCLEtBQUsscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrRUFBK0U7QUFDbkksTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBZ0QsY0FBYyxJQUFJO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQixHQUFHLGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixHQUFHLGdCQUFnQixLQUFLLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsc0dBQXNHO0FBQ2hMO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDBEQUEwRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwQkFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw0SUFBNEk7QUFDek07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrSEFBa0g7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdFQUFnRTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3RUFBd0U7QUFDcEg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxFQUFFLG9CQUFvQixFQUFFLFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdURBQXVEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkNBQTJDO0FBQzVFO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxFQUFFLG9CQUFvQixFQUFFLFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QscUJBQXFCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0VBQXdFLHlDQUF5QztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIO0FBQ3ZIO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOENBQThDLHVEQUF1RDtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDZCQUE2QixxREFBcUQ7QUFDbEY7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwRkFBMEY7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscURBQXFEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELCtCQUErQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0Q0FBNEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx3REFBd0QscURBQXFEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCLEdBQUcsd0JBQXdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0JFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9iY29ubi9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvY29tfmFwcGxlfkNsb3VkRG9jcy9Qcm9qZWN0cy9Wb3hQb3BfQWdlbnRpYy92b3hwb3BhaS9mcm9udGVuZC9ub2RlX21vZHVsZXMvb2lkYy1jbGllbnQtdHMvZGlzdC9lc20vb2lkYy1jbGllbnQtdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL0xvZ2dlci50c1xudmFyIG5vcExvZ2dlciA9IHtcbiAgZGVidWc6ICgpID0+IHZvaWQgMCxcbiAgaW5mbzogKCkgPT4gdm9pZCAwLFxuICB3YXJuOiAoKSA9PiB2b2lkIDAsXG4gIGVycm9yOiAoKSA9PiB2b2lkIDBcbn07XG52YXIgbGV2ZWw7XG52YXIgbG9nZ2VyO1xudmFyIExvZyA9IC8qIEBfX1BVUkVfXyAqLyAoKExvZzIpID0+IHtcbiAgTG9nMltMb2cyW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIExvZzJbTG9nMltcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG4gIExvZzJbTG9nMltcIldBUk5cIl0gPSAyXSA9IFwiV0FSTlwiO1xuICBMb2cyW0xvZzJbXCJJTkZPXCJdID0gM10gPSBcIklORk9cIjtcbiAgTG9nMltMb2cyW1wiREVCVUdcIl0gPSA0XSA9IFwiREVCVUdcIjtcbiAgcmV0dXJuIExvZzI7XG59KShMb2cgfHwge30pO1xuKChMb2cyKSA9PiB7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGxldmVsID0gMyAvKiBJTkZPICovO1xuICAgIGxvZ2dlciA9IG5vcExvZ2dlcjtcbiAgfVxuICBMb2cyLnJlc2V0ID0gcmVzZXQ7XG4gIGZ1bmN0aW9uIHNldExldmVsKHZhbHVlKSB7XG4gICAgaWYgKCEoMCAvKiBOT05FICovIDw9IHZhbHVlICYmIHZhbHVlIDw9IDQgLyogREVCVUcgKi8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvZyBsZXZlbFwiKTtcbiAgICB9XG4gICAgbGV2ZWwgPSB2YWx1ZTtcbiAgfVxuICBMb2cyLnNldExldmVsID0gc2V0TGV2ZWw7XG4gIGZ1bmN0aW9uIHNldExvZ2dlcih2YWx1ZSkge1xuICAgIGxvZ2dlciA9IHZhbHVlO1xuICB9XG4gIExvZzIuc2V0TG9nZ2VyID0gc2V0TG9nZ2VyO1xufSkoTG9nIHx8IChMb2cgPSB7fSkpO1xudmFyIExvZ2dlciA9IGNsYXNzIF9Mb2dnZXIge1xuICBjb25zdHJ1Y3RvcihfbmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBfbmFtZTtcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAqL1xuICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDQgLyogREVCVUcgKi8pIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhfTG9nZ2VyLl9mb3JtYXQodGhpcy5fbmFtZSwgdGhpcy5fbWV0aG9kKSwgLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIGluZm8oLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAzIC8qIElORk8gKi8pIHtcbiAgICAgIGxvZ2dlci5pbmZvKF9Mb2dnZXIuX2Zvcm1hdCh0aGlzLl9uYW1lLCB0aGlzLl9tZXRob2QpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgd2FybiguLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDIgLyogV0FSTiAqLykge1xuICAgICAgbG9nZ2VyLndhcm4oX0xvZ2dlci5fZm9ybWF0KHRoaXMuX25hbWUsIHRoaXMuX21ldGhvZCksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBlcnJvciguLi5hcmdzKSB7XG4gICAgaWYgKGxldmVsID49IDEgLyogRVJST1IgKi8pIHtcbiAgICAgIGxvZ2dlci5lcnJvcihfTG9nZ2VyLl9mb3JtYXQodGhpcy5fbmFtZSwgdGhpcy5fbWV0aG9kKSwgLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gKi9cbiAgdGhyb3coZXJyKSB7XG4gICAgdGhpcy5lcnJvcihlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBjcmVhdGUobWV0aG9kKSB7XG4gICAgY29uc3QgbWV0aG9kTG9nZ2VyID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBtZXRob2RMb2dnZXIuX21ldGhvZCA9IG1ldGhvZDtcbiAgICBtZXRob2RMb2dnZXIuZGVidWcoXCJiZWdpblwiKTtcbiAgICByZXR1cm4gbWV0aG9kTG9nZ2VyO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVTdGF0aWMobmFtZSwgc3RhdGljTWV0aG9kKSB7XG4gICAgY29uc3Qgc3RhdGljTG9nZ2VyID0gbmV3IF9Mb2dnZXIoYCR7bmFtZX0uJHtzdGF0aWNNZXRob2R9YCk7XG4gICAgc3RhdGljTG9nZ2VyLmRlYnVnKFwiYmVnaW5cIik7XG4gICAgcmV0dXJuIHN0YXRpY0xvZ2dlcjtcbiAgfVxuICBzdGF0aWMgX2Zvcm1hdChuYW1lLCBtZXRob2QpIHtcbiAgICBjb25zdCBwcmVmaXggPSBgWyR7bmFtZX1dYDtcbiAgICByZXR1cm4gbWV0aG9kID8gYCR7cHJlZml4fSAke21ldGhvZH06YCA6IHByZWZpeDtcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAqL1xuICAvLyBoZWxwZXJzIGZvciBzdGF0aWMgY2xhc3MgbWV0aG9kc1xuICBzdGF0aWMgZGVidWcobmFtZSwgLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSA0IC8qIERFQlVHICovKSB7XG4gICAgICBsb2dnZXIuZGVidWcoX0xvZ2dlci5fZm9ybWF0KG5hbWUpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGluZm8obmFtZSwgLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAzIC8qIElORk8gKi8pIHtcbiAgICAgIGxvZ2dlci5pbmZvKF9Mb2dnZXIuX2Zvcm1hdChuYW1lKSwgLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB3YXJuKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICBpZiAobGV2ZWwgPj0gMiAvKiBXQVJOICovKSB7XG4gICAgICBsb2dnZXIud2FybihfTG9nZ2VyLl9mb3JtYXQobmFtZSksIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZXJyb3IobmFtZSwgLi4uYXJncykge1xuICAgIGlmIChsZXZlbCA+PSAxIC8qIEVSUk9SICovKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoX0xvZ2dlci5fZm9ybWF0KG5hbWUpLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAqL1xufTtcbkxvZy5yZXNldCgpO1xuXG4vLyBzcmMvdXRpbHMvSnd0VXRpbHMudHNcbmltcG9ydCB7IGp3dERlY29kZSB9IGZyb20gXCJqd3QtZGVjb2RlXCI7XG52YXIgSnd0VXRpbHMgPSBjbGFzcyB7XG4gIC8vIElNUE9SVEFOVDogZG9lc24ndCB2YWxpZGF0ZSB0aGUgdG9rZW5cbiAgc3RhdGljIGRlY29kZSh0b2tlbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gand0RGVjb2RlKHRva2VuKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIExvZ2dlci5lcnJvcihcIkp3dFV0aWxzLmRlY29kZVwiLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVTaWduZWRKd3QoaGVhZGVyLCBwYXlsb2FkLCBwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgZW5jb2RlZEhlYWRlciA9IENyeXB0b1V0aWxzLmVuY29kZUJhc2U2NFVybChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSkpO1xuICAgIGNvbnN0IGVuY29kZWRQYXlsb2FkID0gQ3J5cHRvVXRpbHMuZW5jb2RlQmFzZTY0VXJsKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xuICAgIGNvbnN0IGVuY29kZWRUb2tlbiA9IGAke2VuY29kZWRIZWFkZXJ9LiR7ZW5jb2RlZFBheWxvYWR9YDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5zaWduKFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIkVDRFNBXCIsXG4gICAgICAgIGhhc2g6IHsgbmFtZTogXCJTSEEtMjU2XCIgfVxuICAgICAgfSxcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZW5jb2RlZFRva2VuKVxuICAgICk7XG4gICAgY29uc3QgZW5jb2RlZFNpZ25hdHVyZSA9IENyeXB0b1V0aWxzLmVuY29kZUJhc2U2NFVybChuZXcgVWludDhBcnJheShzaWduYXR1cmUpKTtcbiAgICByZXR1cm4gYCR7ZW5jb2RlZFRva2VufS4ke2VuY29kZWRTaWduYXR1cmV9YDtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL0NyeXB0b1V0aWxzLnRzXG52YXIgVVVJRF9WNF9URU1QTEFURSA9IFwiMTAwMDAwMDAtMTAwMC00MDAwLTgwMDAtMTAwMDAwMDAwMDAwXCI7XG52YXIgdG9CYXNlNjQgPSAodmFsKSA9PiBidG9hKFsuLi5uZXcgVWludDhBcnJheSh2YWwpXS5tYXAoKGNocikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpKS5qb2luKFwiXCIpKTtcbnZhciBfQ3J5cHRvVXRpbHMgPSBjbGFzcyBfQ3J5cHRvVXRpbHMge1xuICBzdGF0aWMgX3JhbmRvbVdvcmQoKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICByZXR1cm4gYXJyWzBdO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgUkZDNDEyMiB2ZXJzaW9uIDQgZ3VpZFxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlVVVJRHY0KCkge1xuICAgIGNvbnN0IHV1aWQgPSBVVUlEX1Y0X1RFTVBMQVRFLnJlcGxhY2UoXG4gICAgICAvWzAxOF0vZyxcbiAgICAgIChjKSA9PiAoK2MgXiBfQ3J5cHRvVXRpbHMuX3JhbmRvbVdvcmQoKSAmIDE1ID4+ICtjIC8gNCkudG9TdHJpbmcoMTYpXG4gICAgKTtcbiAgICByZXR1cm4gdXVpZC5yZXBsYWNlKC8tL2csIFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQS0NFOiBHZW5lcmF0ZSBhIGNvZGUgdmVyaWZpZXJcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZUNvZGVWZXJpZmllcigpIHtcbiAgICByZXR1cm4gX0NyeXB0b1V0aWxzLmdlbmVyYXRlVVVJRHY0KCkgKyBfQ3J5cHRvVXRpbHMuZ2VuZXJhdGVVVUlEdjQoKSArIF9DcnlwdG9VdGlscy5nZW5lcmF0ZVVVSUR2NCgpO1xuICB9XG4gIC8qKlxuICAgKiBQS0NFOiBHZW5lcmF0ZSBhIGNvZGUgY2hhbGxlbmdlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlKGNvZGVfdmVyaWZpZXIpIHtcbiAgICBpZiAoIWNyeXB0by5zdWJ0bGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNyeXB0by5zdWJ0bGUgaXMgYXZhaWxhYmxlIG9ubHkgaW4gc2VjdXJlIGNvbnRleHRzIChIVFRQUykuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgY29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGNvZGVfdmVyaWZpZXIpO1xuICAgICAgY29uc3QgaGFzaGVkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIsIGRhdGEpO1xuICAgICAgcmV0dXJuIHRvQmFzZTY0KGhhc2hlZCkucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgTG9nZ2VyLmVycm9yKFwiQ3J5cHRvVXRpbHMuZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlXCIsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgZm9yIGEgYmFzaWMgYXV0aCBoZWFkZXJcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZUJhc2ljQXV0aChjbGllbnRfaWQsIGNsaWVudF9zZWNyZXQpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKFtjbGllbnRfaWQsIGNsaWVudF9zZWNyZXRdLmpvaW4oXCI6XCIpKTtcbiAgICByZXR1cm4gdG9CYXNlNjQoZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGhhc2ggb2YgYSBzdHJpbmcgdXNpbmcgYSBnaXZlbiBhbGdvcml0aG1cbiAgICogQHBhcmFtIGFsZ1xuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGhhc2goYWxnLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgbXNnVWludDggPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWVzc2FnZSk7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KGFsZywgbXNnVWludDgpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShoYXNoQnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcmZjNzYzOCBjb21wbGlhbnQgandrIHRodW1icHJpbnRcbiAgICogQHBhcmFtIGp3a1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGN1c3RvbUNhbGN1bGF0ZUp3a1RodW1icHJpbnQoandrKSB7XG4gICAgbGV0IGpzb25PYmplY3Q7XG4gICAgc3dpdGNoIChqd2sua3R5KSB7XG4gICAgICBjYXNlIFwiUlNBXCI6XG4gICAgICAgIGpzb25PYmplY3QgPSB7XG4gICAgICAgICAgXCJlXCI6IGp3ay5lLFxuICAgICAgICAgIFwia3R5XCI6IGp3ay5rdHksXG4gICAgICAgICAgXCJuXCI6IGp3ay5uXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkVDXCI6XG4gICAgICAgIGpzb25PYmplY3QgPSB7XG4gICAgICAgICAgXCJjcnZcIjogandrLmNydixcbiAgICAgICAgICBcImt0eVwiOiBqd2sua3R5LFxuICAgICAgICAgIFwieFwiOiBqd2sueCxcbiAgICAgICAgICBcInlcIjogandrLnlcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiT0tQXCI6XG4gICAgICAgIGpzb25PYmplY3QgPSB7XG4gICAgICAgICAgXCJjcnZcIjogandrLmNydixcbiAgICAgICAgICBcImt0eVwiOiBqd2sua3R5LFxuICAgICAgICAgIFwieFwiOiBqd2sueFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvY3RcIjpcbiAgICAgICAganNvbk9iamVjdCA9IHtcbiAgICAgICAgICBcImNydlwiOiBqd2suayxcbiAgICAgICAgICBcImt0eVwiOiBqd2sua3R5XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBqd2sgdHlwZVwiKTtcbiAgICB9XG4gICAgY29uc3QgdXRmOGVuY29kZWRBbmRIYXNoZWQgPSBhd2FpdCBfQ3J5cHRvVXRpbHMuaGFzaChcIlNIQS0yNTZcIiwgSlNPTi5zdHJpbmdpZnkoanNvbk9iamVjdCkpO1xuICAgIHJldHVybiBfQ3J5cHRvVXRpbHMuZW5jb2RlQmFzZTY0VXJsKHV0ZjhlbmNvZGVkQW5kSGFzaGVkKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVEUG9QUHJvb2Yoe1xuICAgIHVybCxcbiAgICBhY2Nlc3NUb2tlbixcbiAgICBodHRwTWV0aG9kLFxuICAgIGtleVBhaXIsXG4gICAgbm9uY2VcbiAgfSkge1xuICAgIGxldCBoYXNoZWRUb2tlbjtcbiAgICBsZXQgZW5jb2RlZEhhc2g7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIFwianRpXCI6IHdpbmRvdy5jcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgXCJodG1cIjogaHR0cE1ldGhvZCAhPSBudWxsID8gaHR0cE1ldGhvZCA6IFwiR0VUXCIsXG4gICAgICBcImh0dVwiOiB1cmwsXG4gICAgICBcImlhdFwiOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpXG4gICAgfTtcbiAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgIGhhc2hlZFRva2VuID0gYXdhaXQgX0NyeXB0b1V0aWxzLmhhc2goXCJTSEEtMjU2XCIsIGFjY2Vzc1Rva2VuKTtcbiAgICAgIGVuY29kZWRIYXNoID0gX0NyeXB0b1V0aWxzLmVuY29kZUJhc2U2NFVybChoYXNoZWRUb2tlbik7XG4gICAgICBwYXlsb2FkLmF0aCA9IGVuY29kZWRIYXNoO1xuICAgIH1cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIHBheWxvYWQubm9uY2UgPSBub25jZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB1YmxpY0p3ayA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFwiandrXCIsIGtleVBhaXIucHVibGljS2V5KTtcbiAgICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgICAgXCJhbGdcIjogXCJFUzI1NlwiLFxuICAgICAgICBcInR5cFwiOiBcImRwb3Arand0XCIsXG4gICAgICAgIFwiandrXCI6IHtcbiAgICAgICAgICBcImNydlwiOiBwdWJsaWNKd2suY3J2LFxuICAgICAgICAgIFwia3R5XCI6IHB1YmxpY0p3ay5rdHksXG4gICAgICAgICAgXCJ4XCI6IHB1YmxpY0p3ay54LFxuICAgICAgICAgIFwieVwiOiBwdWJsaWNKd2sueVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGF3YWl0IEp3dFV0aWxzLmdlbmVyYXRlU2lnbmVkSnd0KGhlYWRlciwgcGF5bG9hZCwga2V5UGFpci5wcml2YXRlS2V5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBleHBvcnRpbmcgZHBvcCBwdWJsaWMga2V5OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVEUG9QSmt0KGtleVBhaXIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHVibGljSndrID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXCJqd2tcIiwga2V5UGFpci5wdWJsaWNLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IF9DcnlwdG9VdGlscy5jdXN0b21DYWxjdWxhdGVKd2tUaHVtYnByaW50KHB1YmxpY0p3ayk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJldHJpZXZlIGRwb3Aga2V5cyBmcm9tIHN0b3JhZ2U6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBnZW5lcmF0ZURQb1BLZXlzKCkge1xuICAgIHJldHVybiBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleShcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJFQ0RTQVwiLFxuICAgICAgICBuYW1lZEN1cnZlOiBcIlAtMjU2XCJcbiAgICAgIH0sXG4gICAgICBmYWxzZSxcbiAgICAgIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl1cbiAgICApO1xuICB9XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBiYXNlNjR1cmwgZW5jb2RlZCBzdHJpbmdcbiAqL1xuX0NyeXB0b1V0aWxzLmVuY29kZUJhc2U2NFVybCA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gdG9CYXNlNjQoaW5wdXQpLnJlcGxhY2UoLz0vZywgXCJcIikucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpO1xufTtcbnZhciBDcnlwdG9VdGlscyA9IF9DcnlwdG9VdGlscztcblxuLy8gc3JjL3V0aWxzL0V2ZW50LnRzXG52YXIgRXZlbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9uYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoYEV2ZW50KCcke3RoaXMuX25hbWV9JylgKTtcbiAgfVxuICBhZGRIYW5kbGVyKGNiKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIHJlbW92ZUhhbmRsZXIoY2IpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLl9jYWxsYmFja3MubGFzdEluZGV4T2YoY2IpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfVxuICBhc3luYyByYWlzZSguLi5ldikge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInJhaXNlOlwiLCAuLi5ldik7XG4gICAgZm9yIChjb25zdCBjYiBvZiB0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgIGF3YWl0IGNiKC4uLmV2KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9Qb3B1cFV0aWxzLnRzXG52YXIgUG9wdXBVdGlscyA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFBvcHVsYXRlcyBhIG1hcCBvZiB3aW5kb3cgZmVhdHVyZXMgd2l0aCBhIHBsYWNlbWVudCBjZW50ZXJlZCBpbiBmcm9udCBvZlxuICAgKiB0aGUgY3VycmVudCB3aW5kb3cuIElmIG5vIGV4cGxpY2l0IHdpZHRoIGlzIGdpdmVuLCBhIGRlZmF1bHQgdmFsdWUgaXNcbiAgICogYmlubmVkIGludG8gWzgwMCwgNzIwLCA2MDAsIDQ4MCwgMzYwXSBiYXNlZCBvbiB0aGUgY3VycmVudCB3aW5kb3cncyB3aWR0aC5cbiAgICovXG4gIHN0YXRpYyBjZW50ZXIoeyAuLi5mZWF0dXJlcyB9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKGZlYXR1cmVzLndpZHRoID09IG51bGwpXG4gICAgICBmZWF0dXJlcy53aWR0aCA9IChfYSA9IFs4MDAsIDcyMCwgNjAwLCA0ODBdLmZpbmQoKHdpZHRoKSA9PiB3aWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCAvIDEuNjE4KSkgIT0gbnVsbCA/IF9hIDogMzYwO1xuICAgIChfYiA9IGZlYXR1cmVzLmxlZnQpICE9IG51bGwgPyBfYiA6IGZlYXR1cmVzLmxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHdpbmRvdy5zY3JlZW5YICsgKHdpbmRvdy5vdXRlcldpZHRoIC0gZmVhdHVyZXMud2lkdGgpIC8gMikpO1xuICAgIGlmIChmZWF0dXJlcy5oZWlnaHQgIT0gbnVsbClcbiAgICAgIChfYyA9IGZlYXR1cmVzLnRvcCkgIT0gbnVsbCA/IF9jIDogZmVhdHVyZXMudG9wID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh3aW5kb3cuc2NyZWVuWSArICh3aW5kb3cub3V0ZXJIZWlnaHQgLSBmZWF0dXJlcy5oZWlnaHQpIC8gMikpO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuICBzdGF0aWMgc2VyaWFsaXplKGZlYXR1cmVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGZlYXR1cmVzKS5maWx0ZXIoKFssIHZhbHVlXSkgPT4gdmFsdWUgIT0gbnVsbCkubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX09JHt0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiID8gdmFsdWUgOiB2YWx1ZSA/IFwieWVzXCIgOiBcIm5vXCJ9YCkuam9pbihcIixcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9UaW1lci50c1xudmFyIFRpbWVyID0gY2xhc3MgX1RpbWVyIGV4dGVuZHMgRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoYFRpbWVyKCcke3RoaXMuX25hbWV9JylgKTtcbiAgICB0aGlzLl90aW1lckhhbmRsZSA9IG51bGw7XG4gICAgdGhpcy5fZXhwaXJhdGlvbiA9IDA7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkaWZmID0gdGhpcy5fZXhwaXJhdGlvbiAtIF9UaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhcInRpbWVyIGNvbXBsZXRlcyBpblwiLCBkaWZmKTtcbiAgICAgIGlmICh0aGlzLl9leHBpcmF0aW9uIDw9IF9UaW1lci5nZXRFcG9jaFRpbWUoKSkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB2b2lkIHN1cGVyLnJhaXNlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvLyBnZXQgdGhlIHRpbWVcbiAgc3RhdGljIGdldEVwb2NoVGltZSgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgfVxuICBpbml0KGR1cmF0aW9uSW5TZWNvbmRzKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJpbml0XCIpO1xuICAgIGR1cmF0aW9uSW5TZWNvbmRzID0gTWF0aC5tYXgoTWF0aC5mbG9vcihkdXJhdGlvbkluU2Vjb25kcyksIDEpO1xuICAgIGNvbnN0IGV4cGlyYXRpb24gPSBfVGltZXIuZ2V0RXBvY2hUaW1lKCkgKyBkdXJhdGlvbkluU2Vjb25kcztcbiAgICBpZiAodGhpcy5leHBpcmF0aW9uID09PSBleHBpcmF0aW9uICYmIHRoaXMuX3RpbWVySGFuZGxlKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwic2tpcHBpbmcgc2luY2UgYWxyZWFkeSBpbml0aWFsaXplZCBmb3IgZXhwaXJhdGlvbiBhdFwiLCB0aGlzLmV4cGlyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNhbmNlbCgpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2luZyBkdXJhdGlvblwiLCBkdXJhdGlvbkluU2Vjb25kcyk7XG4gICAgdGhpcy5fZXhwaXJhdGlvbiA9IGV4cGlyYXRpb247XG4gICAgY29uc3QgdGltZXJEdXJhdGlvbkluU2Vjb25kcyA9IE1hdGgubWluKGR1cmF0aW9uSW5TZWNvbmRzLCA1KTtcbiAgICB0aGlzLl90aW1lckhhbmRsZSA9IHNldEludGVydmFsKHRoaXMuX2NhbGxiYWNrLCB0aW1lckR1cmF0aW9uSW5TZWNvbmRzICogMWUzKTtcbiAgfVxuICBnZXQgZXhwaXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwaXJhdGlvbjtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNhbmNlbFwiKTtcbiAgICBpZiAodGhpcy5fdGltZXJIYW5kbGUpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdGltZXJIYW5kbGUpO1xuICAgICAgdGhpcy5fdGltZXJIYW5kbGUgPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL1VybFV0aWxzLnRzXG52YXIgVXJsVXRpbHMgPSBjbGFzcyB7XG4gIHN0YXRpYyByZWFkUGFyYW1zKHVybCwgcmVzcG9uc2VNb2RlID0gXCJxdWVyeVwiKSB7XG4gICAgaWYgKCF1cmwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFVSTFwiKTtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCwgXCJodHRwOi8vMTI3LjAuMC4xXCIpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHBhcnNlZFVybFtyZXNwb25zZU1vZGUgPT09IFwiZnJhZ21lbnRcIiA/IFwiaGFzaFwiIDogXCJzZWFyY2hcIl07XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zLnNsaWNlKDEpKTtcbiAgfVxufTtcbnZhciBVUkxfU1RBVEVfREVMSU1JVEVSID0gXCI7XCI7XG5cbi8vIHNyYy9lcnJvcnMvRXJyb3JSZXNwb25zZS50c1xudmFyIEVycm9yUmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoYXJncywgZm9ybSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHN1cGVyKGFyZ3MuZXJyb3JfZGVzY3JpcHRpb24gfHwgYXJncy5lcnJvciB8fCBcIlwiKTtcbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIC8qKiBNYXJrZXIgdG8gZGV0ZWN0IGNsYXNzOiBcIkVycm9yUmVzcG9uc2VcIiAqL1xuICAgIHRoaXMubmFtZSA9IFwiRXJyb3JSZXNwb25zZVwiO1xuICAgIGlmICghYXJncy5lcnJvcikge1xuICAgICAgTG9nZ2VyLmVycm9yKFwiRXJyb3JSZXNwb25zZVwiLCBcIk5vIGVycm9yIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5lcnJvciA9IGFyZ3MuZXJyb3I7XG4gICAgdGhpcy5lcnJvcl9kZXNjcmlwdGlvbiA9IChfYSA9IGFyZ3MuZXJyb3JfZGVzY3JpcHRpb24pICE9IG51bGwgPyBfYSA6IG51bGw7XG4gICAgdGhpcy5lcnJvcl91cmkgPSAoX2IgPSBhcmdzLmVycm9yX3VyaSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gYXJncy51c2VyU3RhdGU7XG4gICAgdGhpcy5zZXNzaW9uX3N0YXRlID0gKF9jID0gYXJncy5zZXNzaW9uX3N0YXRlKSAhPSBudWxsID8gX2MgOiBudWxsO1xuICAgIHRoaXMudXJsX3N0YXRlID0gYXJncy51cmxfc3RhdGU7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvcnMvRXJyb3JUaW1lb3V0LnRzXG52YXIgRXJyb3JUaW1lb3V0ID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvKiogTWFya2VyIHRvIGRldGVjdCBjbGFzczogXCJFcnJvclRpbWVvdXRcIiAqL1xuICAgIHRoaXMubmFtZSA9IFwiRXJyb3JUaW1lb3V0XCI7XG4gIH1cbn07XG5cbi8vIHNyYy9BY2Nlc3NUb2tlbkV2ZW50cy50c1xudmFyIEFjY2Vzc1Rva2VuRXZlbnRzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIkFjY2Vzc1Rva2VuRXZlbnRzXCIpO1xuICAgIHRoaXMuX2V4cGlyaW5nVGltZXIgPSBuZXcgVGltZXIoXCJBY2Nlc3MgdG9rZW4gZXhwaXJpbmdcIik7XG4gICAgdGhpcy5fZXhwaXJlZFRpbWVyID0gbmV3IFRpbWVyKFwiQWNjZXNzIHRva2VuIGV4cGlyZWRcIik7XG4gICAgdGhpcy5fZXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzID0gYXJncy5leHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHM7XG4gIH1cbiAgYXN5bmMgbG9hZChjb250YWluZXIpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImxvYWRcIik7XG4gICAgaWYgKGNvbnRhaW5lci5hY2Nlc3NfdG9rZW4gJiYgY29udGFpbmVyLmV4cGlyZXNfaW4gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjb250YWluZXIuZXhwaXJlc19pbjtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJhY2Nlc3MgdG9rZW4gcHJlc2VudCwgcmVtYWluaW5nIGR1cmF0aW9uOlwiLCBkdXJhdGlvbik7XG4gICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgIGxldCBleHBpcmluZyA9IGR1cmF0aW9uIC0gdGhpcy5fZXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzO1xuICAgICAgICBpZiAoZXhwaXJpbmcgPD0gMCkge1xuICAgICAgICAgIGV4cGlyaW5nID0gMTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIyLmRlYnVnKFwicmVnaXN0ZXJpbmcgZXhwaXJpbmcgdGltZXIsIHJhaXNpbmcgaW5cIiwgZXhwaXJpbmcsIFwic2Vjb25kc1wiKTtcbiAgICAgICAgdGhpcy5fZXhwaXJpbmdUaW1lci5pbml0KGV4cGlyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJjYW5jZWxpbmcgZXhpc3RpbmcgZXhwaXJpbmcgdGltZXIgYmVjYXVzZSB3ZSdyZSBwYXN0IGV4cGlyYXRpb24uXCIpO1xuICAgICAgICB0aGlzLl9leHBpcmluZ1RpbWVyLmNhbmNlbCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhwaXJlZCA9IGR1cmF0aW9uICsgMTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJyZWdpc3RlcmluZyBleHBpcmVkIHRpbWVyLCByYWlzaW5nIGluXCIsIGV4cGlyZWQsIFwic2Vjb25kc1wiKTtcbiAgICAgIHRoaXMuX2V4cGlyZWRUaW1lci5pbml0KGV4cGlyZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9leHBpcmluZ1RpbWVyLmNhbmNlbCgpO1xuICAgICAgdGhpcy5fZXhwaXJlZFRpbWVyLmNhbmNlbCgpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1bmxvYWQoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidW5sb2FkOiBjYW5jZWxpbmcgZXhpc3RpbmcgYWNjZXNzIHRva2VuIHRpbWVyc1wiKTtcbiAgICB0aGlzLl9leHBpcmluZ1RpbWVyLmNhbmNlbCgpO1xuICAgIHRoaXMuX2V4cGlyZWRUaW1lci5jYW5jZWwoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGNhbGxiYWNrOiBSYWlzZWQgcHJpb3IgdG8gdGhlIGFjY2VzcyB0b2tlbiBleHBpcmluZy5cbiAgICovXG4gIGFkZEFjY2Vzc1Rva2VuRXhwaXJpbmcoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwaXJpbmdUaW1lci5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgcHJpb3IgdG8gdGhlIGFjY2VzcyB0b2tlbiBleHBpcmluZy5cbiAgICovXG4gIHJlbW92ZUFjY2Vzc1Rva2VuRXhwaXJpbmcoY2IpIHtcbiAgICB0aGlzLl9leHBpcmluZ1RpbWVyLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCBhZnRlciB0aGUgYWNjZXNzIHRva2VuIGhhcyBleHBpcmVkLlxuICAgKi9cbiAgYWRkQWNjZXNzVG9rZW5FeHBpcmVkKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGlyZWRUaW1lci5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgYWZ0ZXIgdGhlIGFjY2VzcyB0b2tlbiBoYXMgZXhwaXJlZC5cbiAgICovXG4gIHJlbW92ZUFjY2Vzc1Rva2VuRXhwaXJlZChjYikge1xuICAgIHRoaXMuX2V4cGlyZWRUaW1lci5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxufTtcblxuLy8gc3JjL0NoZWNrU2Vzc2lvbklGcmFtZS50c1xudmFyIENoZWNrU2Vzc2lvbklGcmFtZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2NhbGxiYWNrLCBfY2xpZW50X2lkLCB1cmwsIF9pbnRlcnZhbEluU2Vjb25kcywgX3N0b3BPbkVycm9yKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBfY2FsbGJhY2s7XG4gICAgdGhpcy5fY2xpZW50X2lkID0gX2NsaWVudF9pZDtcbiAgICB0aGlzLl9pbnRlcnZhbEluU2Vjb25kcyA9IF9pbnRlcnZhbEluU2Vjb25kcztcbiAgICB0aGlzLl9zdG9wT25FcnJvciA9IF9zdG9wT25FcnJvcjtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiQ2hlY2tTZXNzaW9uSUZyYW1lXCIpO1xuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9zZXNzaW9uX3N0YXRlID0gbnVsbDtcbiAgICB0aGlzLl9tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5fZnJhbWVfb3JpZ2luICYmIGUuc291cmNlID09PSB0aGlzLl9mcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgIGlmIChlLmRhdGEgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImVycm9yIG1lc3NhZ2UgZnJvbSBjaGVjayBzZXNzaW9uIG9wIGlmcmFtZVwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fc3RvcE9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEgPT09IFwiY2hhbmdlZFwiKSB7XG4gICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwiY2hhbmdlZCBtZXNzYWdlIGZyb20gY2hlY2sgc2Vzc2lvbiBvcCBpZnJhbWVcIik7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgdm9pZCB0aGlzLl9jYWxsYmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhlLmRhdGEgKyBcIiBtZXNzYWdlIGZyb20gY2hlY2sgc2Vzc2lvbiBvcCBpZnJhbWVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICB0aGlzLl9mcmFtZV9vcmlnaW4gPSBwYXJzZWRVcmwub3JpZ2luO1xuICAgIHRoaXMuX2ZyYW1lID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgdGhpcy5fZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgdGhpcy5fZnJhbWUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgdGhpcy5fZnJhbWUuc3R5bGUubGVmdCA9IFwiLTEwMDBweFwiO1xuICAgIHRoaXMuX2ZyYW1lLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gXCIwXCI7XG4gICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgdGhpcy5fZnJhbWUuc3JjID0gcGFyc2VkVXJsLmhyZWY7XG4gIH1cbiAgbG9hZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX2ZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2ZyYW1lKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9tZXNzYWdlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhcnQoc2Vzc2lvbl9zdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zZXNzaW9uX3N0YXRlID09PSBzZXNzaW9uX3N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzdGFydFwiKTtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLl9zZXNzaW9uX3N0YXRlID0gc2Vzc2lvbl9zdGF0ZTtcbiAgICBjb25zdCBzZW5kID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9mcmFtZS5jb250ZW50V2luZG93IHx8ICF0aGlzLl9zZXNzaW9uX3N0YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UodGhpcy5fY2xpZW50X2lkICsgXCIgXCIgKyB0aGlzLl9zZXNzaW9uX3N0YXRlLCB0aGlzLl9mcmFtZV9vcmlnaW4pO1xuICAgIH07XG4gICAgc2VuZCgpO1xuICAgIHRoaXMuX3RpbWVyID0gc2V0SW50ZXJ2YWwoc2VuZCwgdGhpcy5faW50ZXJ2YWxJblNlY29uZHMgKiAxZTMpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInN0b3BcIik7XG4gICAgdGhpcy5fc2Vzc2lvbl9zdGF0ZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVyKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9Jbk1lbW9yeVdlYlN0b3JhZ2UudHNcbnZhciBJbk1lbW9yeVdlYlN0b3JhZ2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJJbk1lbW9yeVdlYlN0b3JhZ2VcIik7XG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjbGVhclwiKTtcbiAgICB0aGlzLl9kYXRhID0ge307XG4gIH1cbiAgZ2V0SXRlbShrZXkpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKGBnZXRJdGVtKCcke2tleX0nKWApO1xuICAgIHJldHVybiB0aGlzLl9kYXRhW2tleV07XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShgc2V0SXRlbSgnJHtrZXl9JylgKTtcbiAgICB0aGlzLl9kYXRhW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoYHJlbW92ZUl0ZW0oJyR7a2V5fScpYCk7XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFba2V5XTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9kYXRhKS5sZW5ndGg7XG4gIH1cbiAga2V5KGluZGV4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX2RhdGEpW2luZGV4XTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9ycy9FcnJvckRQb1BOb25jZS50c1xudmFyIEVycm9yRFBvUE5vbmNlID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG5vbmNlLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgLyoqIE1hcmtlciB0byBkZXRlY3QgY2xhc3M6IFwiRXJyb3JEUG9QTm9uY2VcIiAqL1xuICAgIHRoaXMubmFtZSA9IFwiRXJyb3JEUG9QTm9uY2VcIjtcbiAgICB0aGlzLm5vbmNlID0gbm9uY2U7XG4gIH1cbn07XG5cbi8vIHNyYy9Kc29uU2VydmljZS50c1xudmFyIEpzb25TZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhZGRpdGlvbmFsQ29udGVudFR5cGVzID0gW10sIF9qd3RIYW5kbGVyID0gbnVsbCwgX2V4dHJhSGVhZGVycyA9IHt9KSB7XG4gICAgdGhpcy5fand0SGFuZGxlciA9IF9qd3RIYW5kbGVyO1xuICAgIHRoaXMuX2V4dHJhSGVhZGVycyA9IF9leHRyYUhlYWRlcnM7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIkpzb25TZXJ2aWNlXCIpO1xuICAgIHRoaXMuX2NvbnRlbnRUeXBlcyA9IFtdO1xuICAgIHRoaXMuX2NvbnRlbnRUeXBlcy5wdXNoKC4uLmFkZGl0aW9uYWxDb250ZW50VHlwZXMsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICBpZiAoX2p3dEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnRUeXBlcy5wdXNoKFwiYXBwbGljYXRpb24vand0XCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaFdpdGhUaW1lb3V0KGlucHV0LCBpbml0ID0ge30pIHtcbiAgICBjb25zdCB7IHRpbWVvdXRJblNlY29uZHMsIC4uLmluaXRGZXRjaCB9ID0gaW5pdDtcbiAgICBpZiAoIXRpbWVvdXRJblNlY29uZHMpIHtcbiAgICAgIHJldHVybiBhd2FpdCBmZXRjaChpbnB1dCwgaW5pdEZldGNoKTtcbiAgICB9XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dEluU2Vjb25kcyAqIDFlMyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaW5wdXQsIHtcbiAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JUaW1lb3V0KFwiTmV0d29yayB0aW1lZCBvdXRcIik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRKc29uKHVybCwge1xuICAgIHRva2VuLFxuICAgIGNyZWRlbnRpYWxzLFxuICAgIHRpbWVvdXRJblNlY29uZHNcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJnZXRKc29uXCIpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkFjY2VwdFwiOiB0aGlzLl9jb250ZW50VHlwZXMuam9pbihcIiwgXCIpXG4gICAgfTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ0b2tlbiBwYXNzZWQsIHNldHRpbmcgQXV0aG9yaXphdGlvbiBoZWFkZXJcIik7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmVhcmVyIFwiICsgdG9rZW47XG4gICAgfVxuICAgIHRoaXMuX2FwcGVuZEV4dHJhSGVhZGVycyhoZWFkZXJzKTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ1cmw6XCIsIHVybCk7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dCh1cmwsIHsgbWV0aG9kOiBcIkdFVFwiLCBoZWFkZXJzLCB0aW1lb3V0SW5TZWNvbmRzLCBjcmVkZW50aWFscyB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlcjIuZXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwiSFRUUCByZXNwb25zZSByZWNlaXZlZCwgc3RhdHVzXCIsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBpZiAoY29udGVudFR5cGUgJiYgIXRoaXMuX2NvbnRlbnRUeXBlcy5maW5kKChpdGVtKSA9PiBjb250ZW50VHlwZS5zdGFydHNXaXRoKGl0ZW0pKSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgQ29udGVudC1UeXBlOiAke2NvbnRlbnRUeXBlICE9IG51bGwgPyBjb250ZW50VHlwZSA6IFwidW5kZWZpbmVkXCJ9LCBmcm9tIFVSTDogJHt1cmx9YCkpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uub2sgJiYgdGhpcy5fand0SGFuZGxlciAmJiAoY29udGVudFR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9qd3RcIikpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fand0SGFuZGxlcihhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgIH1cbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBwYXJzaW5nIEpTT04gcmVzcG9uc2VcIiwgZXJyKTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykgdGhyb3cgZXJyO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICgke3Jlc3BvbnNlLnN0YXR1c30pYCk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBmcm9tIHNlcnZlcjpcIiwganNvbik7XG4gICAgICBpZiAoanNvbi5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZShqc29uKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoJHtyZXNwb25zZS5zdGF0dXN9KTogJHtKU09OLnN0cmluZ2lmeShqc29uKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgYXN5bmMgcG9zdEZvcm0odXJsLCB7XG4gICAgYm9keSxcbiAgICBiYXNpY0F1dGgsXG4gICAgdGltZW91dEluU2Vjb25kcyxcbiAgICBpbml0Q3JlZGVudGlhbHMsXG4gICAgZXh0cmFIZWFkZXJzXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInBvc3RGb3JtXCIpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkFjY2VwdFwiOiB0aGlzLl9jb250ZW50VHlwZXMuam9pbihcIiwgXCIpLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICAgIC4uLmV4dHJhSGVhZGVyc1xuICAgIH07XG4gICAgaWYgKGJhc2ljQXV0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmFzaWMgXCIgKyBiYXNpY0F1dGg7XG4gICAgfVxuICAgIHRoaXMuX2FwcGVuZEV4dHJhSGVhZGVycyhoZWFkZXJzKTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJ1cmw6XCIsIHVybCk7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dCh1cmwsIHsgbWV0aG9kOiBcIlBPU1RcIiwgaGVhZGVycywgYm9keSwgdGltZW91dEluU2Vjb25kcywgY3JlZGVudGlhbHM6IGluaXRDcmVkZW50aWFscyB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlcjIuZXJyb3IoXCJOZXR3b3JrIGVycm9yXCIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwiSFRUUCByZXNwb25zZSByZWNlaXZlZCwgc3RhdHVzXCIsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBpZiAoY29udGVudFR5cGUgJiYgIXRoaXMuX2NvbnRlbnRUeXBlcy5maW5kKChpdGVtKSA9PiBjb250ZW50VHlwZS5zdGFydHNXaXRoKGl0ZW0pKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIENvbnRlbnQtVHlwZTogJHtjb250ZW50VHlwZSAhPSBudWxsID8gY29udGVudFR5cGUgOiBcInVuZGVmaW5lZFwifSwgZnJvbSBVUkw6ICR7dXJsfWApO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICBpZiAocmVzcG9uc2VUZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBwYXJzaW5nIEpTT04gcmVzcG9uc2VcIiwgZXJyKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB0aHJvdyBlcnI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAoJHtyZXNwb25zZS5zdGF0dXN9KWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgZnJvbSBzZXJ2ZXI6XCIsIGpzb24pO1xuICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiZHBvcC1ub25jZVwiKSkge1xuICAgICAgICBjb25zdCBub25jZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiZHBvcC1ub25jZVwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yRFBvUE5vbmNlKG5vbmNlLCBgJHtKU09OLnN0cmluZ2lmeShqc29uKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChqc29uLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlKGpzb24sIGJvZHkpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICgke3Jlc3BvbnNlLnN0YXR1c30pOiAke0pTT04uc3RyaW5naWZ5KGpzb24pfWApO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICBfYXBwZW5kRXh0cmFIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImFwcGVuZEV4dHJhSGVhZGVyc1wiKTtcbiAgICBjb25zdCBjdXN0b21LZXlzID0gT2JqZWN0LmtleXModGhpcy5fZXh0cmFIZWFkZXJzKTtcbiAgICBjb25zdCBwcm90ZWN0ZWRIZWFkZXJzID0gW1xuICAgICAgXCJhY2NlcHRcIixcbiAgICAgIFwiY29udGVudC10eXBlXCJcbiAgICBdO1xuICAgIGNvbnN0IHByZXZlbnRPdmVycmlkZSA9IFtcbiAgICAgIFwiYXV0aG9yaXphdGlvblwiXG4gICAgXTtcbiAgICBpZiAoY3VzdG9tS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VzdG9tS2V5cy5mb3JFYWNoKChoZWFkZXJOYW1lKSA9PiB7XG4gICAgICBpZiAocHJvdGVjdGVkSGVhZGVycy5pbmNsdWRlcyhoZWFkZXJOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGxvZ2dlcjIud2FybihcIlByb3RlY3RlZCBoZWFkZXIgY291bGQgbm90IGJlIHNldFwiLCBoZWFkZXJOYW1lLCBwcm90ZWN0ZWRIZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZlbnRPdmVycmlkZS5pbmNsdWRlcyhoZWFkZXJOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkpICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpLmluY2x1ZGVzKGhlYWRlck5hbWUpKSB7XG4gICAgICAgIGxvZ2dlcjIud2FybihcIkhlYWRlciBjb3VsZCBub3QgYmUgb3ZlcnJpZGRlblwiLCBoZWFkZXJOYW1lLCBwcmV2ZW50T3ZlcnJpZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIHRoaXMuX2V4dHJhSGVhZGVyc1toZWFkZXJOYW1lXSA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fZXh0cmFIZWFkZXJzW2hlYWRlck5hbWVdKCkgOiB0aGlzLl9leHRyYUhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICBpZiAoY29udGVudCAmJiBjb250ZW50ICE9PSBcIlwiKSB7XG4gICAgICAgIGhlYWRlcnNbaGVhZGVyTmFtZV0gPSBjb250ZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvTWV0YWRhdGFTZXJ2aWNlLnRzXG52YXIgTWV0YWRhdGFTZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiTWV0YWRhdGFTZXJ2aWNlXCIpO1xuICAgIHRoaXMuX3NpZ25pbmdLZXlzID0gbnVsbDtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IG51bGw7XG4gICAgdGhpcy5fbWV0YWRhdGFVcmwgPSB0aGlzLl9zZXR0aW5ncy5tZXRhZGF0YVVybDtcbiAgICB0aGlzLl9qc29uU2VydmljZSA9IG5ldyBKc29uU2VydmljZShcbiAgICAgIFtcImFwcGxpY2F0aW9uL2p3ay1zZXQranNvblwiXSxcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLl9zZXR0aW5ncy5leHRyYUhlYWRlcnNcbiAgICApO1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zaWduaW5nS2V5cykge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidXNpbmcgc2lnbmluZ0tleXMgZnJvbSBzZXR0aW5nc1wiKTtcbiAgICAgIHRoaXMuX3NpZ25pbmdLZXlzID0gdGhpcy5fc2V0dGluZ3Muc2lnbmluZ0tleXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tZXRhZGF0YSkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidXNpbmcgbWV0YWRhdGEgZnJvbSBzZXR0aW5nc1wiKTtcbiAgICAgIHRoaXMuX21ldGFkYXRhID0gdGhpcy5fc2V0dGluZ3MubWV0YWRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5mZXRjaFJlcXVlc3RDcmVkZW50aWFscykge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwidXNpbmcgZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgZnJvbSBzZXR0aW5nc1wiKTtcbiAgICAgIHRoaXMuX2ZldGNoUmVxdWVzdENyZWRlbnRpYWxzID0gdGhpcy5fc2V0dGluZ3MuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHM7XG4gICAgfVxuICB9XG4gIHJlc2V0U2lnbmluZ0tleXMoKSB7XG4gICAgdGhpcy5fc2lnbmluZ0tleXMgPSBudWxsO1xuICB9XG4gIGFzeW5jIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0TWV0YWRhdGFcIik7XG4gICAgaWYgKHRoaXMuX21ldGFkYXRhKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwidXNpbmcgY2FjaGVkIHZhbHVlc1wiKTtcbiAgICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9tZXRhZGF0YVVybCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBhdXRob3JpdHkgb3IgbWV0YWRhdGFVcmwgY29uZmlndXJlZCBvbiBzZXR0aW5nc1wiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwiZ2V0dGluZyBtZXRhZGF0YSBmcm9tXCIsIHRoaXMuX21ldGFkYXRhVXJsKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLmdldEpzb24odGhpcy5fbWV0YWRhdGFVcmwsIHsgY3JlZGVudGlhbHM6IHRoaXMuX2ZldGNoUmVxdWVzdENyZWRlbnRpYWxzLCB0aW1lb3V0SW5TZWNvbmRzOiB0aGlzLl9zZXR0aW5ncy5yZXF1ZXN0VGltZW91dEluU2Vjb25kcyB9KTtcbiAgICBsb2dnZXIyLmRlYnVnKFwibWVyZ2luZyByZW1vdGUgSlNPTiB3aXRoIHNlZWQgbWV0YWRhdGFcIik7XG4gICAgdGhpcy5fbWV0YWRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSwgdGhpcy5fc2V0dGluZ3MubWV0YWRhdGFTZWVkKTtcbiAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGE7XG4gIH1cbiAgZ2V0SXNzdWVyKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwiaXNzdWVyXCIpO1xuICB9XG4gIGdldEF1dGhvcml6YXRpb25FbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcImF1dGhvcml6YXRpb25fZW5kcG9pbnRcIik7XG4gIH1cbiAgZ2V0VXNlckluZm9FbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TWV0YWRhdGFQcm9wZXJ0eShcInVzZXJpbmZvX2VuZHBvaW50XCIpO1xuICB9XG4gIGdldFRva2VuRW5kcG9pbnQob3B0aW9uYWwgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE1ldGFkYXRhUHJvcGVydHkoXCJ0b2tlbl9lbmRwb2ludFwiLCBvcHRpb25hbCk7XG4gIH1cbiAgZ2V0Q2hlY2tTZXNzaW9uSWZyYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwiY2hlY2tfc2Vzc2lvbl9pZnJhbWVcIiwgdHJ1ZSk7XG4gIH1cbiAgZ2V0RW5kU2Vzc2lvbkVuZHBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwiZW5kX3Nlc3Npb25fZW5kcG9pbnRcIiwgdHJ1ZSk7XG4gIH1cbiAgZ2V0UmV2b2NhdGlvbkVuZHBvaW50KG9wdGlvbmFsID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwicmV2b2NhdGlvbl9lbmRwb2ludFwiLCBvcHRpb25hbCk7XG4gIH1cbiAgZ2V0S2V5c0VuZHBvaW50KG9wdGlvbmFsID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRNZXRhZGF0YVByb3BlcnR5KFwiandrc191cmlcIiwgb3B0aW9uYWwpO1xuICB9XG4gIGFzeW5jIF9nZXRNZXRhZGF0YVByb3BlcnR5KG5hbWUsIG9wdGlvbmFsID0gZmFsc2UpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShgX2dldE1ldGFkYXRhUHJvcGVydHkoJyR7bmFtZX0nKWApO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5nZXRNZXRhZGF0YSgpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJyZXNvbHZlZFwiKTtcbiAgICBpZiAobWV0YWRhdGFbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgaWYgKG9wdGlvbmFsID09PSB0cnVlKSB7XG4gICAgICAgIGxvZ2dlcjIud2FybihcIk1ldGFkYXRhIGRvZXMgbm90IGNvbnRhaW4gb3B0aW9uYWwgcHJvcGVydHlcIik7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk1ldGFkYXRhIGRvZXMgbm90IGNvbnRhaW4gcHJvcGVydHkgXCIgKyBuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YVtuYW1lXTtcbiAgfVxuICBhc3luYyBnZXRTaWduaW5nS2V5cygpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImdldFNpZ25pbmdLZXlzXCIpO1xuICAgIGlmICh0aGlzLl9zaWduaW5nS2V5cykge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInJldHVybmluZyBzaWduaW5nS2V5cyBmcm9tIGNhY2hlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX3NpZ25pbmdLZXlzO1xuICAgIH1cbiAgICBjb25zdCBqd2tzX3VyaSA9IGF3YWl0IHRoaXMuZ2V0S2V5c0VuZHBvaW50KGZhbHNlKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IGp3a3NfdXJpXCIsIGp3a3NfdXJpKTtcbiAgICBjb25zdCBrZXlTZXQgPSBhd2FpdCB0aGlzLl9qc29uU2VydmljZS5nZXRKc29uKGp3a3NfdXJpLCB7IHRpbWVvdXRJblNlY29uZHM6IHRoaXMuX3NldHRpbmdzLnJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qga2V5IHNldFwiLCBrZXlTZXQpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlTZXQua2V5cykpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTWlzc2luZyBrZXlzIG9uIGtleXNldFwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9zaWduaW5nS2V5cyA9IGtleVNldC5rZXlzO1xuICAgIHJldHVybiB0aGlzLl9zaWduaW5nS2V5cztcbiAgfVxufTtcblxuLy8gc3JjL1dlYlN0b3JhZ2VTdGF0ZVN0b3JlLnRzXG52YXIgV2ViU3RvcmFnZVN0YXRlU3RvcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwcmVmaXggPSBcIm9pZGMuXCIsXG4gICAgc3RvcmUgPSBsb2NhbFN0b3JhZ2VcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIldlYlN0b3JhZ2VTdGF0ZVN0b3JlXCIpO1xuICAgIHRoaXMuX3N0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5fcHJlZml4ID0gcHJlZml4O1xuICB9XG4gIGFzeW5jIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShgc2V0KCcke2tleX0nKWApO1xuICAgIGtleSA9IHRoaXMuX3ByZWZpeCArIGtleTtcbiAgICBhd2FpdCB0aGlzLl9zdG9yZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGdldChrZXkpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKGBnZXQoJyR7a2V5fScpYCk7XG4gICAga2V5ID0gdGhpcy5fcHJlZml4ICsga2V5O1xuICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCB0aGlzLl9zdG9yZS5nZXRJdGVtKGtleSk7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgYXN5bmMgcmVtb3ZlKGtleSkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoYHJlbW92ZSgnJHtrZXl9JylgKTtcbiAgICBrZXkgPSB0aGlzLl9wcmVmaXggKyBrZXk7XG4gICAgY29uc3QgaXRlbSA9IGF3YWl0IHRoaXMuX3N0b3JlLmdldEl0ZW0oa2V5KTtcbiAgICBhd2FpdCB0aGlzLl9zdG9yZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgYXN5bmMgZ2V0QWxsS2V5cygpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZ2V0QWxsS2V5c1wiKTtcbiAgICBjb25zdCBsZW4gPSBhd2FpdCB0aGlzLl9zdG9yZS5sZW5ndGg7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuX3N0b3JlLmtleShpbmRleCk7XG4gICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKHRoaXMuX3ByZWZpeCkgPT09IDApIHtcbiAgICAgICAga2V5cy5wdXNoKGtleS5zdWJzdHIodGhpcy5fcHJlZml4Lmxlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxufTtcblxuLy8gc3JjL09pZGNDbGllbnRTZXR0aW5ncy50c1xudmFyIERlZmF1bHRSZXNwb25zZVR5cGUgPSBcImNvZGVcIjtcbnZhciBEZWZhdWx0U2NvcGUgPSBcIm9wZW5pZFwiO1xudmFyIERlZmF1bHRDbGllbnRBdXRoZW50aWNhdGlvbiA9IFwiY2xpZW50X3NlY3JldF9wb3N0XCI7XG52YXIgRGVmYXVsdFN0YWxlU3RhdGVBZ2VJblNlY29uZHMgPSA2MCAqIDE1O1xudmFyIE9pZGNDbGllbnRTZXR0aW5nc1N0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gbWV0YWRhdGEgcmVsYXRlZFxuICAgIGF1dGhvcml0eSxcbiAgICBtZXRhZGF0YVVybCxcbiAgICBtZXRhZGF0YSxcbiAgICBzaWduaW5nS2V5cyxcbiAgICBtZXRhZGF0YVNlZWQsXG4gICAgLy8gY2xpZW50IHJlbGF0ZWRcbiAgICBjbGllbnRfaWQsXG4gICAgY2xpZW50X3NlY3JldCxcbiAgICByZXNwb25zZV90eXBlID0gRGVmYXVsdFJlc3BvbnNlVHlwZSxcbiAgICBzY29wZSA9IERlZmF1bHRTY29wZSxcbiAgICByZWRpcmVjdF91cmksXG4gICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgIGNsaWVudF9hdXRoZW50aWNhdGlvbiA9IERlZmF1bHRDbGllbnRBdXRoZW50aWNhdGlvbixcbiAgICAvLyBvcHRpb25hbCBwcm90b2NvbFxuICAgIHByb21wdCxcbiAgICBkaXNwbGF5LFxuICAgIG1heF9hZ2UsXG4gICAgdWlfbG9jYWxlcyxcbiAgICBhY3JfdmFsdWVzLFxuICAgIHJlc291cmNlLFxuICAgIHJlc3BvbnNlX21vZGUsXG4gICAgLy8gYmVoYXZpb3IgZmxhZ3NcbiAgICBmaWx0ZXJQcm90b2NvbENsYWltcyA9IHRydWUsXG4gICAgbG9hZFVzZXJJbmZvID0gZmFsc2UsXG4gICAgcmVxdWVzdFRpbWVvdXRJblNlY29uZHMsXG4gICAgc3RhbGVTdGF0ZUFnZUluU2Vjb25kcyA9IERlZmF1bHRTdGFsZVN0YXRlQWdlSW5TZWNvbmRzLFxuICAgIG1lcmdlQ2xhaW1zU3RyYXRlZ3kgPSB7IGFycmF5OiBcInJlcGxhY2VcIiB9LFxuICAgIGRpc2FibGVQS0NFID0gZmFsc2UsXG4gICAgLy8gb3RoZXIgYmVoYXZpb3JcbiAgICBzdGF0ZVN0b3JlLFxuICAgIHJldm9rZVRva2VuQWRkaXRpb25hbENvbnRlbnRUeXBlcyxcbiAgICBmZXRjaFJlcXVlc3RDcmVkZW50aWFscyxcbiAgICByZWZyZXNoVG9rZW5BbGxvd2VkU2NvcGUsXG4gICAgLy8gZXh0cmFcbiAgICBleHRyYVF1ZXJ5UGFyYW1zID0ge30sXG4gICAgZXh0cmFUb2tlblBhcmFtcyA9IHt9LFxuICAgIGV4dHJhSGVhZGVycyA9IHt9LFxuICAgIGRwb3AsXG4gICAgb21pdFNjb3BlV2hlblJlcXVlc3RpbmcgPSBmYWxzZVxuICB9KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuYXV0aG9yaXR5ID0gYXV0aG9yaXR5O1xuICAgIGlmIChtZXRhZGF0YVVybCkge1xuICAgICAgdGhpcy5tZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1ldGFkYXRhVXJsID0gYXV0aG9yaXR5O1xuICAgICAgaWYgKGF1dGhvcml0eSkge1xuICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGFVcmwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgdGhpcy5tZXRhZGF0YVVybCArPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhVXJsICs9IFwiLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMubWV0YWRhdGFTZWVkID0gbWV0YWRhdGFTZWVkO1xuICAgIHRoaXMuc2lnbmluZ0tleXMgPSBzaWduaW5nS2V5cztcbiAgICB0aGlzLmNsaWVudF9pZCA9IGNsaWVudF9pZDtcbiAgICB0aGlzLmNsaWVudF9zZWNyZXQgPSBjbGllbnRfc2VjcmV0O1xuICAgIHRoaXMucmVzcG9uc2VfdHlwZSA9IHJlc3BvbnNlX3R5cGU7XG4gICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIHRoaXMucmVkaXJlY3RfdXJpID0gcmVkaXJlY3RfdXJpO1xuICAgIHRoaXMucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpID0gcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpO1xuICAgIHRoaXMuY2xpZW50X2F1dGhlbnRpY2F0aW9uID0gY2xpZW50X2F1dGhlbnRpY2F0aW9uO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICAgIHRoaXMuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgdGhpcy5tYXhfYWdlID0gbWF4X2FnZTtcbiAgICB0aGlzLnVpX2xvY2FsZXMgPSB1aV9sb2NhbGVzO1xuICAgIHRoaXMuYWNyX3ZhbHVlcyA9IGFjcl92YWx1ZXM7XG4gICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIHRoaXMucmVzcG9uc2VfbW9kZSA9IHJlc3BvbnNlX21vZGU7XG4gICAgdGhpcy5maWx0ZXJQcm90b2NvbENsYWltcyA9IGZpbHRlclByb3RvY29sQ2xhaW1zICE9IG51bGwgPyBmaWx0ZXJQcm90b2NvbENsYWltcyA6IHRydWU7XG4gICAgdGhpcy5sb2FkVXNlckluZm8gPSAhIWxvYWRVc2VySW5mbztcbiAgICB0aGlzLnN0YWxlU3RhdGVBZ2VJblNlY29uZHMgPSBzdGFsZVN0YXRlQWdlSW5TZWNvbmRzO1xuICAgIHRoaXMubWVyZ2VDbGFpbXNTdHJhdGVneSA9IG1lcmdlQ2xhaW1zU3RyYXRlZ3k7XG4gICAgdGhpcy5vbWl0U2NvcGVXaGVuUmVxdWVzdGluZyA9IG9taXRTY29wZVdoZW5SZXF1ZXN0aW5nO1xuICAgIHRoaXMuZGlzYWJsZVBLQ0UgPSAhIWRpc2FibGVQS0NFO1xuICAgIHRoaXMucmV2b2tlVG9rZW5BZGRpdGlvbmFsQ29udGVudFR5cGVzID0gcmV2b2tlVG9rZW5BZGRpdGlvbmFsQ29udGVudFR5cGVzO1xuICAgIHRoaXMuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgPSBmZXRjaFJlcXVlc3RDcmVkZW50aWFscyA/IGZldGNoUmVxdWVzdENyZWRlbnRpYWxzIDogXCJzYW1lLW9yaWdpblwiO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXRJblNlY29uZHMgPSByZXF1ZXN0VGltZW91dEluU2Vjb25kcztcbiAgICBpZiAoc3RhdGVTdG9yZSkge1xuICAgICAgdGhpcy5zdGF0ZVN0b3JlID0gc3RhdGVTdG9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RvcmUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmxvY2FsU3RvcmFnZSA6IG5ldyBJbk1lbW9yeVdlYlN0b3JhZ2UoKTtcbiAgICAgIHRoaXMuc3RhdGVTdG9yZSA9IG5ldyBXZWJTdG9yYWdlU3RhdGVTdG9yZSh7IHN0b3JlIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hUb2tlbkFsbG93ZWRTY29wZSA9IHJlZnJlc2hUb2tlbkFsbG93ZWRTY29wZTtcbiAgICB0aGlzLmV4dHJhUXVlcnlQYXJhbXMgPSBleHRyYVF1ZXJ5UGFyYW1zO1xuICAgIHRoaXMuZXh0cmFUb2tlblBhcmFtcyA9IGV4dHJhVG9rZW5QYXJhbXM7XG4gICAgdGhpcy5leHRyYUhlYWRlcnMgPSBleHRyYUhlYWRlcnM7XG4gICAgdGhpcy5kcG9wID0gZHBvcDtcbiAgICBpZiAodGhpcy5kcG9wICYmICEoKF9hID0gdGhpcy5kcG9wKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RvcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIERQb1BTdG9yZSBpcyByZXF1aXJlZCB3aGVuIGRwb3AgaXMgZW5hYmxlZFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9Vc2VySW5mb1NlcnZpY2UudHNcbnZhciBVc2VySW5mb1NlcnZpY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9zZXR0aW5ncywgX21ldGFkYXRhU2VydmljZSkge1xuICAgIHRoaXMuX3NldHRpbmdzID0gX3NldHRpbmdzO1xuICAgIHRoaXMuX21ldGFkYXRhU2VydmljZSA9IF9tZXRhZGF0YVNlcnZpY2U7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlVzZXJJbmZvU2VydmljZVwiKTtcbiAgICB0aGlzLl9nZXRDbGFpbXNGcm9tSnd0ID0gYXN5bmMgKHJlc3BvbnNlVGV4dCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfZ2V0Q2xhaW1zRnJvbUp3dFwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKd3RVdGlscy5kZWNvZGUocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIkpXVCBkZWNvZGluZyBzdWNjZXNzZnVsXCIpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIyLmVycm9yKFwiRXJyb3IgcGFyc2luZyBKV1QgcmVzcG9uc2VcIik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2pzb25TZXJ2aWNlID0gbmV3IEpzb25TZXJ2aWNlKFxuICAgICAgdm9pZCAwLFxuICAgICAgdGhpcy5fZ2V0Q2xhaW1zRnJvbUp3dCxcbiAgICAgIHRoaXMuX3NldHRpbmdzLmV4dHJhSGVhZGVyc1xuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhaW1zKHRva2VuKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJnZXRDbGFpbXNcIik7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRocm93KG5ldyBFcnJvcihcIk5vIHRva2VuIHBhc3NlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRVc2VySW5mb0VuZHBvaW50KCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCB1c2VyaW5mbyB1cmxcIiwgdXJsKTtcbiAgICBjb25zdCBjbGFpbXMgPSBhd2FpdCB0aGlzLl9qc29uU2VydmljZS5nZXRKc29uKHVybCwge1xuICAgICAgdG9rZW4sXG4gICAgICBjcmVkZW50aWFsczogdGhpcy5fc2V0dGluZ3MuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMsXG4gICAgICB0aW1lb3V0SW5TZWNvbmRzOiB0aGlzLl9zZXR0aW5ncy5yZXF1ZXN0VGltZW91dEluU2Vjb25kc1xuICAgIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgY2xhaW1zXCIsIGNsYWltcyk7XG4gICAgcmV0dXJuIGNsYWltcztcbiAgfVxufTtcblxuLy8gc3JjL1Rva2VuQ2xpZW50LnRzXG52YXIgVG9rZW5DbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9zZXR0aW5ncywgX21ldGFkYXRhU2VydmljZSkge1xuICAgIHRoaXMuX3NldHRpbmdzID0gX3NldHRpbmdzO1xuICAgIHRoaXMuX21ldGFkYXRhU2VydmljZSA9IF9tZXRhZGF0YVNlcnZpY2U7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlRva2VuQ2xpZW50XCIpO1xuICAgIHRoaXMuX2pzb25TZXJ2aWNlID0gbmV3IEpzb25TZXJ2aWNlKFxuICAgICAgdGhpcy5fc2V0dGluZ3MucmV2b2tlVG9rZW5BZGRpdGlvbmFsQ29udGVudFR5cGVzLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMuX3NldHRpbmdzLmV4dHJhSGVhZGVyc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEV4Y2hhbmdlIGNvZGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkjc2VjdGlvbi00LjEuM1xuICAgKi9cbiAgYXN5bmMgZXhjaGFuZ2VDb2RlKHtcbiAgICBncmFudF90eXBlID0gXCJhdXRob3JpemF0aW9uX2NvZGVcIixcbiAgICByZWRpcmVjdF91cmkgPSB0aGlzLl9zZXR0aW5ncy5yZWRpcmVjdF91cmksXG4gICAgY2xpZW50X2lkID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkLFxuICAgIGNsaWVudF9zZWNyZXQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0LFxuICAgIGV4dHJhSGVhZGVycyxcbiAgICAuLi5hcmdzXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImV4Y2hhbmdlQ29kZVwiKTtcbiAgICBpZiAoIWNsaWVudF9pZCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNsaWVudF9pZCBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGlmICghcmVkaXJlY3RfdXJpKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgcmVkaXJlY3RfdXJpIGlzIHJlcXVpcmVkXCIpKTtcbiAgICB9XG4gICAgaWYgKCFhcmdzLmNvZGUpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjb2RlIGlzIHJlcXVpcmVkXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGdyYW50X3R5cGUsIHJlZGlyZWN0X3VyaSB9KTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmdzKSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGJhc2ljQXV0aDtcbiAgICBzd2l0Y2ggKHRoaXMuX3NldHRpbmdzLmNsaWVudF9hdXRoZW50aWNhdGlvbikge1xuICAgICAgY2FzZSBcImNsaWVudF9zZWNyZXRfYmFzaWNcIjpcbiAgICAgICAgaWYgKGNsaWVudF9zZWNyZXQgPT09IHZvaWQgMCB8fCBjbGllbnRfc2VjcmV0ID09PSBudWxsKSB7XG4gICAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNsaWVudF9zZWNyZXQgaXMgcmVxdWlyZWRcIikpO1xuICAgICAgICAgIHRocm93IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYmFzaWNBdXRoID0gQ3J5cHRvVXRpbHMuZ2VuZXJhdGVCYXNpY0F1dGgoY2xpZW50X2lkLCBjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2xpZW50X3NlY3JldF9wb3N0XCI6XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJjbGllbnRfaWRcIiwgY2xpZW50X2lkKTtcbiAgICAgICAgaWYgKGNsaWVudF9zZWNyZXQpIHtcbiAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiY2xpZW50X3NlY3JldFwiLCBjbGllbnRfc2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlLmdldFRva2VuRW5kcG9pbnQoZmFsc2UpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgdG9rZW4gZW5kcG9pbnRcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9qc29uU2VydmljZS5wb3N0Rm9ybSh1cmwsIHtcbiAgICAgIGJvZHk6IHBhcmFtcyxcbiAgICAgIGJhc2ljQXV0aCxcbiAgICAgIHRpbWVvdXRJblNlY29uZHM6IHRoaXMuX3NldHRpbmdzLnJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgaW5pdENyZWRlbnRpYWxzOiB0aGlzLl9zZXR0aW5ncy5mZXRjaFJlcXVlc3RDcmVkZW50aWFscyxcbiAgICAgIGV4dHJhSGVhZGVyc1xuICAgIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBFeGNoYW5nZSBjcmVkZW50aWFscy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OSNzZWN0aW9uLTQuMy4yXG4gICAqL1xuICBhc3luYyBleGNoYW5nZUNyZWRlbnRpYWxzKHtcbiAgICBncmFudF90eXBlID0gXCJwYXNzd29yZFwiLFxuICAgIGNsaWVudF9pZCA9IHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCxcbiAgICBjbGllbnRfc2VjcmV0ID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X3NlY3JldCxcbiAgICBzY29wZSA9IHRoaXMuX3NldHRpbmdzLnNjb3BlLFxuICAgIC4uLmFyZ3NcbiAgfSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZXhjaGFuZ2VDcmVkZW50aWFsc1wiKTtcbiAgICBpZiAoIWNsaWVudF9pZCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIGNsaWVudF9pZCBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBncmFudF90eXBlIH0pO1xuICAgIGlmICghdGhpcy5fc2V0dGluZ3Mub21pdFNjb3BlV2hlblJlcXVlc3RpbmcpIHtcbiAgICAgIHBhcmFtcy5zZXQoXCJzY29wZVwiLCBzY29wZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFyZ3MpKSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYmFzaWNBdXRoO1xuICAgIHN3aXRjaCAodGhpcy5fc2V0dGluZ3MuY2xpZW50X2F1dGhlbnRpY2F0aW9uKSB7XG4gICAgICBjYXNlIFwiY2xpZW50X3NlY3JldF9iYXNpY1wiOlxuICAgICAgICBpZiAoY2xpZW50X3NlY3JldCA9PT0gdm9pZCAwIHx8IGNsaWVudF9zZWNyZXQgPT09IG51bGwpIHtcbiAgICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgY2xpZW50X3NlY3JldCBpcyByZXF1aXJlZFwiKSk7XG4gICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBiYXNpY0F1dGggPSBDcnlwdG9VdGlscy5nZW5lcmF0ZUJhc2ljQXV0aChjbGllbnRfaWQsIGNsaWVudF9zZWNyZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjbGllbnRfc2VjcmV0X3Bvc3RcIjpcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcImNsaWVudF9pZFwiLCBjbGllbnRfaWQpO1xuICAgICAgICBpZiAoY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJjbGllbnRfc2VjcmV0XCIsIGNsaWVudF9zZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0VG9rZW5FbmRwb2ludChmYWxzZSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCB0b2tlbiBlbmRwb2ludFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLnBvc3RGb3JtKHVybCwgeyBib2R5OiBwYXJhbXMsIGJhc2ljQXV0aCwgdGltZW91dEluU2Vjb25kczogdGhpcy5fc2V0dGluZ3MucmVxdWVzdFRpbWVvdXRJblNlY29uZHMsIGluaXRDcmVkZW50aWFsczogdGhpcy5fc2V0dGluZ3MuZmV0Y2hSZXF1ZXN0Q3JlZGVudGlhbHMgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCByZXNwb25zZVwiKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIEV4Y2hhbmdlIGEgcmVmcmVzaCB0b2tlbi5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OSNzZWN0aW9uLTZcbiAgICovXG4gIGFzeW5jIGV4Y2hhbmdlUmVmcmVzaFRva2VuKHtcbiAgICBncmFudF90eXBlID0gXCJyZWZyZXNoX3Rva2VuXCIsXG4gICAgY2xpZW50X2lkID0gdGhpcy5fc2V0dGluZ3MuY2xpZW50X2lkLFxuICAgIGNsaWVudF9zZWNyZXQgPSB0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0LFxuICAgIHRpbWVvdXRJblNlY29uZHMsXG4gICAgZXh0cmFIZWFkZXJzLFxuICAgIC4uLmFyZ3NcbiAgfSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiZXhjaGFuZ2VSZWZyZXNoVG9rZW5cIik7XG4gICAgaWYgKCFjbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSBjbGllbnRfaWQgaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBpZiAoIWFyZ3MucmVmcmVzaF90b2tlbikge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJBIHJlZnJlc2hfdG9rZW4gaXMgcmVxdWlyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgZ3JhbnRfdHlwZSB9KTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmdzKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHBhcmFtKSA9PiBwYXJhbXMuYXBwZW5kKGtleSwgcGFyYW0pKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYmFzaWNBdXRoO1xuICAgIHN3aXRjaCAodGhpcy5fc2V0dGluZ3MuY2xpZW50X2F1dGhlbnRpY2F0aW9uKSB7XG4gICAgICBjYXNlIFwiY2xpZW50X3NlY3JldF9iYXNpY1wiOlxuICAgICAgICBpZiAoY2xpZW50X3NlY3JldCA9PT0gdm9pZCAwIHx8IGNsaWVudF9zZWNyZXQgPT09IG51bGwpIHtcbiAgICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIkEgY2xpZW50X3NlY3JldCBpcyByZXF1aXJlZFwiKSk7XG4gICAgICAgICAgdGhyb3cgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBiYXNpY0F1dGggPSBDcnlwdG9VdGlscy5nZW5lcmF0ZUJhc2ljQXV0aChjbGllbnRfaWQsIGNsaWVudF9zZWNyZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjbGllbnRfc2VjcmV0X3Bvc3RcIjpcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcImNsaWVudF9pZFwiLCBjbGllbnRfaWQpO1xuICAgICAgICBpZiAoY2xpZW50X3NlY3JldCkge1xuICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJjbGllbnRfc2VjcmV0XCIsIGNsaWVudF9zZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9tZXRhZGF0YVNlcnZpY2UuZ2V0VG9rZW5FbmRwb2ludChmYWxzZSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCB0b2tlbiBlbmRwb2ludFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2pzb25TZXJ2aWNlLnBvc3RGb3JtKHVybCwgeyBib2R5OiBwYXJhbXMsIGJhc2ljQXV0aCwgdGltZW91dEluU2Vjb25kcywgaW5pdENyZWRlbnRpYWxzOiB0aGlzLl9zZXR0aW5ncy5mZXRjaFJlcXVlc3RDcmVkZW50aWFscywgZXh0cmFIZWFkZXJzIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBSZXZva2UgYW4gYWNjZXNzIG9yIHJlZnJlc2ggdG9rZW4uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3MDA5I3NlY3Rpb24tMi4xXG4gICAqL1xuICBhc3luYyByZXZva2UoYXJncykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInJldm9rZVwiKTtcbiAgICBpZiAoIWFyZ3MudG9rZW4pIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiQSB0b2tlbiBpcyByZXF1aXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX21ldGFkYXRhU2VydmljZS5nZXRSZXZvY2F0aW9uRW5kcG9pbnQoZmFsc2UpO1xuICAgIGxvZ2dlcjIuZGVidWcoYGdvdCByZXZvY2F0aW9uIGVuZHBvaW50LCByZXZva2luZyAkeyhfYSA9IGFyZ3MudG9rZW5fdHlwZV9oaW50KSAhPSBudWxsID8gX2EgOiBcImRlZmF1bHQgdG9rZW4gdHlwZVwifWApO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmdzKSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1zLnNldChcImNsaWVudF9pZFwiLCB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQpO1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0KSB7XG4gICAgICBwYXJhbXMuc2V0KFwiY2xpZW50X3NlY3JldFwiLCB0aGlzLl9zZXR0aW5ncy5jbGllbnRfc2VjcmV0KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fanNvblNlcnZpY2UucG9zdEZvcm0odXJsLCB7IGJvZHk6IHBhcmFtcywgdGltZW91dEluU2Vjb25kczogdGhpcy5fc2V0dGluZ3MucmVxdWVzdFRpbWVvdXRJblNlY29uZHMgfSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCByZXNwb25zZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL1Jlc3BvbnNlVmFsaWRhdG9yLnRzXG52YXIgUmVzcG9uc2VWYWxpZGF0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9zZXR0aW5ncywgX21ldGFkYXRhU2VydmljZSwgX2NsYWltc1NlcnZpY2UpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9tZXRhZGF0YVNlcnZpY2UgPSBfbWV0YWRhdGFTZXJ2aWNlO1xuICAgIHRoaXMuX2NsYWltc1NlcnZpY2UgPSBfY2xhaW1zU2VydmljZTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiUmVzcG9uc2VWYWxpZGF0b3JcIik7XG4gICAgdGhpcy5fdXNlckluZm9TZXJ2aWNlID0gbmV3IFVzZXJJbmZvU2VydmljZSh0aGlzLl9zZXR0aW5ncywgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlKTtcbiAgICB0aGlzLl90b2tlbkNsaWVudCA9IG5ldyBUb2tlbkNsaWVudCh0aGlzLl9zZXR0aW5ncywgdGhpcy5fbWV0YWRhdGFTZXJ2aWNlKTtcbiAgfVxuICBhc3luYyB2YWxpZGF0ZVNpZ25pblJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSwgZXh0cmFIZWFkZXJzKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJ2YWxpZGF0ZVNpZ25pblJlc3BvbnNlXCIpO1xuICAgIHRoaXMuX3Byb2Nlc3NTaWduaW5TdGF0ZShyZXNwb25zZSwgc3RhdGUpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJzdGF0ZSBwcm9jZXNzZWRcIik7XG4gICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0NvZGUocmVzcG9uc2UsIHN0YXRlLCBleHRyYUhlYWRlcnMpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJjb2RlIHByb2Nlc3NlZFwiKTtcbiAgICBpZiAocmVzcG9uc2UuaXNPcGVuSWQpIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSWRUb2tlbkF0dHJpYnV0ZXMocmVzcG9uc2UpO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwidG9rZW5zIHZhbGlkYXRlZFwiKTtcbiAgICBhd2FpdCB0aGlzLl9wcm9jZXNzQ2xhaW1zKHJlc3BvbnNlLCBzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuc2tpcFVzZXJJbmZvLCByZXNwb25zZS5pc09wZW5JZCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImNsYWltcyBwcm9jZXNzZWRcIik7XG4gIH1cbiAgYXN5bmMgdmFsaWRhdGVDcmVkZW50aWFsc1Jlc3BvbnNlKHJlc3BvbnNlLCBza2lwVXNlckluZm8pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInZhbGlkYXRlQ3JlZGVudGlhbHNSZXNwb25zZVwiKTtcbiAgICBjb25zdCBzaG91bGRWYWxpZGF0ZVN1YkNsYWltID0gcmVzcG9uc2UuaXNPcGVuSWQgJiYgISFyZXNwb25zZS5pZF90b2tlbjtcbiAgICBpZiAoc2hvdWxkVmFsaWRhdGVTdWJDbGFpbSkge1xuICAgICAgdGhpcy5fdmFsaWRhdGVJZFRva2VuQXR0cmlidXRlcyhyZXNwb25zZSk7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJ0b2tlbnMgdmFsaWRhdGVkXCIpO1xuICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NDbGFpbXMocmVzcG9uc2UsIHNraXBVc2VySW5mbywgc2hvdWxkVmFsaWRhdGVTdWJDbGFpbSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImNsYWltcyBwcm9jZXNzZWRcIik7XG4gIH1cbiAgYXN5bmMgdmFsaWRhdGVSZWZyZXNoUmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInZhbGlkYXRlUmVmcmVzaFJlc3BvbnNlXCIpO1xuICAgIHJlc3BvbnNlLnVzZXJTdGF0ZSA9IHN0YXRlLmRhdGE7XG4gICAgKF9hID0gcmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSkgIT0gbnVsbCA/IF9hIDogcmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSA9IHN0YXRlLnNlc3Npb25fc3RhdGU7XG4gICAgKF9iID0gcmVzcG9uc2Uuc2NvcGUpICE9IG51bGwgPyBfYiA6IHJlc3BvbnNlLnNjb3BlID0gc3RhdGUuc2NvcGU7XG4gICAgaWYgKHJlc3BvbnNlLmlzT3BlbklkICYmICEhcmVzcG9uc2UuaWRfdG9rZW4pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSWRUb2tlbkF0dHJpYnV0ZXMocmVzcG9uc2UsIHN0YXRlLmlkX3Rva2VuKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJJRCBUb2tlbiB2YWxpZGF0ZWRcIik7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuaWRfdG9rZW4pIHtcbiAgICAgIHJlc3BvbnNlLmlkX3Rva2VuID0gc3RhdGUuaWRfdG9rZW47XG4gICAgICByZXNwb25zZS5wcm9maWxlID0gc3RhdGUucHJvZmlsZTtcbiAgICB9XG4gICAgY29uc3QgaGFzSWRUb2tlbiA9IHJlc3BvbnNlLmlzT3BlbklkICYmICEhcmVzcG9uc2UuaWRfdG9rZW47XG4gICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0NsYWltcyhyZXNwb25zZSwgZmFsc2UsIGhhc0lkVG9rZW4pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJjbGFpbXMgcHJvY2Vzc2VkXCIpO1xuICB9XG4gIHZhbGlkYXRlU2lnbm91dFJlc3BvbnNlKHJlc3BvbnNlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwidmFsaWRhdGVTaWdub3V0UmVzcG9uc2VcIik7XG4gICAgaWYgKHN0YXRlLmlkICE9PSByZXNwb25zZS5zdGF0ZSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJTdGF0ZSBkb2VzIG5vdCBtYXRjaFwiKSk7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJzdGF0ZSB2YWxpZGF0ZWRcIik7XG4gICAgcmVzcG9uc2UudXNlclN0YXRlID0gc3RhdGUuZGF0YTtcbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIGxvZ2dlcjIud2FybihcIlJlc3BvbnNlIHdhcyBlcnJvclwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfVxuICB9XG4gIF9wcm9jZXNzU2lnbmluU3RhdGUocmVzcG9uc2UsIHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3Byb2Nlc3NTaWduaW5TdGF0ZVwiKTtcbiAgICBpZiAoc3RhdGUuaWQgIT09IHJlc3BvbnNlLnN0YXRlKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIlN0YXRlIGRvZXMgbm90IG1hdGNoXCIpKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5jbGllbnRfaWQpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gY2xpZW50X2lkIG9uIHN0YXRlXCIpKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5hdXRob3JpdHkpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gYXV0aG9yaXR5IG9uIHN0YXRlXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmF1dGhvcml0eSAhPT0gc3RhdGUuYXV0aG9yaXR5KSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcImF1dGhvcml0eSBtaXNtYXRjaCBvbiBzZXR0aW5ncyB2cy4gc2lnbmluIHN0YXRlXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmNsaWVudF9pZCAmJiB0aGlzLl9zZXR0aW5ncy5jbGllbnRfaWQgIT09IHN0YXRlLmNsaWVudF9pZCkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJjbGllbnRfaWQgbWlzbWF0Y2ggb24gc2V0dGluZ3MgdnMuIHNpZ25pbiBzdGF0ZVwiKSk7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJzdGF0ZSB2YWxpZGF0ZWRcIik7XG4gICAgcmVzcG9uc2UudXNlclN0YXRlID0gc3RhdGUuZGF0YTtcbiAgICByZXNwb25zZS51cmxfc3RhdGUgPSBzdGF0ZS51cmxfc3RhdGU7XG4gICAgKF9hID0gcmVzcG9uc2Uuc2NvcGUpICE9IG51bGwgPyBfYSA6IHJlc3BvbnNlLnNjb3BlID0gc3RhdGUuc2NvcGU7XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICBsb2dnZXIyLndhcm4oXCJSZXNwb25zZSB3YXMgZXJyb3JcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29kZV92ZXJpZmllciAmJiAhcmVzcG9uc2UuY29kZSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJFeHBlY3RlZCBjb2RlIGluIHJlc3BvbnNlXCIpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX3Byb2Nlc3NDbGFpbXMocmVzcG9uc2UsIHNraXBVc2VySW5mbyA9IGZhbHNlLCB2YWxpZGF0ZVN1YiA9IHRydWUpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9wcm9jZXNzQ2xhaW1zXCIpO1xuICAgIHJlc3BvbnNlLnByb2ZpbGUgPSB0aGlzLl9jbGFpbXNTZXJ2aWNlLmZpbHRlclByb3RvY29sQ2xhaW1zKHJlc3BvbnNlLnByb2ZpbGUpO1xuICAgIGlmIChza2lwVXNlckluZm8gfHwgIXRoaXMuX3NldHRpbmdzLmxvYWRVc2VySW5mbyB8fCAhcmVzcG9uc2UuYWNjZXNzX3Rva2VuKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwibm90IGxvYWRpbmcgdXNlciBpbmZvXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIyLmRlYnVnKFwibG9hZGluZyB1c2VyIGluZm9cIik7XG4gICAgY29uc3QgY2xhaW1zID0gYXdhaXQgdGhpcy5fdXNlckluZm9TZXJ2aWNlLmdldENsYWltcyhyZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2VyIGluZm8gY2xhaW1zIHJlY2VpdmVkIGZyb20gdXNlciBpbmZvIGVuZHBvaW50XCIpO1xuICAgIGlmICh2YWxpZGF0ZVN1YiAmJiBjbGFpbXMuc3ViICE9PSByZXNwb25zZS5wcm9maWxlLnN1Yikge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJzdWJqZWN0IGZyb20gVXNlckluZm8gcmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggc3ViamVjdCBpbiBJRCBUb2tlblwiKSk7XG4gICAgfVxuICAgIHJlc3BvbnNlLnByb2ZpbGUgPSB0aGlzLl9jbGFpbXNTZXJ2aWNlLm1lcmdlQ2xhaW1zKHJlc3BvbnNlLnByb2ZpbGUsIHRoaXMuX2NsYWltc1NlcnZpY2UuZmlsdGVyUHJvdG9jb2xDbGFpbXMoY2xhaW1zKSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgaW5mbyBjbGFpbXMgcmVjZWl2ZWQsIHVwZGF0ZWQgcHJvZmlsZTpcIiwgcmVzcG9uc2UucHJvZmlsZSk7XG4gIH1cbiAgYXN5bmMgX3Byb2Nlc3NDb2RlKHJlc3BvbnNlLCBzdGF0ZSwgZXh0cmFIZWFkZXJzKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfcHJvY2Vzc0NvZGVcIik7XG4gICAgaWYgKHJlc3BvbnNlLmNvZGUpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJWYWxpZGF0aW5nIGNvZGVcIik7XG4gICAgICBjb25zdCB0b2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdG9rZW5DbGllbnQuZXhjaGFuZ2VDb2RlKHtcbiAgICAgICAgY2xpZW50X2lkOiBzdGF0ZS5jbGllbnRfaWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IHN0YXRlLmNsaWVudF9zZWNyZXQsXG4gICAgICAgIGNvZGU6IHJlc3BvbnNlLmNvZGUsXG4gICAgICAgIHJlZGlyZWN0X3VyaTogc3RhdGUucmVkaXJlY3RfdXJpLFxuICAgICAgICBjb2RlX3ZlcmlmaWVyOiBzdGF0ZS5jb2RlX3ZlcmlmaWVyLFxuICAgICAgICBleHRyYUhlYWRlcnMsXG4gICAgICAgIC4uLnN0YXRlLmV4dHJhVG9rZW5QYXJhbXNcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihyZXNwb25zZSwgdG9rZW5SZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJObyBjb2RlIHRvIHByb2Nlc3NcIik7XG4gICAgfVxuICB9XG4gIF92YWxpZGF0ZUlkVG9rZW5BdHRyaWJ1dGVzKHJlc3BvbnNlLCBleGlzdGluZ1Rva2VuKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3ZhbGlkYXRlSWRUb2tlbkF0dHJpYnV0ZXNcIik7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImRlY29kaW5nIElEIFRva2VuIEpXVFwiKTtcbiAgICBjb25zdCBpbmNvbWluZyA9IEp3dFV0aWxzLmRlY29kZSgoX2EgPSByZXNwb25zZS5pZF90b2tlbikgIT0gbnVsbCA/IF9hIDogXCJcIik7XG4gICAgaWYgKCFpbmNvbWluZy5zdWIpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiSUQgVG9rZW4gaXMgbWlzc2luZyBhIHN1YmplY3QgY2xhaW1cIikpO1xuICAgIH1cbiAgICBpZiAoZXhpc3RpbmdUb2tlbikge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBKd3RVdGlscy5kZWNvZGUoZXhpc3RpbmdUb2tlbik7XG4gICAgICBpZiAoaW5jb21pbmcuc3ViICE9PSBleGlzdGluZy5zdWIpIHtcbiAgICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJzdWIgaW4gaWRfdG9rZW4gZG9lcyBub3QgbWF0Y2ggY3VycmVudCBzdWJcIikpO1xuICAgICAgfVxuICAgICAgaWYgKGluY29taW5nLmF1dGhfdGltZSAmJiBpbmNvbWluZy5hdXRoX3RpbWUgIT09IGV4aXN0aW5nLmF1dGhfdGltZSkge1xuICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcImF1dGhfdGltZSBpbiBpZF90b2tlbiBkb2VzIG5vdCBtYXRjaCBvcmlnaW5hbCBhdXRoX3RpbWVcIikpO1xuICAgICAgfVxuICAgICAgaWYgKGluY29taW5nLmF6cCAmJiBpbmNvbWluZy5henAgIT09IGV4aXN0aW5nLmF6cCkge1xuICAgICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcImF6cCBpbiBpZF90b2tlbiBkb2VzIG5vdCBtYXRjaCBvcmlnaW5hbCBhenBcIikpO1xuICAgICAgfVxuICAgICAgaWYgKCFpbmNvbWluZy5henAgJiYgZXhpc3RpbmcuYXpwKSB7XG4gICAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiYXpwIG5vdCBpbiBpZF90b2tlbiwgYnV0IHByZXNlbnQgaW4gb3JpZ2luYWwgaWRfdG9rZW5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXNwb25zZS5wcm9maWxlID0gaW5jb21pbmc7XG4gIH1cbn07XG5cbi8vIHNyYy9TdGF0ZS50c1xudmFyIFN0YXRlID0gY2xhc3MgX1N0YXRlIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuaWQgPSBhcmdzLmlkIHx8IENyeXB0b1V0aWxzLmdlbmVyYXRlVVVJRHY0KCk7XG4gICAgdGhpcy5kYXRhID0gYXJncy5kYXRhO1xuICAgIGlmIChhcmdzLmNyZWF0ZWQgJiYgYXJncy5jcmVhdGVkID4gMCkge1xuICAgICAgdGhpcy5jcmVhdGVkID0gYXJncy5jcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZWQgPSBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0X3R5cGUgPSBhcmdzLnJlcXVlc3RfdHlwZTtcbiAgICB0aGlzLnVybF9zdGF0ZSA9IGFyZ3MudXJsX3N0YXRlO1xuICB9XG4gIHRvU3RvcmFnZVN0cmluZygpIHtcbiAgICBuZXcgTG9nZ2VyKFwiU3RhdGVcIikuY3JlYXRlKFwidG9TdG9yYWdlU3RyaW5nXCIpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgIGNyZWF0ZWQ6IHRoaXMuY3JlYXRlZCxcbiAgICAgIHJlcXVlc3RfdHlwZTogdGhpcy5yZXF1ZXN0X3R5cGUsXG4gICAgICB1cmxfc3RhdGU6IHRoaXMudXJsX3N0YXRlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21TdG9yYWdlU3RyaW5nKHN0b3JhZ2VTdHJpbmcpIHtcbiAgICBMb2dnZXIuY3JlYXRlU3RhdGljKFwiU3RhdGVcIiwgXCJmcm9tU3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBfU3RhdGUoSlNPTi5wYXJzZShzdG9yYWdlU3RyaW5nKSkpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjbGVhclN0YWxlU3RhdGUoc3RvcmFnZSwgYWdlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IExvZ2dlci5jcmVhdGVTdGF0aWMoXCJTdGF0ZVwiLCBcImNsZWFyU3RhbGVTdGF0ZVwiKTtcbiAgICBjb25zdCBjdXRvZmYgPSBUaW1lci5nZXRFcG9jaFRpbWUoKSAtIGFnZTtcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgc3RvcmFnZS5nZXRBbGxLZXlzKCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBrZXlzXCIsIGtleXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCBzdG9yYWdlLmdldChrZXkpO1xuICAgICAgbGV0IHJlbW92ZSA9IGZhbHNlO1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IF9TdGF0ZS5mcm9tU3RvcmFnZVN0cmluZyhpdGVtKTtcbiAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwiZ290IGl0ZW0gZnJvbSBrZXk6XCIsIGtleSwgc3RhdGUuY3JlYXRlZCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmNyZWF0ZWQgPD0gY3V0b2ZmKSB7XG4gICAgICAgICAgICByZW1vdmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyMi5lcnJvcihcIkVycm9yIHBhcnNpbmcgc3RhdGUgZm9yIGtleTpcIiwga2V5LCBlcnIpO1xuICAgICAgICAgIHJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJubyBpdGVtIGluIHN0b3JhZ2UgZm9yIGtleTpcIiwga2V5KTtcbiAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInJlbW92ZWQgaXRlbSBmb3Iga2V5OlwiLCBrZXkpO1xuICAgICAgICB2b2lkIHN0b3JhZ2UucmVtb3ZlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvU2lnbmluU3RhdGUudHNcbnZhciBTaWduaW5TdGF0ZSA9IGNsYXNzIF9TaWduaW5TdGF0ZSBleHRlbmRzIFN0YXRlIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMuY29kZV92ZXJpZmllciA9IGFyZ3MuY29kZV92ZXJpZmllcjtcbiAgICB0aGlzLmNvZGVfY2hhbGxlbmdlID0gYXJncy5jb2RlX2NoYWxsZW5nZTtcbiAgICB0aGlzLmF1dGhvcml0eSA9IGFyZ3MuYXV0aG9yaXR5O1xuICAgIHRoaXMuY2xpZW50X2lkID0gYXJncy5jbGllbnRfaWQ7XG4gICAgdGhpcy5yZWRpcmVjdF91cmkgPSBhcmdzLnJlZGlyZWN0X3VyaTtcbiAgICB0aGlzLnNjb3BlID0gYXJncy5zY29wZTtcbiAgICB0aGlzLmNsaWVudF9zZWNyZXQgPSBhcmdzLmNsaWVudF9zZWNyZXQ7XG4gICAgdGhpcy5leHRyYVRva2VuUGFyYW1zID0gYXJncy5leHRyYVRva2VuUGFyYW1zO1xuICAgIHRoaXMucmVzcG9uc2VfbW9kZSA9IGFyZ3MucmVzcG9uc2VfbW9kZTtcbiAgICB0aGlzLnNraXBVc2VySW5mbyA9IGFyZ3Muc2tpcFVzZXJJbmZvO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoYXJncykge1xuICAgIGNvbnN0IGNvZGVfdmVyaWZpZXIgPSBhcmdzLmNvZGVfdmVyaWZpZXIgPT09IHRydWUgPyBDcnlwdG9VdGlscy5nZW5lcmF0ZUNvZGVWZXJpZmllcigpIDogYXJncy5jb2RlX3ZlcmlmaWVyIHx8IHZvaWQgMDtcbiAgICBjb25zdCBjb2RlX2NoYWxsZW5nZSA9IGNvZGVfdmVyaWZpZXIgPyBhd2FpdCBDcnlwdG9VdGlscy5nZW5lcmF0ZUNvZGVDaGFsbGVuZ2UoY29kZV92ZXJpZmllcikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG5ldyBfU2lnbmluU3RhdGUoe1xuICAgICAgLi4uYXJncyxcbiAgICAgIGNvZGVfdmVyaWZpZXIsXG4gICAgICBjb2RlX2NoYWxsZW5nZVxuICAgIH0pO1xuICB9XG4gIHRvU3RvcmFnZVN0cmluZygpIHtcbiAgICBuZXcgTG9nZ2VyKFwiU2lnbmluU3RhdGVcIikuY3JlYXRlKFwidG9TdG9yYWdlU3RyaW5nXCIpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgIGNyZWF0ZWQ6IHRoaXMuY3JlYXRlZCxcbiAgICAgIHJlcXVlc3RfdHlwZTogdGhpcy5yZXF1ZXN0X3R5cGUsXG4gICAgICB1cmxfc3RhdGU6IHRoaXMudXJsX3N0YXRlLFxuICAgICAgY29kZV92ZXJpZmllcjogdGhpcy5jb2RlX3ZlcmlmaWVyLFxuICAgICAgYXV0aG9yaXR5OiB0aGlzLmF1dGhvcml0eSxcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgICByZWRpcmVjdF91cmk6IHRoaXMucmVkaXJlY3RfdXJpLFxuICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLmNsaWVudF9zZWNyZXQsXG4gICAgICBleHRyYVRva2VuUGFyYW1zOiB0aGlzLmV4dHJhVG9rZW5QYXJhbXMsXG4gICAgICByZXNwb25zZV9tb2RlOiB0aGlzLnJlc3BvbnNlX21vZGUsXG4gICAgICBza2lwVXNlckluZm86IHRoaXMuc2tpcFVzZXJJbmZvXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21TdG9yYWdlU3RyaW5nKHN0b3JhZ2VTdHJpbmcpIHtcbiAgICBMb2dnZXIuY3JlYXRlU3RhdGljKFwiU2lnbmluU3RhdGVcIiwgXCJmcm9tU3RvcmFnZVN0cmluZ1wiKTtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzdG9yYWdlU3RyaW5nKTtcbiAgICByZXR1cm4gX1NpZ25pblN0YXRlLmNyZWF0ZShkYXRhKTtcbiAgfVxufTtcblxuLy8gc3JjL1NpZ25pblJlcXVlc3QudHNcbnZhciBfU2lnbmluUmVxdWVzdCA9IGNsYXNzIF9TaWduaW5SZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMudXJsID0gYXJncy51cmw7XG4gICAgdGhpcy5zdGF0ZSA9IGFyZ3Muc3RhdGU7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSh7XG4gICAgLy8gbWFuZGF0b3J5XG4gICAgdXJsLFxuICAgIGF1dGhvcml0eSxcbiAgICBjbGllbnRfaWQsXG4gICAgcmVkaXJlY3RfdXJpLFxuICAgIHJlc3BvbnNlX3R5cGUsXG4gICAgc2NvcGUsXG4gICAgLy8gb3B0aW9uYWxcbiAgICBzdGF0ZV9kYXRhLFxuICAgIHJlc3BvbnNlX21vZGUsXG4gICAgcmVxdWVzdF90eXBlLFxuICAgIGNsaWVudF9zZWNyZXQsXG4gICAgbm9uY2UsXG4gICAgdXJsX3N0YXRlLFxuICAgIHJlc291cmNlLFxuICAgIHNraXBVc2VySW5mbyxcbiAgICBleHRyYVF1ZXJ5UGFyYW1zLFxuICAgIGV4dHJhVG9rZW5QYXJhbXMsXG4gICAgZGlzYWJsZVBLQ0UsXG4gICAgZHBvcEprdCxcbiAgICBvbWl0U2NvcGVXaGVuUmVxdWVzdGluZyxcbiAgICAuLi5vcHRpb25hbFBhcmFtc1xuICB9KSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImNyZWF0ZTogTm8gdXJsIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVybFwiKTtcbiAgICB9XG4gICAgaWYgKCFjbGllbnRfaWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImNyZWF0ZTogTm8gY2xpZW50X2lkIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNsaWVudF9pZFwiKTtcbiAgICB9XG4gICAgaWYgKCFyZWRpcmVjdF91cmkpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImNyZWF0ZTogTm8gcmVkaXJlY3RfdXJpIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZGlyZWN0X3VyaVwiKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZV90eXBlKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoXCJjcmVhdGU6IE5vIHJlc3BvbnNlX3R5cGUgcGFzc2VkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzcG9uc2VfdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiY3JlYXRlOiBObyBzY29wZSBwYXNzZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY29wZVwiKTtcbiAgICB9XG4gICAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihcImNyZWF0ZTogTm8gYXV0aG9yaXR5IHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dGhvcml0eVwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBTaWduaW5TdGF0ZS5jcmVhdGUoe1xuICAgICAgZGF0YTogc3RhdGVfZGF0YSxcbiAgICAgIHJlcXVlc3RfdHlwZSxcbiAgICAgIHVybF9zdGF0ZSxcbiAgICAgIGNvZGVfdmVyaWZpZXI6ICFkaXNhYmxlUEtDRSxcbiAgICAgIGNsaWVudF9pZCxcbiAgICAgIGF1dGhvcml0eSxcbiAgICAgIHJlZGlyZWN0X3VyaSxcbiAgICAgIHJlc3BvbnNlX21vZGUsXG4gICAgICBjbGllbnRfc2VjcmV0LFxuICAgICAgc2NvcGUsXG4gICAgICBleHRyYVRva2VuUGFyYW1zLFxuICAgICAgc2tpcFVzZXJJbmZvXG4gICAgfSk7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY2xpZW50X2lkXCIsIGNsaWVudF9pZCk7XG4gICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZWRpcmVjdF91cmlcIiwgcmVkaXJlY3RfdXJpKTtcbiAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInJlc3BvbnNlX3R5cGVcIiwgcmVzcG9uc2VfdHlwZSk7XG4gICAgaWYgKCFvbWl0U2NvcGVXaGVuUmVxdWVzdGluZykge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzY29wZVwiLCBzY29wZSk7XG4gICAgfVxuICAgIGlmIChub25jZSkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub25jZVwiLCBub25jZSk7XG4gICAgfVxuICAgIGlmIChkcG9wSmt0KSB7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImRwb3Bfamt0XCIsIGRwb3BKa3QpO1xuICAgIH1cbiAgICBsZXQgc3RhdGVQYXJhbSA9IHN0YXRlLmlkO1xuICAgIGlmICh1cmxfc3RhdGUpIHtcbiAgICAgIHN0YXRlUGFyYW0gPSBgJHtzdGF0ZVBhcmFtfSR7VVJMX1NUQVRFX0RFTElNSVRFUn0ke3VybF9zdGF0ZX1gO1xuICAgIH1cbiAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInN0YXRlXCIsIHN0YXRlUGFyYW0pO1xuICAgIGlmIChzdGF0ZS5jb2RlX2NoYWxsZW5nZSkge1xuICAgICAgcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJjb2RlX2NoYWxsZW5nZVwiLCBzdGF0ZS5jb2RlX2NoYWxsZW5nZSk7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNvZGVfY2hhbGxlbmdlX21ldGhvZFwiLCBcIlMyNTZcIik7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgY29uc3QgcmVzb3VyY2VzID0gQXJyYXkuaXNBcnJheShyZXNvdXJjZSkgPyByZXNvdXJjZSA6IFtyZXNvdXJjZV07XG4gICAgICByZXNvdXJjZXMuZm9yRWFjaCgocikgPT4gcGFyc2VkVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZXNvdXJjZVwiLCByKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHsgcmVzcG9uc2VfbW9kZSwgLi4ub3B0aW9uYWxQYXJhbXMsIC4uLmV4dHJhUXVlcnlQYXJhbXMgfSkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1NpZ25pblJlcXVlc3Qoe1xuICAgICAgdXJsOiBwYXJzZWRVcmwuaHJlZixcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gIH1cbn07XG5fU2lnbmluUmVxdWVzdC5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlNpZ25pblJlcXVlc3RcIik7XG52YXIgU2lnbmluUmVxdWVzdCA9IF9TaWduaW5SZXF1ZXN0O1xuXG4vLyBzcmMvU2lnbmluUmVzcG9uc2UudHNcbnZhciBPaWRjU2NvcGUgPSBcIm9wZW5pZFwiO1xudmFyIFNpZ25pblJlc3BvbnNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAvKiogQHNlZSB7QGxpbmsgVXNlci5hY2Nlc3NfdG9rZW59ICovXG4gICAgdGhpcy5hY2Nlc3NfdG9rZW4gPSBcIlwiO1xuICAgIC8qKiBAc2VlIHtAbGluayBVc2VyLnRva2VuX3R5cGV9ICovXG4gICAgdGhpcy50b2tlbl90eXBlID0gXCJcIjtcbiAgICAvKiogQHNlZSB7QGxpbmsgVXNlci5wcm9maWxlfSAqL1xuICAgIHRoaXMucHJvZmlsZSA9IHt9O1xuICAgIHRoaXMuc3RhdGUgPSBwYXJhbXMuZ2V0KFwic3RhdGVcIik7XG4gICAgdGhpcy5zZXNzaW9uX3N0YXRlID0gcGFyYW1zLmdldChcInNlc3Npb25fc3RhdGVcIik7XG4gICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNvbnN0IHNwbGl0U3RhdGUgPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5zdGF0ZSkuc3BsaXQoVVJMX1NUQVRFX0RFTElNSVRFUik7XG4gICAgICB0aGlzLnN0YXRlID0gc3BsaXRTdGF0ZVswXTtcbiAgICAgIGlmIChzcGxpdFN0YXRlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy51cmxfc3RhdGUgPSBzcGxpdFN0YXRlLnNsaWNlKDEpLmpvaW4oVVJMX1NUQVRFX0RFTElNSVRFUik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXJyb3IgPSBwYXJhbXMuZ2V0KFwiZXJyb3JcIik7XG4gICAgdGhpcy5lcnJvcl9kZXNjcmlwdGlvbiA9IHBhcmFtcy5nZXQoXCJlcnJvcl9kZXNjcmlwdGlvblwiKTtcbiAgICB0aGlzLmVycm9yX3VyaSA9IHBhcmFtcy5nZXQoXCJlcnJvcl91cmlcIik7XG4gICAgdGhpcy5jb2RlID0gcGFyYW1zLmdldChcImNvZGVcIik7XG4gIH1cbiAgZ2V0IGV4cGlyZXNfaW4oKSB7XG4gICAgaWYgKHRoaXMuZXhwaXJlc19hdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHBpcmVzX2F0IC0gVGltZXIuZ2V0RXBvY2hUaW1lKCk7XG4gIH1cbiAgc2V0IGV4cGlyZXNfaW4odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUgPj0gMCkge1xuICAgICAgdGhpcy5leHBpcmVzX2F0ID0gTWF0aC5mbG9vcih2YWx1ZSkgKyBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzT3BlbklkKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuc2NvcGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcGxpdChcIiBcIikuaW5jbHVkZXMoT2lkY1Njb3BlKSkgfHwgISF0aGlzLmlkX3Rva2VuO1xuICB9XG59O1xuXG4vLyBzcmMvU2lnbm91dFJlcXVlc3QudHNcbnZhciBTaWdub3V0UmVxdWVzdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBzdGF0ZV9kYXRhLFxuICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgIGV4dHJhUXVlcnlQYXJhbXMsXG4gICAgcmVxdWVzdF90eXBlLFxuICAgIGNsaWVudF9pZCxcbiAgICB1cmxfc3RhdGVcbiAgfSkge1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJTaWdub3V0UmVxdWVzdFwiKTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKFwiY3RvcjogTm8gdXJsIHBhc3NlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVybFwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChpZF90b2tlbl9oaW50KSB7XG4gICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImlkX3Rva2VuX2hpbnRcIiwgaWRfdG9rZW5faGludCk7XG4gICAgfVxuICAgIGlmIChjbGllbnRfaWQpIHtcbiAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY2xpZW50X2lkXCIsIGNsaWVudF9pZCk7XG4gICAgfVxuICAgIGlmIChwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkpIHtcbiAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwicG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpXCIsIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSk7XG4gICAgICBpZiAoc3RhdGVfZGF0YSB8fCB1cmxfc3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZSh7IGRhdGE6IHN0YXRlX2RhdGEsIHJlcXVlc3RfdHlwZSwgdXJsX3N0YXRlIH0pO1xuICAgICAgICBsZXQgc3RhdGVQYXJhbSA9IHRoaXMuc3RhdGUuaWQ7XG4gICAgICAgIGlmICh1cmxfc3RhdGUpIHtcbiAgICAgICAgICBzdGF0ZVBhcmFtID0gYCR7c3RhdGVQYXJhbX0ke1VSTF9TVEFURV9ERUxJTUlURVJ9JHt1cmxfc3RhdGV9YDtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInN0YXRlXCIsIHN0YXRlUGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh7IC4uLmV4dHJhUXVlcnlQYXJhbXMgfSkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcnNlZFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXJsID0gcGFyc2VkVXJsLmhyZWY7XG4gIH1cbn07XG5cbi8vIHNyYy9TaWdub3V0UmVzcG9uc2UudHNcbnZhciBTaWdub3V0UmVzcG9uc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHRoaXMuc3RhdGUgPSBwYXJhbXMuZ2V0KFwic3RhdGVcIik7XG4gICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNvbnN0IHNwbGl0U3RhdGUgPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5zdGF0ZSkuc3BsaXQoVVJMX1NUQVRFX0RFTElNSVRFUik7XG4gICAgICB0aGlzLnN0YXRlID0gc3BsaXRTdGF0ZVswXTtcbiAgICAgIGlmIChzcGxpdFN0YXRlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy51cmxfc3RhdGUgPSBzcGxpdFN0YXRlLnNsaWNlKDEpLmpvaW4oVVJMX1NUQVRFX0RFTElNSVRFUik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXJyb3IgPSBwYXJhbXMuZ2V0KFwiZXJyb3JcIik7XG4gICAgdGhpcy5lcnJvcl9kZXNjcmlwdGlvbiA9IHBhcmFtcy5nZXQoXCJlcnJvcl9kZXNjcmlwdGlvblwiKTtcbiAgICB0aGlzLmVycm9yX3VyaSA9IHBhcmFtcy5nZXQoXCJlcnJvcl91cmlcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9DbGFpbXNTZXJ2aWNlLnRzXG52YXIgRGVmYXVsdFByb3RvY29sQ2xhaW1zID0gW1xuICBcIm5iZlwiLFxuICBcImp0aVwiLFxuICBcImF1dGhfdGltZVwiLFxuICBcIm5vbmNlXCIsXG4gIFwiYWNyXCIsXG4gIFwiYW1yXCIsXG4gIFwiYXpwXCIsXG4gIFwiYXRfaGFzaFwiXG4gIC8vIGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1jb3JlLTFfMC5odG1sI0NvZGVJRFRva2VuXG5dO1xudmFyIEludGVybmFsUmVxdWlyZWRQcm90b2NvbENsYWltcyA9IFtcInN1YlwiLCBcImlzc1wiLCBcImF1ZFwiLCBcImV4cFwiLCBcImlhdFwiXTtcbnZhciBDbGFpbXNTZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiQ2xhaW1zU2VydmljZVwiKTtcbiAgfVxuICBmaWx0ZXJQcm90b2NvbENsYWltcyhjbGFpbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmNsYWltcyB9O1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5maWx0ZXJQcm90b2NvbENsYWltcykge1xuICAgICAgbGV0IHByb3RvY29sQ2xhaW1zO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fc2V0dGluZ3MuZmlsdGVyUHJvdG9jb2xDbGFpbXMpKSB7XG4gICAgICAgIHByb3RvY29sQ2xhaW1zID0gdGhpcy5fc2V0dGluZ3MuZmlsdGVyUHJvdG9jb2xDbGFpbXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90b2NvbENsYWltcyA9IERlZmF1bHRQcm90b2NvbENsYWltcztcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2xhaW0gb2YgcHJvdG9jb2xDbGFpbXMpIHtcbiAgICAgICAgaWYgKCFJbnRlcm5hbFJlcXVpcmVkUHJvdG9jb2xDbGFpbXMuaW5jbHVkZXMoY2xhaW0pKSB7XG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtjbGFpbV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBtZXJnZUNsYWltcyhjbGFpbXMxLCBjbGFpbXMyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi5jbGFpbXMxIH07XG4gICAgZm9yIChjb25zdCBbY2xhaW0sIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMoY2xhaW1zMikpIHtcbiAgICAgIGlmIChyZXN1bHRbY2xhaW1dICE9PSB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2NsYWltXSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1lcmdlQ2xhaW1zU3RyYXRlZ3kuYXJyYXkgPT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtjbGFpbV0gPSB2YWx1ZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFZhbHVlcyA9IEFycmF5LmlzQXJyYXkocmVzdWx0W2NsYWltXSkgPyByZXN1bHRbY2xhaW1dIDogW3Jlc3VsdFtjbGFpbV1dO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbdmFsdWVzXSkge1xuICAgICAgICAgICAgICBpZiAoIW1lcmdlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjbGFpbV0gPSBtZXJnZWRWYWx1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHRbY2xhaW1dID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZXN1bHRbY2xhaW1dID0gdGhpcy5tZXJnZUNsYWltcyhyZXN1bHRbY2xhaW1dLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtjbGFpbV0gPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL0RQb1BTdG9yZS50c1xudmFyIERQb1BTdGF0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioa2V5cywgbm9uY2UpIHtcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHRoaXMubm9uY2UgPSBub25jZTtcbiAgfVxufTtcblxuLy8gc3JjL09pZGNDbGllbnQudHNcbnZhciBPaWRjQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgbWV0YWRhdGFTZXJ2aWNlKSB7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIk9pZGNDbGllbnRcIik7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzIGluc3RhbmNlb2YgT2lkY0NsaWVudFNldHRpbmdzU3RvcmUgPyBzZXR0aW5ncyA6IG5ldyBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZShzZXR0aW5ncyk7XG4gICAgdGhpcy5tZXRhZGF0YVNlcnZpY2UgPSBtZXRhZGF0YVNlcnZpY2UgIT0gbnVsbCA/IG1ldGFkYXRhU2VydmljZSA6IG5ldyBNZXRhZGF0YVNlcnZpY2UodGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5fY2xhaW1zU2VydmljZSA9IG5ldyBDbGFpbXNTZXJ2aWNlKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX3ZhbGlkYXRvciA9IG5ldyBSZXNwb25zZVZhbGlkYXRvcih0aGlzLnNldHRpbmdzLCB0aGlzLm1ldGFkYXRhU2VydmljZSwgdGhpcy5fY2xhaW1zU2VydmljZSk7XG4gICAgdGhpcy5fdG9rZW5DbGllbnQgPSBuZXcgVG9rZW5DbGllbnQodGhpcy5zZXR0aW5ncywgdGhpcy5tZXRhZGF0YVNlcnZpY2UpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVNpZ25pblJlcXVlc3Qoe1xuICAgIHN0YXRlLFxuICAgIHJlcXVlc3QsXG4gICAgcmVxdWVzdF91cmksXG4gICAgcmVxdWVzdF90eXBlLFxuICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgbG9naW5faGludCxcbiAgICBza2lwVXNlckluZm8sXG4gICAgbm9uY2UsXG4gICAgdXJsX3N0YXRlLFxuICAgIHJlc3BvbnNlX3R5cGUgPSB0aGlzLnNldHRpbmdzLnJlc3BvbnNlX3R5cGUsXG4gICAgc2NvcGUgPSB0aGlzLnNldHRpbmdzLnNjb3BlLFxuICAgIHJlZGlyZWN0X3VyaSA9IHRoaXMuc2V0dGluZ3MucmVkaXJlY3RfdXJpLFxuICAgIHByb21wdCA9IHRoaXMuc2V0dGluZ3MucHJvbXB0LFxuICAgIGRpc3BsYXkgPSB0aGlzLnNldHRpbmdzLmRpc3BsYXksXG4gICAgbWF4X2FnZSA9IHRoaXMuc2V0dGluZ3MubWF4X2FnZSxcbiAgICB1aV9sb2NhbGVzID0gdGhpcy5zZXR0aW5ncy51aV9sb2NhbGVzLFxuICAgIGFjcl92YWx1ZXMgPSB0aGlzLnNldHRpbmdzLmFjcl92YWx1ZXMsXG4gICAgcmVzb3VyY2UgPSB0aGlzLnNldHRpbmdzLnJlc291cmNlLFxuICAgIHJlc3BvbnNlX21vZGUgPSB0aGlzLnNldHRpbmdzLnJlc3BvbnNlX21vZGUsXG4gICAgZXh0cmFRdWVyeVBhcmFtcyA9IHRoaXMuc2V0dGluZ3MuZXh0cmFRdWVyeVBhcmFtcyxcbiAgICBleHRyYVRva2VuUGFyYW1zID0gdGhpcy5zZXR0aW5ncy5leHRyYVRva2VuUGFyYW1zLFxuICAgIGRwb3BKa3QsXG4gICAgb21pdFNjb3BlV2hlblJlcXVlc3RpbmcgPSB0aGlzLnNldHRpbmdzLm9taXRTY29wZVdoZW5SZXF1ZXN0aW5nXG4gIH0pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNyZWF0ZVNpZ25pblJlcXVlc3RcIik7XG4gICAgaWYgKHJlc3BvbnNlX3R5cGUgIT09IFwiY29kZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHRoZSBBdXRob3JpemF0aW9uIENvZGUgZmxvdyAod2l0aCBQS0NFKSBpcyBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMubWV0YWRhdGFTZXJ2aWNlLmdldEF1dGhvcml6YXRpb25FbmRwb2ludCgpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJSZWNlaXZlZCBhdXRob3JpemF0aW9uIGVuZHBvaW50XCIsIHVybCk7XG4gICAgY29uc3Qgc2lnbmluUmVxdWVzdCA9IGF3YWl0IFNpZ25pblJlcXVlc3QuY3JlYXRlKHtcbiAgICAgIHVybCxcbiAgICAgIGF1dGhvcml0eTogdGhpcy5zZXR0aW5ncy5hdXRob3JpdHksXG4gICAgICBjbGllbnRfaWQ6IHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkLFxuICAgICAgcmVkaXJlY3RfdXJpLFxuICAgICAgcmVzcG9uc2VfdHlwZSxcbiAgICAgIHNjb3BlLFxuICAgICAgc3RhdGVfZGF0YTogc3RhdGUsXG4gICAgICB1cmxfc3RhdGUsXG4gICAgICBwcm9tcHQsXG4gICAgICBkaXNwbGF5LFxuICAgICAgbWF4X2FnZSxcbiAgICAgIHVpX2xvY2FsZXMsXG4gICAgICBpZF90b2tlbl9oaW50LFxuICAgICAgbG9naW5faGludCxcbiAgICAgIGFjcl92YWx1ZXMsXG4gICAgICBkcG9wSmt0LFxuICAgICAgcmVzb3VyY2UsXG4gICAgICByZXF1ZXN0LFxuICAgICAgcmVxdWVzdF91cmksXG4gICAgICBleHRyYVF1ZXJ5UGFyYW1zLFxuICAgICAgZXh0cmFUb2tlblBhcmFtcyxcbiAgICAgIHJlcXVlc3RfdHlwZSxcbiAgICAgIHJlc3BvbnNlX21vZGUsXG4gICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLnNldHRpbmdzLmNsaWVudF9zZWNyZXQsXG4gICAgICBza2lwVXNlckluZm8sXG4gICAgICBub25jZSxcbiAgICAgIGRpc2FibGVQS0NFOiB0aGlzLnNldHRpbmdzLmRpc2FibGVQS0NFLFxuICAgICAgb21pdFNjb3BlV2hlblJlcXVlc3RpbmdcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmNsZWFyU3RhbGVTdGF0ZSgpO1xuICAgIGNvbnN0IHNpZ25pblN0YXRlID0gc2lnbmluUmVxdWVzdC5zdGF0ZTtcbiAgICBhd2FpdCB0aGlzLnNldHRpbmdzLnN0YXRlU3RvcmUuc2V0KHNpZ25pblN0YXRlLmlkLCBzaWduaW5TdGF0ZS50b1N0b3JhZ2VTdHJpbmcoKSk7XG4gICAgcmV0dXJuIHNpZ25pblJlcXVlc3Q7XG4gIH1cbiAgYXN5bmMgcmVhZFNpZ25pblJlc3BvbnNlU3RhdGUodXJsLCByZW1vdmVTdGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJyZWFkU2lnbmluUmVzcG9uc2VTdGF0ZVwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IG5ldyBTaWduaW5SZXNwb25zZShVcmxVdGlscy5yZWFkUGFyYW1zKHVybCwgdGhpcy5zZXR0aW5ncy5yZXNwb25zZV9tb2RlKSk7XG4gICAgaWYgKCFyZXNwb25zZS5zdGF0ZSkge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBzdGF0ZSBpbiByZXNwb25zZVwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdG9yZWRTdGF0ZVN0cmluZyA9IGF3YWl0IHRoaXMuc2V0dGluZ3Muc3RhdGVTdG9yZVtyZW1vdmVTdGF0ZSA/IFwicmVtb3ZlXCIgOiBcImdldFwiXShyZXNwb25zZS5zdGF0ZSk7XG4gICAgaWYgKCFzdG9yZWRTdGF0ZVN0cmluZykge1xuICAgICAgbG9nZ2VyMi50aHJvdyhuZXcgRXJyb3IoXCJObyBtYXRjaGluZyBzdGF0ZSBmb3VuZCBpbiBzdG9yYWdlXCIpKTtcbiAgICAgIHRocm93IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgU2lnbmluU3RhdGUuZnJvbVN0b3JhZ2VTdHJpbmcoc3RvcmVkU3RhdGVTdHJpbmcpO1xuICAgIHJldHVybiB7IHN0YXRlLCByZXNwb25zZSB9O1xuICB9XG4gIGFzeW5jIHByb2Nlc3NTaWduaW5SZXNwb25zZSh1cmwsIGV4dHJhSGVhZGVycywgcmVtb3ZlU3RhdGUgPSB0cnVlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJwcm9jZXNzU2lnbmluUmVzcG9uc2VcIik7XG4gICAgY29uc3QgeyBzdGF0ZSwgcmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMucmVhZFNpZ25pblJlc3BvbnNlU3RhdGUodXJsLCByZW1vdmVTdGF0ZSk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcInJlY2VpdmVkIHN0YXRlIGZyb20gc3RvcmFnZTsgdmFsaWRhdGluZyByZXNwb25zZVwiKTtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5kcG9wICYmIHRoaXMuc2V0dGluZ3MuZHBvcC5zdG9yZSkge1xuICAgICAgY29uc3QgZHBvcFByb29mID0gYXdhaXQgdGhpcy5nZXREcG9wUHJvb2YodGhpcy5zZXR0aW5ncy5kcG9wLnN0b3JlKTtcbiAgICAgIGV4dHJhSGVhZGVycyA9IHsgLi4uZXh0cmFIZWFkZXJzLCBcIkRQb1BcIjogZHBvcFByb29mIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl92YWxpZGF0b3IudmFsaWRhdGVTaWduaW5SZXNwb25zZShyZXNwb25zZSwgc3RhdGUsIGV4dHJhSGVhZGVycyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3JEUG9QTm9uY2UgJiYgdGhpcy5zZXR0aW5ncy5kcG9wKSB7XG4gICAgICAgIGNvbnN0IGRwb3BQcm9vZiA9IGF3YWl0IHRoaXMuZ2V0RHBvcFByb29mKHRoaXMuc2V0dGluZ3MuZHBvcC5zdG9yZSwgZXJyLm5vbmNlKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzW1wiRFBvUFwiXSA9IGRwb3BQcm9vZjtcbiAgICAgICAgYXdhaXQgdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlU2lnbmluUmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlLCBleHRyYUhlYWRlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgZ2V0RHBvcFByb29mKGRwb3BTdG9yZSwgbm9uY2UpIHtcbiAgICBsZXQga2V5UGFpcjtcbiAgICBsZXQgZHBvcFN0YXRlO1xuICAgIGlmICghKGF3YWl0IGRwb3BTdG9yZS5nZXRBbGxLZXlzKCkpLmluY2x1ZGVzKHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkKSkge1xuICAgICAga2V5UGFpciA9IGF3YWl0IENyeXB0b1V0aWxzLmdlbmVyYXRlRFBvUEtleXMoKTtcbiAgICAgIGRwb3BTdGF0ZSA9IG5ldyBEUG9QU3RhdGUoa2V5UGFpciwgbm9uY2UpO1xuICAgICAgYXdhaXQgZHBvcFN0b3JlLnNldCh0aGlzLnNldHRpbmdzLmNsaWVudF9pZCwgZHBvcFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHBvcFN0YXRlID0gYXdhaXQgZHBvcFN0b3JlLmdldCh0aGlzLnNldHRpbmdzLmNsaWVudF9pZCk7XG4gICAgICBpZiAoZHBvcFN0YXRlLm5vbmNlICE9PSBub25jZSAmJiBub25jZSkge1xuICAgICAgICBkcG9wU3RhdGUubm9uY2UgPSBub25jZTtcbiAgICAgICAgYXdhaXQgZHBvcFN0b3JlLnNldCh0aGlzLnNldHRpbmdzLmNsaWVudF9pZCwgZHBvcFN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IENyeXB0b1V0aWxzLmdlbmVyYXRlRFBvUFByb29mKHtcbiAgICAgIHVybDogYXdhaXQgdGhpcy5tZXRhZGF0YVNlcnZpY2UuZ2V0VG9rZW5FbmRwb2ludChmYWxzZSksXG4gICAgICBodHRwTWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGtleVBhaXI6IGRwb3BTdGF0ZS5rZXlzLFxuICAgICAgbm9uY2U6IGRwb3BTdGF0ZS5ub25jZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NSZXNvdXJjZU93bmVyUGFzc3dvcmRDcmVkZW50aWFscyh7XG4gICAgdXNlcm5hbWUsXG4gICAgcGFzc3dvcmQsXG4gICAgc2tpcFVzZXJJbmZvID0gZmFsc2UsXG4gICAgZXh0cmFUb2tlblBhcmFtcyA9IHt9XG4gIH0pIHtcbiAgICBjb25zdCB0b2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdG9rZW5DbGllbnQuZXhjaGFuZ2VDcmVkZW50aWFscyh7IHVzZXJuYW1lLCBwYXNzd29yZCwgLi4uZXh0cmFUb2tlblBhcmFtcyB9KTtcbiAgICBjb25zdCBzaWduaW5SZXNwb25zZSA9IG5ldyBTaWduaW5SZXNwb25zZShuZXcgVVJMU2VhcmNoUGFyYW1zKCkpO1xuICAgIE9iamVjdC5hc3NpZ24oc2lnbmluUmVzcG9uc2UsIHRva2VuUmVzcG9uc2UpO1xuICAgIGF3YWl0IHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZUNyZWRlbnRpYWxzUmVzcG9uc2Uoc2lnbmluUmVzcG9uc2UsIHNraXBVc2VySW5mbyk7XG4gICAgcmV0dXJuIHNpZ25pblJlc3BvbnNlO1xuICB9XG4gIGFzeW5jIHVzZVJlZnJlc2hUb2tlbih7XG4gICAgc3RhdGUsXG4gICAgcmVkaXJlY3RfdXJpLFxuICAgIHJlc291cmNlLFxuICAgIHRpbWVvdXRJblNlY29uZHMsXG4gICAgZXh0cmFIZWFkZXJzLFxuICAgIGV4dHJhVG9rZW5QYXJhbXNcbiAgfSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInVzZVJlZnJlc2hUb2tlblwiKTtcbiAgICBsZXQgc2NvcGU7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucmVmcmVzaFRva2VuQWxsb3dlZFNjb3BlID09PSB2b2lkIDApIHtcbiAgICAgIHNjb3BlID0gc3RhdGUuc2NvcGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFsbG93YWJsZVNjb3BlcyA9IHRoaXMuc2V0dGluZ3MucmVmcmVzaFRva2VuQWxsb3dlZFNjb3BlLnNwbGl0KFwiIFwiKTtcbiAgICAgIGNvbnN0IHByb3ZpZGVkU2NvcGVzID0gKChfYSA9IHN0YXRlLnNjb3BlKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3BsaXQoXCIgXCIpKSB8fCBbXTtcbiAgICAgIHNjb3BlID0gcHJvdmlkZWRTY29wZXMuZmlsdGVyKChzKSA9PiBhbGxvd2FibGVTY29wZXMuaW5jbHVkZXMocykpLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5kcG9wICYmIHRoaXMuc2V0dGluZ3MuZHBvcC5zdG9yZSkge1xuICAgICAgY29uc3QgZHBvcFByb29mID0gYXdhaXQgdGhpcy5nZXREcG9wUHJvb2YodGhpcy5zZXR0aW5ncy5kcG9wLnN0b3JlKTtcbiAgICAgIGV4dHJhSGVhZGVycyA9IHsgLi4uZXh0cmFIZWFkZXJzLCBcIkRQb1BcIjogZHBvcFByb29mIH07XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuX3Rva2VuQ2xpZW50LmV4Y2hhbmdlUmVmcmVzaFRva2VuKHtcbiAgICAgICAgcmVmcmVzaF90b2tlbjogc3RhdGUucmVmcmVzaF90b2tlbixcbiAgICAgICAgLy8gcHJvdmlkZSB0aGUgKHBvc3NpYmxlIGZpbHRlcmVkKSBzY29wZSBsaXN0XG4gICAgICAgIHNjb3BlLFxuICAgICAgICByZWRpcmVjdF91cmksXG4gICAgICAgIHJlc291cmNlLFxuICAgICAgICB0aW1lb3V0SW5TZWNvbmRzLFxuICAgICAgICBleHRyYUhlYWRlcnMsXG4gICAgICAgIC4uLmV4dHJhVG9rZW5QYXJhbXNcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yRFBvUE5vbmNlICYmIHRoaXMuc2V0dGluZ3MuZHBvcCkge1xuICAgICAgICBleHRyYUhlYWRlcnNbXCJEUG9QXCJdID0gYXdhaXQgdGhpcy5nZXREcG9wUHJvb2YodGhpcy5zZXR0aW5ncy5kcG9wLnN0b3JlLCBlcnIubm9uY2UpO1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLl90b2tlbkNsaWVudC5leGNoYW5nZVJlZnJlc2hUb2tlbih7XG4gICAgICAgICAgcmVmcmVzaF90b2tlbjogc3RhdGUucmVmcmVzaF90b2tlbixcbiAgICAgICAgICAvLyBwcm92aWRlIHRoZSAocG9zc2libGUgZmlsdGVyZWQpIHNjb3BlIGxpc3RcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICByZWRpcmVjdF91cmksXG4gICAgICAgICAgcmVzb3VyY2UsXG4gICAgICAgICAgdGltZW91dEluU2Vjb25kcyxcbiAgICAgICAgICBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgLi4uZXh0cmFUb2tlblBhcmFtc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgU2lnbmluUmVzcG9uc2UobmV3IFVSTFNlYXJjaFBhcmFtcygpKTtcbiAgICBPYmplY3QuYXNzaWduKHJlc3BvbnNlLCByZXN1bHQpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJ2YWxpZGF0aW5nIHJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcbiAgICBhd2FpdCB0aGlzLl92YWxpZGF0b3IudmFsaWRhdGVSZWZyZXNoUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLy8gb3ZlcnJpZGUgdGhlIHNjb3BlIGluIHRoZSBzdGF0ZSBoYW5kZWQgb3ZlciB0byB0aGUgdmFsaWRhdG9yXG4gICAgICAvLyBzbyBpdCBjYW4gc2V0IHRoZSBncmFudGVkIHNjb3BlIHRvIHRoZSByZXF1ZXN0ZWQgc2NvcGUgaW4gY2FzZSBub25lIGlzIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZVxuICAgICAgc2NvcGVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgYXN5bmMgY3JlYXRlU2lnbm91dFJlcXVlc3Qoe1xuICAgIHN0YXRlLFxuICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgY2xpZW50X2lkLFxuICAgIHJlcXVlc3RfdHlwZSxcbiAgICB1cmxfc3RhdGUsXG4gICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpID0gdGhpcy5zZXR0aW5ncy5wb3N0X2xvZ291dF9yZWRpcmVjdF91cmksXG4gICAgZXh0cmFRdWVyeVBhcmFtcyA9IHRoaXMuc2V0dGluZ3MuZXh0cmFRdWVyeVBhcmFtc1xuICB9ID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNyZWF0ZVNpZ25vdXRSZXF1ZXN0XCIpO1xuICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMubWV0YWRhdGFTZXJ2aWNlLmdldEVuZFNlc3Npb25FbmRwb2ludCgpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIGVuZCBzZXNzaW9uIGVuZHBvaW50XCIpKTtcbiAgICAgIHRocm93IG51bGw7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJSZWNlaXZlZCBlbmQgc2Vzc2lvbiBlbmRwb2ludFwiLCB1cmwpO1xuICAgIGlmICghY2xpZW50X2lkICYmIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSAmJiAhaWRfdG9rZW5faGludCkge1xuICAgICAgY2xpZW50X2lkID0gdGhpcy5zZXR0aW5ncy5jbGllbnRfaWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgU2lnbm91dFJlcXVlc3Qoe1xuICAgICAgdXJsLFxuICAgICAgaWRfdG9rZW5faGludCxcbiAgICAgIGNsaWVudF9pZCxcbiAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgIHN0YXRlX2RhdGE6IHN0YXRlLFxuICAgICAgZXh0cmFRdWVyeVBhcmFtcyxcbiAgICAgIHJlcXVlc3RfdHlwZSxcbiAgICAgIHVybF9zdGF0ZVxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuY2xlYXJTdGFsZVN0YXRlKCk7XG4gICAgY29uc3Qgc2lnbm91dFN0YXRlID0gcmVxdWVzdC5zdGF0ZTtcbiAgICBpZiAoc2lnbm91dFN0YXRlKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiU2lnbm91dCByZXF1ZXN0IGhhcyBzdGF0ZSB0byBwZXJzaXN0XCIpO1xuICAgICAgYXdhaXQgdGhpcy5zZXR0aW5ncy5zdGF0ZVN0b3JlLnNldChzaWdub3V0U3RhdGUuaWQsIHNpZ25vdXRTdGF0ZS50b1N0b3JhZ2VTdHJpbmcoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIGFzeW5jIHJlYWRTaWdub3V0UmVzcG9uc2VTdGF0ZSh1cmwsIHJlbW92ZVN0YXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInJlYWRTaWdub3V0UmVzcG9uc2VTdGF0ZVwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IG5ldyBTaWdub3V0UmVzcG9uc2UoVXJsVXRpbHMucmVhZFBhcmFtcyh1cmwsIHRoaXMuc2V0dGluZ3MucmVzcG9uc2VfbW9kZSkpO1xuICAgIGlmICghcmVzcG9uc2Uuc3RhdGUpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJObyBzdGF0ZSBpbiByZXNwb25zZVwiKTtcbiAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICBsb2dnZXIyLndhcm4oXCJSZXNwb25zZSB3YXMgZXJyb3I6XCIsIHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3RhdGU6IHZvaWQgMCwgcmVzcG9uc2UgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkU3RhdGVTdHJpbmcgPSBhd2FpdCB0aGlzLnNldHRpbmdzLnN0YXRlU3RvcmVbcmVtb3ZlU3RhdGUgPyBcInJlbW92ZVwiIDogXCJnZXRcIl0ocmVzcG9uc2Uuc3RhdGUpO1xuICAgIGlmICghc3RvcmVkU3RhdGVTdHJpbmcpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gbWF0Y2hpbmcgc3RhdGUgZm91bmQgaW4gc3RvcmFnZVwiKSk7XG4gICAgICB0aHJvdyBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IGF3YWl0IFN0YXRlLmZyb21TdG9yYWdlU3RyaW5nKHN0b3JlZFN0YXRlU3RyaW5nKTtcbiAgICByZXR1cm4geyBzdGF0ZSwgcmVzcG9uc2UgfTtcbiAgfVxuICBhc3luYyBwcm9jZXNzU2lnbm91dFJlc3BvbnNlKHVybCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwicHJvY2Vzc1NpZ25vdXRSZXNwb25zZVwiKTtcbiAgICBjb25zdCB7IHN0YXRlLCByZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5yZWFkU2lnbm91dFJlc3BvbnNlU3RhdGUodXJsLCB0cnVlKTtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJSZWNlaXZlZCBzdGF0ZSBmcm9tIHN0b3JhZ2U7IHZhbGlkYXRpbmcgcmVzcG9uc2VcIik7XG4gICAgICB0aGlzLl92YWxpZGF0b3IudmFsaWRhdGVTaWdub3V0UmVzcG9uc2UocmVzcG9uc2UsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcIk5vIHN0YXRlIGZyb20gc3RvcmFnZTsgc2tpcHBpbmcgcmVzcG9uc2UgdmFsaWRhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIGNsZWFyU3RhbGVTdGF0ZSgpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiY2xlYXJTdGFsZVN0YXRlXCIpO1xuICAgIHJldHVybiBTdGF0ZS5jbGVhclN0YWxlU3RhdGUodGhpcy5zZXR0aW5ncy5zdGF0ZVN0b3JlLCB0aGlzLnNldHRpbmdzLnN0YWxlU3RhdGVBZ2VJblNlY29uZHMpO1xuICB9XG4gIGFzeW5jIHJldm9rZVRva2VuKHRva2VuLCB0eXBlKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInJldm9rZVRva2VuXCIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl90b2tlbkNsaWVudC5yZXZva2Uoe1xuICAgICAgdG9rZW4sXG4gICAgICB0b2tlbl90eXBlX2hpbnQ6IHR5cGVcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL1Nlc3Npb25Nb25pdG9yLnRzXG52YXIgU2Vzc2lvbk1vbml0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF91c2VyTWFuYWdlcikge1xuICAgIHRoaXMuX3VzZXJNYW5hZ2VyID0gX3VzZXJNYW5hZ2VyO1xuICAgIHRoaXMuX2xvZ2dlciA9IG5ldyBMb2dnZXIoXCJTZXNzaW9uTW9uaXRvclwiKTtcbiAgICB0aGlzLl9zdGFydCA9IGFzeW5jICh1c2VyKSA9PiB7XG4gICAgICBjb25zdCBzZXNzaW9uX3N0YXRlID0gdXNlci5zZXNzaW9uX3N0YXRlO1xuICAgICAgaWYgKCFzZXNzaW9uX3N0YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX3N0YXJ0XCIpO1xuICAgICAgaWYgKHVzZXIucHJvZmlsZSkge1xuICAgICAgICB0aGlzLl9zdWIgPSB1c2VyLnByb2ZpbGUuc3ViO1xuICAgICAgICBsb2dnZXIyLmRlYnVnKFwic2Vzc2lvbl9zdGF0ZVwiLCBzZXNzaW9uX3N0YXRlLCBcIiwgc3ViXCIsIHRoaXMuX3N1Yik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdWIgPSB2b2lkIDA7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzZXNzaW9uX3N0YXRlXCIsIHNlc3Npb25fc3RhdGUsIFwiLCBhbm9ueW1vdXMgdXNlclwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lLnN0YXJ0KHNlc3Npb25fc3RhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl91c2VyTWFuYWdlci5tZXRhZGF0YVNlcnZpY2UuZ2V0Q2hlY2tTZXNzaW9uSWZyYW1lKCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwiaW5pdGlhbGl6aW5nIGNoZWNrIHNlc3Npb24gaWZyYW1lXCIpO1xuICAgICAgICAgIGNvbnN0IGNsaWVudF9pZCA9IHRoaXMuX3VzZXJNYW5hZ2VyLnNldHRpbmdzLmNsaWVudF9pZDtcbiAgICAgICAgICBjb25zdCBpbnRlcnZhbEluU2Vjb25kcyA9IHRoaXMuX3VzZXJNYW5hZ2VyLnNldHRpbmdzLmNoZWNrU2Vzc2lvbkludGVydmFsSW5TZWNvbmRzO1xuICAgICAgICAgIGNvbnN0IHN0b3BPbkVycm9yID0gdGhpcy5fdXNlck1hbmFnZXIuc2V0dGluZ3Muc3RvcENoZWNrU2Vzc2lvbk9uRXJyb3I7XG4gICAgICAgICAgY29uc3QgY2hlY2tTZXNzaW9uSUZyYW1lID0gbmV3IENoZWNrU2Vzc2lvbklGcmFtZSh0aGlzLl9jYWxsYmFjaywgY2xpZW50X2lkLCB1cmwsIGludGVydmFsSW5TZWNvbmRzLCBzdG9wT25FcnJvcik7XG4gICAgICAgICAgYXdhaXQgY2hlY2tTZXNzaW9uSUZyYW1lLmxvYWQoKTtcbiAgICAgICAgICB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUgPSBjaGVja1Nlc3Npb25JRnJhbWU7XG4gICAgICAgICAgY2hlY2tTZXNzaW9uSUZyYW1lLnN0YXJ0KHNlc3Npb25fc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlcjIud2FybihcIm5vIGNoZWNrIHNlc3Npb24gaWZyYW1lIGZvdW5kIGluIHRoZSBtZXRhZGF0YVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBmcm9tIGdldENoZWNrU2Vzc2lvbklmcmFtZTpcIiwgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9zdG9wID0gKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc3RvcFwiKTtcbiAgICAgIHRoaXMuX3N1YiA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tTZXNzaW9uSUZyYW1lLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl91c2VyTWFuYWdlci5zZXR0aW5ncy5tb25pdG9yQW5vbnltb3VzU2Vzc2lvbikge1xuICAgICAgICBjb25zdCB0aW1lckhhbmRsZSA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVySGFuZGxlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLnF1ZXJ5U2Vzc2lvblN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgdG1wVXNlciA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3N0YXRlOiBzZXNzaW9uLnNlc3Npb25fc3RhdGUsXG4gICAgICAgICAgICAgICAgcHJvZmlsZTogc2Vzc2lvbi5zdWIgPyB7XG4gICAgICAgICAgICAgICAgICBzdWI6IHNlc3Npb24uc3ViXG4gICAgICAgICAgICAgICAgfSA6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdm9pZCB0aGlzLl9zdGFydCh0bXBVc2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJlcnJvciBmcm9tIHF1ZXJ5U2Vzc2lvblN0YXR1c1wiLCBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDFlMyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2NhbGxiYWNrXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLnF1ZXJ5U2Vzc2lvblN0YXR1cygpO1xuICAgICAgICBsZXQgcmFpc2VFdmVudCA9IHRydWU7XG4gICAgICAgIGlmIChzZXNzaW9uICYmIHRoaXMuX2NoZWNrU2Vzc2lvbklGcmFtZSkge1xuICAgICAgICAgIGlmIChzZXNzaW9uLnN1YiA9PT0gdGhpcy5fc3ViKSB7XG4gICAgICAgICAgICByYWlzZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Nlc3Npb25JRnJhbWUuc3RhcnQoc2Vzc2lvbi5zZXNzaW9uX3N0YXRlKTtcbiAgICAgICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzYW1lIHN1YiBzdGlsbCBsb2dnZWQgaW4gYXQgT1AsIHNlc3Npb24gc3RhdGUgaGFzIGNoYW5nZWQsIHJlc3RhcnRpbmcgY2hlY2sgc2Vzc2lvbiBpZnJhbWU7IHNlc3Npb25fc3RhdGVcIiwgc2Vzc2lvbi5zZXNzaW9uX3N0YXRlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2Vzc2lvbkNoYW5nZWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImRpZmZlcmVudCBzdWJqZWN0IHNpZ25lZCBpbnRvIE9QXCIsIHNlc3Npb24uc3ViKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInN1YmplY3Qgbm8gbG9uZ2VyIHNpZ25lZCBpbnRvIE9QXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYWlzZUV2ZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3N1Yikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLl9yYWlzZVVzZXJTaWduZWRPdXQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLl9yYWlzZVVzZXJTaWduZWRJbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIyLmRlYnVnKFwibm8gY2hhbmdlIGluIHNlc3Npb24gZGV0ZWN0ZWQsIG5vIGV2ZW50IHRvIHJhaXNlXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1Yikge1xuICAgICAgICAgIGxvZ2dlcjIuZGVidWcoXCJFcnJvciBjYWxsaW5nIHF1ZXJ5Q3VycmVudFNpZ25pblNlc3Npb247IHJhaXNpbmcgc2lnbmVkIG91dCBldmVudFwiLCBlcnIpO1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5fcmFpc2VVc2VyU2lnbmVkT3V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghX3VzZXJNYW5hZ2VyKSB7XG4gICAgICB0aGlzLl9sb2dnZXIudGhyb3cobmV3IEVycm9yKFwiTm8gdXNlciBtYW5hZ2VyIHBhc3NlZFwiKSk7XG4gICAgfVxuICAgIHRoaXMuX3VzZXJNYW5hZ2VyLmV2ZW50cy5hZGRVc2VyTG9hZGVkKHRoaXMuX3N0YXJ0KTtcbiAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuYWRkVXNlclVubG9hZGVkKHRoaXMuX3N0b3ApO1xuICAgIHRoaXMuX2luaXQoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoZXJyKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBfaW5pdCgpIHtcbiAgICB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2luaXRcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmdldFVzZXIoKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgdm9pZCB0aGlzLl9zdGFydCh1c2VyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3VzZXJNYW5hZ2VyLnNldHRpbmdzLm1vbml0b3JBbm9ueW1vdXNTZXNzaW9uKSB7XG4gICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIucXVlcnlTZXNzaW9uU3RhdHVzKCk7XG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBjb25zdCB0bXBVc2VyID0ge1xuICAgICAgICAgIHNlc3Npb25fc3RhdGU6IHNlc3Npb24uc2Vzc2lvbl9zdGF0ZSxcbiAgICAgICAgICBwcm9maWxlOiBzZXNzaW9uLnN1YiA/IHtcbiAgICAgICAgICAgIHN1Yjogc2Vzc2lvbi5zdWJcbiAgICAgICAgICB9IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB2b2lkIHRoaXMuX3N0YXJ0KHRtcFVzZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL1VzZXIudHNcbnZhciBVc2VyID0gY2xhc3MgX1VzZXIge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuaWRfdG9rZW4gPSBhcmdzLmlkX3Rva2VuO1xuICAgIHRoaXMuc2Vzc2lvbl9zdGF0ZSA9IChfYSA9IGFyZ3Muc2Vzc2lvbl9zdGF0ZSkgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgICB0aGlzLmFjY2Vzc190b2tlbiA9IGFyZ3MuYWNjZXNzX3Rva2VuO1xuICAgIHRoaXMucmVmcmVzaF90b2tlbiA9IGFyZ3MucmVmcmVzaF90b2tlbjtcbiAgICB0aGlzLnRva2VuX3R5cGUgPSBhcmdzLnRva2VuX3R5cGU7XG4gICAgdGhpcy5zY29wZSA9IGFyZ3Muc2NvcGU7XG4gICAgdGhpcy5wcm9maWxlID0gYXJncy5wcm9maWxlO1xuICAgIHRoaXMuZXhwaXJlc19hdCA9IGFyZ3MuZXhwaXJlc19hdDtcbiAgICB0aGlzLnN0YXRlID0gYXJncy51c2VyU3RhdGU7XG4gICAgdGhpcy51cmxfc3RhdGUgPSBhcmdzLnVybF9zdGF0ZTtcbiAgfVxuICAvKiogQ29tcHV0ZWQgbnVtYmVyIG9mIHNlY29uZHMgdGhlIGFjY2VzcyB0b2tlbiBoYXMgcmVtYWluaW5nLiAqL1xuICBnZXQgZXhwaXJlc19pbigpIHtcbiAgICBpZiAodGhpcy5leHBpcmVzX2F0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfYXQgLSBUaW1lci5nZXRFcG9jaFRpbWUoKTtcbiAgfVxuICBzZXQgZXhwaXJlc19pbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmV4cGlyZXNfYXQgPSBNYXRoLmZsb29yKHZhbHVlKSArIFRpbWVyLmdldEVwb2NoVGltZSgpO1xuICAgIH1cbiAgfVxuICAvKiogQ29tcHV0ZWQgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgYWNjZXNzIHRva2VuIGlzIGV4cGlyZWQuICovXG4gIGdldCBleHBpcmVkKCkge1xuICAgIGNvbnN0IGV4cGlyZXNfaW4gPSB0aGlzLmV4cGlyZXNfaW47XG4gICAgaWYgKGV4cGlyZXNfaW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGlyZXNfaW4gPD0gMDtcbiAgfVxuICAvKiogQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwYXJzZWQgdmFsdWVzIGZyb20gdGhlIGBzY29wZWAuICovXG4gIGdldCBzY29wZXMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5zY29wZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiIFwiKSkgIT0gbnVsbCA/IF9iIDogW107XG4gIH1cbiAgdG9TdG9yYWdlU3RyaW5nKCkge1xuICAgIG5ldyBMb2dnZXIoXCJVc2VyXCIpLmNyZWF0ZShcInRvU3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgaWRfdG9rZW46IHRoaXMuaWRfdG9rZW4sXG4gICAgICBzZXNzaW9uX3N0YXRlOiB0aGlzLnNlc3Npb25fc3RhdGUsXG4gICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzX3Rva2VuLFxuICAgICAgcmVmcmVzaF90b2tlbjogdGhpcy5yZWZyZXNoX3Rva2VuLFxuICAgICAgdG9rZW5fdHlwZTogdGhpcy50b2tlbl90eXBlLFxuICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICBwcm9maWxlOiB0aGlzLnByb2ZpbGUsXG4gICAgICBleHBpcmVzX2F0OiB0aGlzLmV4cGlyZXNfYXRcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZnJvbVN0b3JhZ2VTdHJpbmcoc3RvcmFnZVN0cmluZykge1xuICAgIExvZ2dlci5jcmVhdGVTdGF0aWMoXCJVc2VyXCIsIFwiZnJvbVN0b3JhZ2VTdHJpbmdcIik7XG4gICAgcmV0dXJuIG5ldyBfVXNlcihKU09OLnBhcnNlKHN0b3JhZ2VTdHJpbmcpKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvQWJzdHJhY3RDaGlsZFdpbmRvdy50c1xudmFyIG1lc3NhZ2VTb3VyY2UgPSBcIm9pZGMtY2xpZW50XCI7XG52YXIgQWJzdHJhY3RDaGlsZFdpbmRvdyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYWJvcnQgPSBuZXcgRXZlbnQoXCJXaW5kb3cgbmF2aWdhdGlvbiBhYm9ydGVkXCIpO1xuICAgIHRoaXMuX2Rpc3Bvc2VIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgfVxuICBhc3luYyBuYXZpZ2F0ZShwYXJhbXMpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIm5hdmlnYXRlXCIpO1xuICAgIGlmICghdGhpcy5fd2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gbmF2aWdhdGUgb24gYSBkaXNwb3NlZCB3aW5kb3dcIik7XG4gICAgfVxuICAgIGxvZ2dlcjIuZGVidWcoXCJzZXR0aW5nIFVSTCBpbiB3aW5kb3dcIik7XG4gICAgdGhpcy5fd2luZG93LmxvY2F0aW9uLnJlcGxhY2UocGFyYW1zLnVybCk7XG4gICAgY29uc3QgeyB1cmwsIGtlZXBPcGVuIH0gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gKF9hID0gcGFyYW1zLnNjcmlwdE9yaWdpbikgIT0gbnVsbCA/IF9hIDogd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgaWYgKGUub3JpZ2luICE9PSBvcmlnaW4gfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuc291cmNlKSAhPT0gbWVzc2FnZVNvdXJjZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gVXJsVXRpbHMucmVhZFBhcmFtcyhkYXRhLnVybCwgcGFyYW1zLnJlc3BvbnNlX21vZGUpLmdldChcInN0YXRlXCIpO1xuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcjIud2FybihcIm5vIHN0YXRlIGZvdW5kIGluIHJlc3BvbnNlIHVybFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUuc291cmNlICE9PSB0aGlzLl93aW5kb3cgJiYgc3RhdGUgIT09IHBhcmFtcy5zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gd2luZG93XCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmFkZCgoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIsIGZhbHNlKSk7XG4gICAgICB0aGlzLl9kaXNwb3NlSGFuZGxlcnMuYWRkKHRoaXMuX2Fib3J0LmFkZEhhbmRsZXIoKHJlYXNvbikgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3QgcmVzcG9uc2UgZnJvbSB3aW5kb3dcIik7XG4gICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgIGlmICgha2VlcE9wZW4pIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdXJsIH07XG4gIH1cbiAgX2Rpc3Bvc2UoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9kaXNwb3NlXCIpO1xuICAgIGZvciAoY29uc3QgZGlzcG9zZSBvZiB0aGlzLl9kaXNwb3NlSGFuZGxlcnMpIHtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmNsZWFyKCk7XG4gIH1cbiAgc3RhdGljIF9ub3RpZnlQYXJlbnQocGFyZW50LCB1cmwsIGtlZXBPcGVuID0gZmFsc2UsIHRhcmdldE9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICBwYXJlbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgc291cmNlOiBtZXNzYWdlU291cmNlLFxuICAgICAgdXJsLFxuICAgICAga2VlcE9wZW5cbiAgICB9LCB0YXJnZXRPcmlnaW4pO1xuICB9XG59O1xuXG4vLyBzcmMvVXNlck1hbmFnZXJTZXR0aW5ncy50c1xudmFyIERlZmF1bHRQb3B1cFdpbmRvd0ZlYXR1cmVzID0ge1xuICBsb2NhdGlvbjogZmFsc2UsXG4gIHRvb2xiYXI6IGZhbHNlLFxuICBoZWlnaHQ6IDY0MCxcbiAgY2xvc2VQb3B1cFdpbmRvd0FmdGVySW5TZWNvbmRzOiAtMVxufTtcbnZhciBEZWZhdWx0UG9wdXBUYXJnZXQgPSBcIl9ibGFua1wiO1xudmFyIERlZmF1bHRBY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyA9IDYwO1xudmFyIERlZmF1bHRDaGVja1Nlc3Npb25JbnRlcnZhbEluU2Vjb25kcyA9IDI7XG52YXIgRGVmYXVsdFNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzID0gMTA7XG52YXIgVXNlck1hbmFnZXJTZXR0aW5nc1N0b3JlID0gY2xhc3MgZXh0ZW5kcyBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3B1cF9yZWRpcmVjdF91cmkgPSBhcmdzLnJlZGlyZWN0X3VyaSxcbiAgICAgIHBvcHVwX3Bvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IGFyZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgICAgcG9wdXBXaW5kb3dGZWF0dXJlcyA9IERlZmF1bHRQb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgcG9wdXBXaW5kb3dUYXJnZXQgPSBEZWZhdWx0UG9wdXBUYXJnZXQsXG4gICAgICByZWRpcmVjdE1ldGhvZCA9IFwiYXNzaWduXCIsXG4gICAgICByZWRpcmVjdFRhcmdldCA9IFwic2VsZlwiLFxuICAgICAgaWZyYW1lTm90aWZ5UGFyZW50T3JpZ2luID0gYXJncy5pZnJhbWVOb3RpZnlQYXJlbnRPcmlnaW4sXG4gICAgICBpZnJhbWVTY3JpcHRPcmlnaW4gPSBhcmdzLmlmcmFtZVNjcmlwdE9yaWdpbixcbiAgICAgIHJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgc2lsZW50X3JlZGlyZWN0X3VyaSA9IGFyZ3MucmVkaXJlY3RfdXJpLFxuICAgICAgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMsXG4gICAgICBhdXRvbWF0aWNTaWxlbnRSZW5ldyA9IHRydWUsXG4gICAgICB2YWxpZGF0ZVN1Yk9uU2lsZW50UmVuZXcgPSB0cnVlLFxuICAgICAgaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3ID0gZmFsc2UsXG4gICAgICBtb25pdG9yU2Vzc2lvbiA9IGZhbHNlLFxuICAgICAgbW9uaXRvckFub255bW91c1Nlc3Npb24gPSBmYWxzZSxcbiAgICAgIGNoZWNrU2Vzc2lvbkludGVydmFsSW5TZWNvbmRzID0gRGVmYXVsdENoZWNrU2Vzc2lvbkludGVydmFsSW5TZWNvbmRzLFxuICAgICAgcXVlcnlfc3RhdHVzX3Jlc3BvbnNlX3R5cGUgPSBcImNvZGVcIixcbiAgICAgIHN0b3BDaGVja1Nlc3Npb25PbkVycm9yID0gdHJ1ZSxcbiAgICAgIHJldm9rZVRva2VuVHlwZXMgPSBbXCJhY2Nlc3NfdG9rZW5cIiwgXCJyZWZyZXNoX3Rva2VuXCJdLFxuICAgICAgcmV2b2tlVG9rZW5zT25TaWdub3V0ID0gZmFsc2UsXG4gICAgICBpbmNsdWRlSWRUb2tlbkluU2lsZW50U2lnbm91dCA9IGZhbHNlLFxuICAgICAgYWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHMgPSBEZWZhdWx0QWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHMsXG4gICAgICB1c2VyU3RvcmVcbiAgICB9ID0gYXJncztcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLnBvcHVwX3JlZGlyZWN0X3VyaSA9IHBvcHVwX3JlZGlyZWN0X3VyaTtcbiAgICB0aGlzLnBvcHVwX3Bvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IHBvcHVwX3Bvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTtcbiAgICB0aGlzLnBvcHVwV2luZG93RmVhdHVyZXMgPSBwb3B1cFdpbmRvd0ZlYXR1cmVzO1xuICAgIHRoaXMucG9wdXBXaW5kb3dUYXJnZXQgPSBwb3B1cFdpbmRvd1RhcmdldDtcbiAgICB0aGlzLnJlZGlyZWN0TWV0aG9kID0gcmVkaXJlY3RNZXRob2Q7XG4gICAgdGhpcy5yZWRpcmVjdFRhcmdldCA9IHJlZGlyZWN0VGFyZ2V0O1xuICAgIHRoaXMuaWZyYW1lTm90aWZ5UGFyZW50T3JpZ2luID0gaWZyYW1lTm90aWZ5UGFyZW50T3JpZ2luO1xuICAgIHRoaXMuaWZyYW1lU2NyaXB0T3JpZ2luID0gaWZyYW1lU2NyaXB0T3JpZ2luO1xuICAgIHRoaXMuc2lsZW50X3JlZGlyZWN0X3VyaSA9IHNpbGVudF9yZWRpcmVjdF91cmk7XG4gICAgdGhpcy5zaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyA9IHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzIHx8IHJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzIHx8IERlZmF1bHRTaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcztcbiAgICB0aGlzLmF1dG9tYXRpY1NpbGVudFJlbmV3ID0gYXV0b21hdGljU2lsZW50UmVuZXc7XG4gICAgdGhpcy52YWxpZGF0ZVN1Yk9uU2lsZW50UmVuZXcgPSB2YWxpZGF0ZVN1Yk9uU2lsZW50UmVuZXc7XG4gICAgdGhpcy5pbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXcgPSBpbmNsdWRlSWRUb2tlbkluU2lsZW50UmVuZXc7XG4gICAgdGhpcy5tb25pdG9yU2Vzc2lvbiA9IG1vbml0b3JTZXNzaW9uO1xuICAgIHRoaXMubW9uaXRvckFub255bW91c1Nlc3Npb24gPSBtb25pdG9yQW5vbnltb3VzU2Vzc2lvbjtcbiAgICB0aGlzLmNoZWNrU2Vzc2lvbkludGVydmFsSW5TZWNvbmRzID0gY2hlY2tTZXNzaW9uSW50ZXJ2YWxJblNlY29uZHM7XG4gICAgdGhpcy5zdG9wQ2hlY2tTZXNzaW9uT25FcnJvciA9IHN0b3BDaGVja1Nlc3Npb25PbkVycm9yO1xuICAgIHRoaXMucXVlcnlfc3RhdHVzX3Jlc3BvbnNlX3R5cGUgPSBxdWVyeV9zdGF0dXNfcmVzcG9uc2VfdHlwZTtcbiAgICB0aGlzLnJldm9rZVRva2VuVHlwZXMgPSByZXZva2VUb2tlblR5cGVzO1xuICAgIHRoaXMucmV2b2tlVG9rZW5zT25TaWdub3V0ID0gcmV2b2tlVG9rZW5zT25TaWdub3V0O1xuICAgIHRoaXMuaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQgPSBpbmNsdWRlSWRUb2tlbkluU2lsZW50U2lnbm91dDtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuRXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzID0gYWNjZXNzVG9rZW5FeHBpcmluZ05vdGlmaWNhdGlvblRpbWVJblNlY29uZHM7XG4gICAgaWYgKHVzZXJTdG9yZSkge1xuICAgICAgdGhpcy51c2VyU3RvcmUgPSB1c2VyU3RvcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5zZXNzaW9uU3RvcmFnZSA6IG5ldyBJbk1lbW9yeVdlYlN0b3JhZ2UoKTtcbiAgICAgIHRoaXMudXNlclN0b3JlID0gbmV3IFdlYlN0b3JhZ2VTdGF0ZVN0b3JlKHsgc3RvcmUgfSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbmF2aWdhdG9ycy9JRnJhbWVXaW5kb3cudHNcbnZhciBJRnJhbWVXaW5kb3cgPSBjbGFzcyBfSUZyYW1lV2luZG93IGV4dGVuZHMgQWJzdHJhY3RDaGlsZFdpbmRvdyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyA9IERlZmF1bHRTaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kc1xuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiSUZyYW1lV2luZG93XCIpO1xuICAgIHRoaXMuX3RpbWVvdXRJblNlY29uZHMgPSBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcztcbiAgICB0aGlzLl9mcmFtZSA9IF9JRnJhbWVXaW5kb3cuY3JlYXRlSGlkZGVuSWZyYW1lKCk7XG4gICAgdGhpcy5fd2luZG93ID0gdGhpcy5fZnJhbWUuY29udGVudFdpbmRvdztcbiAgfVxuICBzdGF0aWMgY3JlYXRlSGlkZGVuSWZyYW1lKCkge1xuICAgIGNvbnN0IGlmcmFtZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIGlmcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgaWZyYW1lLnN0eWxlLmxlZnQgPSBcIi0xMDAwcHhcIjtcbiAgICBpZnJhbWUuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgaWZyYW1lLndpZHRoID0gXCIwXCI7XG4gICAgaWZyYW1lLmhlaWdodCA9IFwiMFwiO1xuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxuICBhc3luYyBuYXZpZ2F0ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJuYXZpZ2F0ZTogVXNpbmcgdGltZW91dCBvZjpcIiwgdGhpcy5fdGltZW91dEluU2Vjb25kcyk7XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHZvaWQgdGhpcy5fYWJvcnQucmFpc2UobmV3IEVycm9yVGltZW91dChcIklGcmFtZSB0aW1lZCBvdXQgd2l0aG91dCBhIHJlc3BvbnNlXCIpKSwgdGhpcy5fdGltZW91dEluU2Vjb25kcyAqIDFlMyk7XG4gICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmFkZCgoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpKTtcbiAgICByZXR1cm4gYXdhaXQgc3VwZXIubmF2aWdhdGUocGFyYW1zKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuX2ZyYW1lKSB7XG4gICAgICBpZiAodGhpcy5fZnJhbWUucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLl9mcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoZXYpID0+IHtcbiAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gZXYudGFyZ2V0O1xuICAgICAgICAgIChfYTIgPSBmcmFtZS5wYXJlbnROb2RlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnJlbW92ZUNoaWxkKGZyYW1lKTtcbiAgICAgICAgICB2b2lkIHRoaXMuX2Fib3J0LnJhaXNlKG5ldyBFcnJvcihcIklGcmFtZSByZW1vdmVkIGZyb20gRE9NXCIpKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIChfYSA9IHRoaXMuX2ZyYW1lLmNvbnRlbnRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYS5sb2NhdGlvbi5yZXBsYWNlKFwiYWJvdXQ6YmxhbmtcIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9mcmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RhdGljIG5vdGlmeVBhcmVudCh1cmwsIHRhcmdldE9yaWdpbikge1xuICAgIHJldHVybiBzdXBlci5fbm90aWZ5UGFyZW50KHdpbmRvdy5wYXJlbnQsIHVybCwgZmFsc2UsIHRhcmdldE9yaWdpbik7XG4gIH1cbn07XG5cbi8vIHNyYy9uYXZpZ2F0b3JzL0lGcmFtZU5hdmlnYXRvci50c1xudmFyIElGcmFtZU5hdmlnYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIklGcmFtZU5hdmlnYXRvclwiKTtcbiAgfVxuICBhc3luYyBwcmVwYXJlKHtcbiAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyA9IHRoaXMuX3NldHRpbmdzLnNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzXG4gIH0pIHtcbiAgICByZXR1cm4gbmV3IElGcmFtZVdpbmRvdyh7IHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzIH0pO1xuICB9XG4gIGFzeW5jIGNhbGxiYWNrKHVybCkge1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjYWxsYmFja1wiKTtcbiAgICBJRnJhbWVXaW5kb3cubm90aWZ5UGFyZW50KHVybCwgdGhpcy5fc2V0dGluZ3MuaWZyYW1lTm90aWZ5UGFyZW50T3JpZ2luKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvUG9wdXBXaW5kb3cudHNcbnZhciBjaGVja0ZvclBvcHVwQ2xvc2VkSW50ZXJ2YWwgPSA1MDA7XG52YXIgc2Vjb25kID0gMWUzO1xudmFyIFBvcHVwV2luZG93ID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdENoaWxkV2luZG93IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBvcHVwV2luZG93VGFyZ2V0ID0gRGVmYXVsdFBvcHVwVGFyZ2V0LFxuICAgIHBvcHVwV2luZG93RmVhdHVyZXMgPSB7fSxcbiAgICBwb3B1cFNpZ25hbFxuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiUG9wdXBXaW5kb3dcIik7XG4gICAgY29uc3QgY2VudGVyZWRQb3B1cCA9IFBvcHVwVXRpbHMuY2VudGVyKHsgLi4uRGVmYXVsdFBvcHVwV2luZG93RmVhdHVyZXMsIC4uLnBvcHVwV2luZG93RmVhdHVyZXMgfSk7XG4gICAgdGhpcy5fd2luZG93ID0gd2luZG93Lm9wZW4odm9pZCAwLCBwb3B1cFdpbmRvd1RhcmdldCwgUG9wdXBVdGlscy5zZXJpYWxpemUoY2VudGVyZWRQb3B1cCkpO1xuICAgIGlmIChwb3B1cFNpZ25hbCkge1xuICAgICAgcG9wdXBTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2b2lkIHRoaXMuX2Fib3J0LnJhaXNlKG5ldyBFcnJvcigoX2EgPSBwb3B1cFNpZ25hbC5yZWFzb24pICE9IG51bGwgPyBfYSA6IFwiUG9wdXAgYWJvcnRlZFwiKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBvcHVwV2luZG93RmVhdHVyZXMuY2xvc2VQb3B1cFdpbmRvd0FmdGVySW5TZWNvbmRzICYmIHBvcHVwV2luZG93RmVhdHVyZXMuY2xvc2VQb3B1cFdpbmRvd0FmdGVySW5TZWNvbmRzID4gMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fd2luZG93IHx8IHR5cGVvZiB0aGlzLl93aW5kb3cuY2xvc2VkICE9PSBcImJvb2xlYW5cIiB8fCB0aGlzLl93aW5kb3cuY2xvc2VkKSB7XG4gICAgICAgICAgdm9pZCB0aGlzLl9hYm9ydC5yYWlzZShuZXcgRXJyb3IoXCJQb3B1cCBibG9ja2VkIGJ5IHVzZXJcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9LCBwb3B1cFdpbmRvd0ZlYXR1cmVzLmNsb3NlUG9wdXBXaW5kb3dBZnRlckluU2Vjb25kcyAqIHNlY29uZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIG5hdmlnYXRlKHBhcmFtcykge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl93aW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgIGNvbnN0IHBvcHVwQ2xvc2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3dpbmRvdyB8fCB0aGlzLl93aW5kb3cuY2xvc2VkKSB7XG4gICAgICAgIHZvaWQgdGhpcy5fYWJvcnQucmFpc2UobmV3IEVycm9yKFwiUG9wdXAgY2xvc2VkIGJ5IHVzZXJcIikpO1xuICAgICAgfVxuICAgIH0sIGNoZWNrRm9yUG9wdXBDbG9zZWRJbnRlcnZhbCk7XG4gICAgdGhpcy5fZGlzcG9zZUhhbmRsZXJzLmFkZCgoKSA9PiBjbGVhckludGVydmFsKHBvcHVwQ2xvc2VkSW50ZXJ2YWwpKTtcbiAgICByZXR1cm4gYXdhaXQgc3VwZXIubmF2aWdhdGUocGFyYW1zKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5fd2luZG93KSB7XG4gICAgICBpZiAoIXRoaXMuX3dpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5fd2luZG93LmNsb3NlKCk7XG4gICAgICAgIHZvaWQgdGhpcy5fYWJvcnQucmFpc2UobmV3IEVycm9yKFwiUG9wdXAgY2xvc2VkXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgbm90aWZ5T3BlbmVyKHVybCwga2VlcE9wZW4pIHtcbiAgICBpZiAoIXdpbmRvdy5vcGVuZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHdpbmRvdy5vcGVuZXIuIENhbid0IGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cIik7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fbm90aWZ5UGFyZW50KHdpbmRvdy5vcGVuZXIsIHVybCwga2VlcE9wZW4pO1xuICB9XG59O1xuXG4vLyBzcmMvbmF2aWdhdG9ycy9Qb3B1cE5hdmlnYXRvci50c1xudmFyIFBvcHVwTmF2aWdhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc2V0dGluZ3MpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9zZXR0aW5ncztcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiUG9wdXBOYXZpZ2F0b3JcIik7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZSh7XG4gICAgcG9wdXBXaW5kb3dGZWF0dXJlcyA9IHRoaXMuX3NldHRpbmdzLnBvcHVwV2luZG93RmVhdHVyZXMsXG4gICAgcG9wdXBXaW5kb3dUYXJnZXQgPSB0aGlzLl9zZXR0aW5ncy5wb3B1cFdpbmRvd1RhcmdldCxcbiAgICBwb3B1cFNpZ25hbFxuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBQb3B1cFdpbmRvdyh7IHBvcHVwV2luZG93RmVhdHVyZXMsIHBvcHVwV2luZG93VGFyZ2V0LCBwb3B1cFNpZ25hbCB9KTtcbiAgfVxuICBhc3luYyBjYWxsYmFjayh1cmwsIHsga2VlcE9wZW4gPSBmYWxzZSB9KSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImNhbGxiYWNrXCIpO1xuICAgIFBvcHVwV2luZG93Lm5vdGlmeU9wZW5lcih1cmwsIGtlZXBPcGVuKTtcbiAgfVxufTtcblxuLy8gc3JjL25hdmlnYXRvcnMvUmVkaXJlY3ROYXZpZ2F0b3IudHNcbnZhciBSZWRpcmVjdE5hdmlnYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NldHRpbmdzKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfc2V0dGluZ3M7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlJlZGlyZWN0TmF2aWdhdG9yXCIpO1xuICB9XG4gIGFzeW5jIHByZXBhcmUoe1xuICAgIHJlZGlyZWN0TWV0aG9kID0gdGhpcy5fc2V0dGluZ3MucmVkaXJlY3RNZXRob2QsXG4gICAgcmVkaXJlY3RUYXJnZXQgPSB0aGlzLl9zZXR0aW5ncy5yZWRpcmVjdFRhcmdldFxuICB9KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJwcmVwYXJlXCIpO1xuICAgIGxldCB0YXJnZXRXaW5kb3cgPSB3aW5kb3cuc2VsZjtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQgPT09IFwidG9wXCIpIHtcbiAgICAgIHRhcmdldFdpbmRvdyA9IChfYSA9IHdpbmRvdy50b3ApICE9IG51bGwgPyBfYSA6IHdpbmRvdy5zZWxmO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdCA9IHRhcmdldFdpbmRvdy5sb2NhdGlvbltyZWRpcmVjdE1ldGhvZF0uYmluZCh0YXJnZXRXaW5kb3cubG9jYXRpb24pO1xuICAgIGxldCBhYm9ydDtcbiAgICByZXR1cm4ge1xuICAgICAgbmF2aWdhdGU6IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIm5hdmlnYXRlXCIpO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGFib3J0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmVkaXJlY3QocGFyYW1zLnVybCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJjbG9zZVwiKTtcbiAgICAgICAgYWJvcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0KG5ldyBFcnJvcihcIlJlZGlyZWN0IGFib3J0ZWRcIikpO1xuICAgICAgICB0YXJnZXRXaW5kb3cuc3RvcCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgY2FsbGJhY2soKSB7XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG4vLyBzcmMvVXNlck1hbmFnZXJFdmVudHMudHNcbnZhciBVc2VyTWFuYWdlckV2ZW50cyA9IGNsYXNzIGV4dGVuZHMgQWNjZXNzVG9rZW5FdmVudHMge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHsgZXhwaXJpbmdOb3RpZmljYXRpb25UaW1lSW5TZWNvbmRzOiBzZXR0aW5ncy5hY2Nlc3NUb2tlbkV4cGlyaW5nTm90aWZpY2F0aW9uVGltZUluU2Vjb25kcyB9KTtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiVXNlck1hbmFnZXJFdmVudHNcIik7XG4gICAgdGhpcy5fdXNlckxvYWRlZCA9IG5ldyBFdmVudChcIlVzZXIgbG9hZGVkXCIpO1xuICAgIHRoaXMuX3VzZXJVbmxvYWRlZCA9IG5ldyBFdmVudChcIlVzZXIgdW5sb2FkZWRcIik7XG4gICAgdGhpcy5fc2lsZW50UmVuZXdFcnJvciA9IG5ldyBFdmVudChcIlNpbGVudCByZW5ldyBlcnJvclwiKTtcbiAgICB0aGlzLl91c2VyU2lnbmVkSW4gPSBuZXcgRXZlbnQoXCJVc2VyIHNpZ25lZCBpblwiKTtcbiAgICB0aGlzLl91c2VyU2lnbmVkT3V0ID0gbmV3IEV2ZW50KFwiVXNlciBzaWduZWQgb3V0XCIpO1xuICAgIHRoaXMuX3VzZXJTZXNzaW9uQ2hhbmdlZCA9IG5ldyBFdmVudChcIlVzZXIgc2Vzc2lvbiBjaGFuZ2VkXCIpO1xuICB9XG4gIGFzeW5jIGxvYWQodXNlciwgcmFpc2VFdmVudCA9IHRydWUpIHtcbiAgICBhd2FpdCBzdXBlci5sb2FkKHVzZXIpO1xuICAgIGlmIChyYWlzZUV2ZW50KSB7XG4gICAgICBhd2FpdCB0aGlzLl91c2VyTG9hZGVkLnJhaXNlKHVzZXIpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1bmxvYWQoKSB7XG4gICAgYXdhaXQgc3VwZXIudW5sb2FkKCk7XG4gICAgYXdhaXQgdGhpcy5fdXNlclVubG9hZGVkLnJhaXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjazogUmFpc2VkIHdoZW4gYSB1c2VyIHNlc3Npb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQgKG9yIHJlLWVzdGFibGlzaGVkKS5cbiAgICovXG4gIGFkZFVzZXJMb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckxvYWRlZC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiBhIHVzZXIgc2Vzc2lvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZCAob3IgcmUtZXN0YWJsaXNoZWQpLlxuICAgKi9cbiAgcmVtb3ZlVXNlckxvYWRlZChjYikge1xuICAgIHJldHVybiB0aGlzLl91c2VyTG9hZGVkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIGEgdXNlciBzZXNzaW9uIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAqL1xuICBhZGRVc2VyVW5sb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclVubG9hZGVkLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIGEgdXNlciBzZXNzaW9uIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAqL1xuICByZW1vdmVVc2VyVW5sb2FkZWQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclVubG9hZGVkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSBhdXRvbWF0aWMgc2lsZW50IHJlbmV3IGhhcyBmYWlsZWQuXG4gICAqL1xuICBhZGRTaWxlbnRSZW5ld0Vycm9yKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpbGVudFJlbmV3RXJyb3IuYWRkSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBjYWxsYmFjazogUmFpc2VkIHdoZW4gdGhlIGF1dG9tYXRpYyBzaWxlbnQgcmVuZXcgaGFzIGZhaWxlZC5cbiAgICovXG4gIHJlbW92ZVNpbGVudFJlbmV3RXJyb3IoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lsZW50UmVuZXdFcnJvci5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfcmFpc2VTaWxlbnRSZW5ld0Vycm9yKGUpIHtcbiAgICBhd2FpdCB0aGlzLl9zaWxlbnRSZW5ld0Vycm9yLnJhaXNlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyIGlzIHNpZ25lZCBpbiAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqIEBzZWUge0BsaW5rIFVzZXJNYW5hZ2VyU2V0dGluZ3MubW9uaXRvclNlc3Npb259XG4gICAqL1xuICBhZGRVc2VyU2lnbmVkSW4oY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclNpZ25lZEluLmFkZEhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyIGlzIHNpZ25lZCBpbiAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqL1xuICByZW1vdmVVc2VyU2lnbmVkSW4oY2IpIHtcbiAgICB0aGlzLl91c2VyU2lnbmVkSW4ucmVtb3ZlSGFuZGxlcihjYik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX3JhaXNlVXNlclNpZ25lZEluKCkge1xuICAgIGF3YWl0IHRoaXMuX3VzZXJTaWduZWRJbi5yYWlzZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgY2FsbGJhY2s6IFJhaXNlZCB3aGVuIHRoZSB1c2VyJ3Mgc2lnbi1pbiBzdGF0dXMgYXQgdGhlIE9QIGhhcyBjaGFuZ2VkICh3aGVuIGBtb25pdG9yU2Vzc2lvbmAgaXMgc2V0KS5cbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXJTZXR0aW5ncy5tb25pdG9yU2Vzc2lvbn1cbiAgICovXG4gIGFkZFVzZXJTaWduZWRPdXQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclNpZ25lZE91dC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlcidzIHNpZ24taW4gc3RhdHVzIGF0IHRoZSBPUCBoYXMgY2hhbmdlZCAod2hlbiBgbW9uaXRvclNlc3Npb25gIGlzIHNldCkuXG4gICAqL1xuICByZW1vdmVVc2VyU2lnbmVkT3V0KGNiKSB7XG4gICAgdGhpcy5fdXNlclNpZ25lZE91dC5yZW1vdmVIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfcmFpc2VVc2VyU2lnbmVkT3V0KCkge1xuICAgIGF3YWl0IHRoaXMuX3VzZXJTaWduZWRPdXQucmFpc2UoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlciBzZXNzaW9uIGNoYW5nZWQgKHdoZW4gYG1vbml0b3JTZXNzaW9uYCBpcyBzZXQpLlxuICAgKiBAc2VlIHtAbGluayBVc2VyTWFuYWdlclNldHRpbmdzLm1vbml0b3JTZXNzaW9ufVxuICAgKi9cbiAgYWRkVXNlclNlc3Npb25DaGFuZ2VkKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJTZXNzaW9uQ2hhbmdlZC5hZGRIYW5kbGVyKGNiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrOiBSYWlzZWQgd2hlbiB0aGUgdXNlciBzZXNzaW9uIGNoYW5nZWQgKHdoZW4gYG1vbml0b3JTZXNzaW9uYCBpcyBzZXQpLlxuICAgKi9cbiAgcmVtb3ZlVXNlclNlc3Npb25DaGFuZ2VkKGNiKSB7XG4gICAgdGhpcy5fdXNlclNlc3Npb25DaGFuZ2VkLnJlbW92ZUhhbmRsZXIoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9yYWlzZVVzZXJTZXNzaW9uQ2hhbmdlZCgpIHtcbiAgICBhd2FpdCB0aGlzLl91c2VyU2Vzc2lvbkNoYW5nZWQucmFpc2UoKTtcbiAgfVxufTtcblxuLy8gc3JjL1NpbGVudFJlbmV3U2VydmljZS50c1xudmFyIFNpbGVudFJlbmV3U2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3VzZXJNYW5hZ2VyKSB7XG4gICAgdGhpcy5fdXNlck1hbmFnZXIgPSBfdXNlck1hbmFnZXI7XG4gICAgdGhpcy5fbG9nZ2VyID0gbmV3IExvZ2dlcihcIlNpbGVudFJlbmV3U2VydmljZVwiKTtcbiAgICB0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXRyeVRpbWVyID0gbmV3IFRpbWVyKFwiUmV0cnkgU2lsZW50IFJlbmV3XCIpO1xuICAgIHRoaXMuX3Rva2VuRXhwaXJpbmcgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl90b2tlbkV4cGlyaW5nXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIuc2lnbmluU2lsZW50KCk7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzaWxlbnQgdG9rZW4gcmVuZXdhbCBzdWNjZXNzZnVsXCIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvclRpbWVvdXQpIHtcbiAgICAgICAgICBsb2dnZXIyLndhcm4oXCJFcnJvclRpbWVvdXQgZnJvbSBzaWduaW5TaWxlbnQ6XCIsIGVyciwgXCJyZXRyeSBpbiA1c1wiKTtcbiAgICAgICAgICB0aGlzLl9yZXRyeVRpbWVyLmluaXQoNSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcjIuZXJyb3IoXCJFcnJvciBmcm9tIHNpZ25pblNpbGVudDpcIiwgZXJyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fdXNlck1hbmFnZXIuZXZlbnRzLl9yYWlzZVNpbGVudFJlbmV3RXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic3RhcnRcIik7XG4gICAgaWYgKCF0aGlzLl9pc1N0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMuYWRkQWNjZXNzVG9rZW5FeHBpcmluZyh0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRoaXMuX3JldHJ5VGltZXIuYWRkSGFuZGxlcih0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VzZXJNYW5hZ2VyLmdldFVzZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2dnZXIyLmVycm9yKFwiZ2V0VXNlciBlcnJvclwiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9pc1N0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3JldHJ5VGltZXIuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9yZXRyeVRpbWVyLnJlbW92ZUhhbmRsZXIodGhpcy5fdG9rZW5FeHBpcmluZyk7XG4gICAgICB0aGlzLl91c2VyTWFuYWdlci5ldmVudHMucmVtb3ZlQWNjZXNzVG9rZW5FeHBpcmluZyh0aGlzLl90b2tlbkV4cGlyaW5nKTtcbiAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL1JlZnJlc2hTdGF0ZS50c1xudmFyIFJlZnJlc2hTdGF0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMucmVmcmVzaF90b2tlbiA9IGFyZ3MucmVmcmVzaF90b2tlbjtcbiAgICB0aGlzLmlkX3Rva2VuID0gYXJncy5pZF90b2tlbjtcbiAgICB0aGlzLnNlc3Npb25fc3RhdGUgPSBhcmdzLnNlc3Npb25fc3RhdGU7XG4gICAgdGhpcy5zY29wZSA9IGFyZ3Muc2NvcGU7XG4gICAgdGhpcy5wcm9maWxlID0gYXJncy5wcm9maWxlO1xuICAgIHRoaXMuZGF0YSA9IGFyZ3Muc3RhdGU7XG4gIH1cbn07XG5cbi8vIHNyYy9Vc2VyTWFuYWdlci50c1xudmFyIFVzZXJNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgcmVkaXJlY3ROYXZpZ2F0b3IsIHBvcHVwTmF2aWdhdG9yLCBpZnJhbWVOYXZpZ2F0b3IpIHtcbiAgICB0aGlzLl9sb2dnZXIgPSBuZXcgTG9nZ2VyKFwiVXNlck1hbmFnZXJcIik7XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBVc2VyTWFuYWdlclNldHRpbmdzU3RvcmUoc2V0dGluZ3MpO1xuICAgIHRoaXMuX2NsaWVudCA9IG5ldyBPaWRjQ2xpZW50KHNldHRpbmdzKTtcbiAgICB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvciA9IHJlZGlyZWN0TmF2aWdhdG9yICE9IG51bGwgPyByZWRpcmVjdE5hdmlnYXRvciA6IG5ldyBSZWRpcmVjdE5hdmlnYXRvcih0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLl9wb3B1cE5hdmlnYXRvciA9IHBvcHVwTmF2aWdhdG9yICE9IG51bGwgPyBwb3B1cE5hdmlnYXRvciA6IG5ldyBQb3B1cE5hdmlnYXRvcih0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLl9pZnJhbWVOYXZpZ2F0b3IgPSBpZnJhbWVOYXZpZ2F0b3IgIT0gbnVsbCA/IGlmcmFtZU5hdmlnYXRvciA6IG5ldyBJRnJhbWVOYXZpZ2F0b3IodGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IFVzZXJNYW5hZ2VyRXZlbnRzKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuX3NpbGVudFJlbmV3U2VydmljZSA9IG5ldyBTaWxlbnRSZW5ld1NlcnZpY2UodGhpcyk7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuYXV0b21hdGljU2lsZW50UmVuZXcpIHtcbiAgICAgIHRoaXMuc3RhcnRTaWxlbnRSZW5ldygpO1xuICAgIH1cbiAgICB0aGlzLl9zZXNzaW9uTW9uaXRvciA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubW9uaXRvclNlc3Npb24pIHtcbiAgICAgIHRoaXMuX3Nlc3Npb25Nb25pdG9yID0gbmV3IFNlc3Npb25Nb25pdG9yKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IG9iamVjdCB1c2VkIHRvIHJlZ2lzdGVyIGZvciBldmVudHMgcmFpc2VkIGJ5IHRoZSBgVXNlck1hbmFnZXJgLlxuICAgKi9cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb2JqZWN0IHVzZWQgdG8gYWNjZXNzIHRoZSBtZXRhZGF0YSBjb25maWd1cmF0aW9uIG9mIHRoZSBpZGVudGl0eSBwcm92aWRlci5cbiAgICovXG4gIGdldCBtZXRhZGF0YVNlcnZpY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5tZXRhZGF0YVNlcnZpY2U7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgdGhlIGBVc2VyYCBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB1c2VyLlxuICAgKlxuICAgKiBAcGFyYW0gcmFpc2VFdmVudCAtIElmIGB0cnVlYCwgdGhlIGBVc2VyTG9hZGVkYCBldmVudCB3aWxsIGJlIHJhaXNlZC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlcihyYWlzZUV2ZW50ID0gZmFsc2UpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcImdldFVzZXJcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX2xvYWRVc2VyKCk7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcInVzZXIgbG9hZGVkXCIpO1xuICAgICAgYXdhaXQgdGhpcy5fZXZlbnRzLmxvYWQodXNlciwgcmFpc2VFdmVudCk7XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gICAgbG9nZ2VyMi5pbmZvKFwidXNlciBub3QgZm91bmQgaW4gc3RvcmFnZVwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGZyb20gYW55IHN0b3JhZ2UgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlVXNlcigpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInJlbW92ZVVzZXJcIik7XG4gICAgYXdhaXQgdGhpcy5zdG9yZVVzZXIobnVsbCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwidXNlciByZW1vdmVkIGZyb20gc3RvcmFnZVwiKTtcbiAgICBhd2FpdCB0aGlzLl9ldmVudHMudW5sb2FkKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSByZWRpcmVjdCBvZiB0aGUgY3VycmVudCB3aW5kb3cgdG8gdGhlIGF1dGhvcml6YXRpb24gZW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZVxuICAgKlxuICAgKiBAdGhyb3dzIGBFcnJvcmAgSW4gY2FzZXMgb2Ygd3JvbmcgYXV0aGVudGljYXRpb24uXG4gICAqL1xuICBhc3luYyBzaWduaW5SZWRpcmVjdChhcmdzID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblJlZGlyZWN0XCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZGlyZWN0TWV0aG9kLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBsZXQgZHBvcEprdDtcbiAgICBpZiAoKF9hID0gdGhpcy5zZXR0aW5ncy5kcG9wKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYmluZF9hdXRob3JpemF0aW9uX2NvZGUpIHtcbiAgICAgIGRwb3BKa3QgPSBhd2FpdCB0aGlzLmdlbmVyYXRlRFBvUEprdCh0aGlzLnNldHRpbmdzLmRwb3ApO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvci5wcmVwYXJlKHsgcmVkaXJlY3RNZXRob2QgfSk7XG4gICAgYXdhaXQgdGhpcy5fc2lnbmluU3RhcnQoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNpOnJcIixcbiAgICAgIGRwb3BKa3QsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIHJlc3BvbnNlIChjYWxsYmFjaykgZnJvbSB0aGUgYXV0aG9yaXphdGlvbiBlbmRwb2ludC5cbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5DYWxsYmFja30gaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIGF1dGhlbnRpY2F0ZWQgYFVzZXJgLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5DYWxsYmFja31cbiAgICovXG4gIGFzeW5jIHNpZ25pblJlZGlyZWN0Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25pblJlZGlyZWN0Q2FsbGJhY2tcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuX3NpZ25pbkVuZCh1cmwpO1xuICAgIGlmICh1c2VyLnByb2ZpbGUgJiYgdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzcywgc2lnbmVkIGluIHN1YmplY3RcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSBzaWduaW4gd2l0aCB1c2VyL3Bhc3N3b3JkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgY29udGFpbmluZyB0aGUgYXV0aGVudGljYXRlZCBgVXNlcmAuXG4gICAqIEB0aHJvd3Mge0BsaW5rIEVycm9yUmVzcG9uc2V9IEluIGNhc2VzIG9mIHdyb25nIGF1dGhlbnRpY2F0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2lnbmluUmVzb3VyY2VPd25lckNyZWRlbnRpYWxzKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBza2lwVXNlckluZm8gPSBmYWxzZVxuICB9KSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5SZXNvdXJjZU93bmVyQ3JlZGVudGlhbFwiKTtcbiAgICBjb25zdCBzaWduaW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NsaWVudC5wcm9jZXNzUmVzb3VyY2VPd25lclBhc3N3b3JkQ3JlZGVudGlhbHMoe1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHNraXBVc2VySW5mbyxcbiAgICAgIGV4dHJhVG9rZW5QYXJhbXM6IHRoaXMuc2V0dGluZ3MuZXh0cmFUb2tlblBhcmFtc1xuICAgIH0pO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlc3BvbnNlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9idWlsZFVzZXIoc2lnbmluUmVzcG9uc2UpO1xuICAgIGlmICh1c2VyLnByb2ZpbGUgJiYgdXNlci5wcm9maWxlLnN1Yikge1xuICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzcywgc2lnbmVkIGluIHN1YmplY3RcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgcmVxdWVzdCAodmlhIGEgcG9wdXAgd2luZG93KSB0byB0aGUgYXV0aG9yaXphdGlvbiBlbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIGNvbnRhaW5pbmcgdGhlIGF1dGhlbnRpY2F0ZWQgYFVzZXJgLlxuICAgKiBAdGhyb3dzIGBFcnJvcmAgSW4gY2FzZXMgb2Ygd3JvbmcgYXV0aGVudGljYXRpb24uXG4gICAqL1xuICBhc3luYyBzaWduaW5Qb3B1cChhcmdzID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5Qb3B1cFwiKTtcbiAgICBsZXQgZHBvcEprdDtcbiAgICBpZiAoKF9hID0gdGhpcy5zZXR0aW5ncy5kcG9wKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYmluZF9hdXRob3JpemF0aW9uX2NvZGUpIHtcbiAgICAgIGRwb3BKa3QgPSBhd2FpdCB0aGlzLmdlbmVyYXRlRFBvUEprdCh0aGlzLnNldHRpbmdzLmRwb3ApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgcG9wdXBXaW5kb3dUYXJnZXQsXG4gICAgICBwb3B1cFNpZ25hbCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9yZWRpcmVjdF91cmk7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGxvZ2dlcjIudGhyb3cobmV3IEVycm9yKFwiTm8gcG9wdXBfcmVkaXJlY3RfdXJpIGNvbmZpZ3VyZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9wb3B1cE5hdmlnYXRvci5wcmVwYXJlKHsgcG9wdXBXaW5kb3dGZWF0dXJlcywgcG9wdXBXaW5kb3dUYXJnZXQsIHBvcHVwU2lnbmFsIH0pO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9zaWduaW4oe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNpOnBcIixcbiAgICAgIHJlZGlyZWN0X3VyaTogdXJsLFxuICAgICAgZGlzcGxheTogXCJwb3B1cFwiLFxuICAgICAgZHBvcEprdCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSwgaGFuZGxlKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgaWYgKHVzZXIucHJvZmlsZSAmJiB1c2VyLnByb2ZpbGUuc3ViKSB7XG4gICAgICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3MsIHNpZ25lZCBpbiBzdWJqZWN0XCIsIHVzZXIucHJvZmlsZS5zdWIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyMi5pbmZvKFwibm8gc3ViamVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSB0aGUgb3BlbmluZyB3aW5kb3cgb2YgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Uge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25pbkNhbGxiYWNrfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbmluQ2FsbGJhY2t9XG4gICAqL1xuICBhc3luYyBzaWduaW5Qb3B1cENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBrZWVwT3BlbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWduaW5Qb3B1cENhbGxiYWNrXCIpO1xuICAgIGF3YWl0IHRoaXMuX3BvcHVwTmF2aWdhdG9yLmNhbGxiYWNrKHVybCwgeyBrZWVwT3BlbiB9KTtcbiAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgc2lsZW50IHJlcXVlc3QgKHZpYSByZWZyZXNoIHRva2VuIG9yIGFuIGlmcmFtZSkgdG8gdGhlIGF1dGhvcml6YXRpb24gZW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IGNvbnRhaW5zIHRoZSBhdXRoZW50aWNhdGVkIGBVc2VyYC5cbiAgICovXG4gIGFzeW5jIHNpZ25pblNpbGVudChhcmdzID0ge30pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbmluU2lsZW50XCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBsZXQgdXNlciA9IGF3YWl0IHRoaXMuX2xvYWRVc2VyKCk7XG4gICAgaWYgKHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIucmVmcmVzaF90b2tlbikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzaW5nIHJlZnJlc2ggdG9rZW5cIik7XG4gICAgICBjb25zdCBzdGF0ZSA9IG5ldyBSZWZyZXNoU3RhdGUodXNlcik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlUmVmcmVzaFRva2VuKHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlZGlyZWN0X3VyaTogcmVxdWVzdEFyZ3MucmVkaXJlY3RfdXJpLFxuICAgICAgICByZXNvdXJjZTogcmVxdWVzdEFyZ3MucmVzb3VyY2UsXG4gICAgICAgIGV4dHJhVG9rZW5QYXJhbXM6IHJlcXVlc3RBcmdzLmV4dHJhVG9rZW5QYXJhbXMsXG4gICAgICAgIHRpbWVvdXRJblNlY29uZHM6IHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGRwb3BKa3Q7XG4gICAgaWYgKChfYSA9IHRoaXMuc2V0dGluZ3MuZHBvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJpbmRfYXV0aG9yaXphdGlvbl9jb2RlKSB7XG4gICAgICBkcG9wSmt0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZURQb1BKa3QodGhpcy5zZXR0aW5ncy5kcG9wKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5zaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIHNpbGVudF9yZWRpcmVjdF91cmkgY29uZmlndXJlZFwiKSk7XG4gICAgfVxuICAgIGxldCB2ZXJpZnlTdWI7XG4gICAgaWYgKHVzZXIgJiYgdGhpcy5zZXR0aW5ncy52YWxpZGF0ZVN1Yk9uU2lsZW50UmVuZXcpIHtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJzdWJqZWN0IHByaW9yIHRvIHNpbGVudCByZW5ldzpcIiwgdXNlci5wcm9maWxlLnN1Yik7XG4gICAgICB2ZXJpZnlTdWIgPSB1c2VyLnByb2ZpbGUuc3ViO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9pZnJhbWVOYXZpZ2F0b3IucHJlcGFyZSh7IHNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzIH0pO1xuICAgIHVzZXIgPSBhd2FpdCB0aGlzLl9zaWduaW4oe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInNpOnNcIixcbiAgICAgIHJlZGlyZWN0X3VyaTogdXJsLFxuICAgICAgcHJvbXB0OiBcIm5vbmVcIixcbiAgICAgIGlkX3Rva2VuX2hpbnQ6IHRoaXMuc2V0dGluZ3MuaW5jbHVkZUlkVG9rZW5JblNpbGVudFJlbmV3ID8gdXNlciA9PSBudWxsID8gdm9pZCAwIDogdXNlci5pZF90b2tlbiA6IHZvaWQgMCxcbiAgICAgIGRwb3BKa3QsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSwgdmVyaWZ5U3ViKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgaWYgKChfYiA9IHVzZXIucHJvZmlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnN1Yikge1xuICAgICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzLCBzaWduZWQgaW4gc3ViamVjdFwiLCB1c2VyLnByb2ZpbGUuc3ViKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlcjIuaW5mbyhcIm5vIHN1YmplY3RcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIGFzeW5jIF91c2VSZWZyZXNoVG9rZW4oYXJncykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2xpZW50LnVzZVJlZnJlc2hUb2tlbih7XG4gICAgICB0aW1lb3V0SW5TZWNvbmRzOiB0aGlzLnNldHRpbmdzLnNpbGVudFJlcXVlc3RUaW1lb3V0SW5TZWNvbmRzLFxuICAgICAgLi4uYXJnc1xuICAgIH0pO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih7IC4uLmFyZ3Muc3RhdGUsIC4uLnJlc3BvbnNlIH0pO1xuICAgIGF3YWl0IHRoaXMuc3RvcmVVc2VyKHVzZXIpO1xuICAgIGF3YWl0IHRoaXMuX2V2ZW50cy5sb2FkKHVzZXIpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBOb3RpZnkgdGhlIHBhcmVudCB3aW5kb3cgb2YgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Uge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25pbkNhbGxiYWNrfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbmluQ2FsbGJhY2t9XG4gICAqL1xuICBhc3luYyBzaWduaW5TaWxlbnRDYWxsYmFjayh1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbmluU2lsZW50Q2FsbGJhY2tcIik7XG4gICAgYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLmNhbGxiYWNrKHVybCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhbnkgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIGVuZHBvaW50LCBieSBkaXNwYXRjaGluZyB0aGUgcmVxdWVzdF90eXBlXG4gICAqIGFuZCBleGVjdXRpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICAgKiAtIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5SZWRpcmVjdENhbGxiYWNrfVxuICAgKiAtIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5Qb3B1cENhbGxiYWNrfVxuICAgKiAtIHtAbGluayBVc2VyTWFuYWdlci5zaWduaW5TaWxlbnRDYWxsYmFja31cbiAgICpcbiAgICogQHRocm93cyBgRXJyb3JgIElmIHJlcXVlc3RfdHlwZSBpcyB1bmtub3duIG9yIHNpZ25pbiBjYW5ub3QgYmUgcHJvY2Vzc2VkLlxuICAgKi9cbiAgYXN5bmMgc2lnbmluQ2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBhd2FpdCB0aGlzLl9jbGllbnQucmVhZFNpZ25pblJlc3BvbnNlU3RhdGUodXJsKTtcbiAgICBzd2l0Y2ggKHN0YXRlLnJlcXVlc3RfdHlwZSkge1xuICAgICAgY2FzZSBcInNpOnJcIjpcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbmluUmVkaXJlY3RDYWxsYmFjayh1cmwpO1xuICAgICAgY2FzZSBcInNpOnBcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5zaWduaW5Qb3B1cENhbGxiYWNrKHVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNpOnNcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5zaWduaW5TaWxlbnRDYWxsYmFjayh1cmwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VfdHlwZSBpbiBzdGF0ZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBhbnkgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludCwgYnkgZGlzcGF0Y2hpbmcgdGhlIHJlcXVlc3RfdHlwZVxuICAgKiBhbmQgZXhlY3V0aW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAgICogLSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbm91dFJlZGlyZWN0Q2FsbGJhY2t9XG4gICAqIC0ge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25vdXRQb3B1cENhbGxiYWNrfVxuICAgKiAtIHtAbGluayBVc2VyTWFuYWdlci5zaWdub3V0U2lsZW50Q2FsbGJhY2t9XG4gICAqXG4gICAqIEB0aHJvd3MgYEVycm9yYCBJZiByZXF1ZXN0X3R5cGUgaXMgdW5rbm93biBvciBzaWdub3V0IGNhbm5vdCBiZSBwcm9jZXNzZWQuXG4gICAqL1xuICBhc3luYyBzaWdub3V0Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYsIGtlZXBPcGVuID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBhd2FpdCB0aGlzLl9jbGllbnQucmVhZFNpZ25vdXRSZXNwb25zZVN0YXRlKHVybCk7XG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgc3dpdGNoIChzdGF0ZS5yZXF1ZXN0X3R5cGUpIHtcbiAgICAgIGNhc2UgXCJzbzpyXCI6XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25vdXRSZWRpcmVjdENhbGxiYWNrKHVybCk7XG4gICAgICBjYXNlIFwic286cFwiOlxuICAgICAgICBhd2FpdCB0aGlzLnNpZ25vdXRQb3B1cENhbGxiYWNrKHVybCwga2VlcE9wZW4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzbzpzXCI6XG4gICAgICAgIGF3YWl0IHRoaXMuc2lnbm91dFNpbGVudENhbGxiYWNrKHVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZV90eXBlIGluIHN0YXRlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBRdWVyeSBPUCBmb3IgdXNlcidzIGN1cnJlbnQgc2lnbmluIHN0YXR1cy5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlIG9iamVjdCB3aXRoIHNlc3Npb25fc3RhdGUgYW5kIHN1YmplY3QgaWRlbnRpZmllci5cbiAgICovXG4gIGFzeW5jIHF1ZXJ5U2Vzc2lvblN0YXR1cyhhcmdzID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInF1ZXJ5U2Vzc2lvblN0YXR1c1wiKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5zaWxlbnRfcmVkaXJlY3RfdXJpO1xuICAgIGlmICghdXJsKSB7XG4gICAgICBsb2dnZXIyLnRocm93KG5ldyBFcnJvcihcIk5vIHNpbGVudF9yZWRpcmVjdF91cmkgY29uZmlndXJlZFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgIGNvbnN0IGhhbmRsZSA9IGF3YWl0IHRoaXMuX2lmcmFtZU5hdmlnYXRvci5wcmVwYXJlKHsgc2lsZW50UmVxdWVzdFRpbWVvdXRJblNlY29uZHMgfSk7XG4gICAgY29uc3QgbmF2UmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zaWduaW5TdGFydCh7XG4gICAgICByZXF1ZXN0X3R5cGU6IFwic2k6c1wiLFxuICAgICAgLy8gdGhpcyBhY3RzIGxpa2UgYSBzaWduaW4gc2lsZW50XG4gICAgICByZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIHByb21wdDogXCJub25lXCIsXG4gICAgICBpZF90b2tlbl9oaW50OiB0aGlzLnNldHRpbmdzLmluY2x1ZGVJZFRva2VuSW5TaWxlbnRSZW5ldyA/IHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIuaWRfdG9rZW4gOiB2b2lkIDAsXG4gICAgICByZXNwb25zZV90eXBlOiB0aGlzLnNldHRpbmdzLnF1ZXJ5X3N0YXR1c19yZXNwb25zZV90eXBlLFxuICAgICAgc2NvcGU6IFwib3BlbmlkXCIsXG4gICAgICBza2lwVXNlckluZm86IHRydWUsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV4dHJhSGVhZGVycyA9IHt9O1xuICAgICAgY29uc3Qgc2lnbmluUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQucHJvY2Vzc1NpZ25pblJlc3BvbnNlKG5hdlJlc3BvbnNlLnVybCwgZXh0cmFIZWFkZXJzKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlc3BvbnNlXCIpO1xuICAgICAgaWYgKHNpZ25pblJlc3BvbnNlLnNlc3Npb25fc3RhdGUgJiYgc2lnbmluUmVzcG9uc2UucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgbG9nZ2VyMi5pbmZvKFwic3VjY2VzcyBmb3Igc3ViamVjdFwiLCBzaWduaW5SZXNwb25zZS5wcm9maWxlLnN1Yik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2Vzc2lvbl9zdGF0ZTogc2lnbmluUmVzcG9uc2Uuc2Vzc2lvbl9zdGF0ZSxcbiAgICAgICAgICBzdWI6IHNpZ25pblJlc3BvbnNlLnByb2ZpbGUuc3ViXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsb2dnZXIyLmluZm8oXCJzdWNjZXNzLCB1c2VyIG5vdCBhdXRoZW50aWNhdGVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb25pdG9yQW5vbnltb3VzU2Vzc2lvbiAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvclJlc3BvbnNlKSB7XG4gICAgICAgIHN3aXRjaCAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgY2FzZSBcImxvZ2luX3JlcXVpcmVkXCI6XG4gICAgICAgICAgY2FzZSBcImNvbnNlbnRfcmVxdWlyZWRcIjpcbiAgICAgICAgICBjYXNlIFwiaW50ZXJhY3Rpb25fcmVxdWlyZWRcIjpcbiAgICAgICAgICBjYXNlIFwiYWNjb3VudF9zZWxlY3Rpb25fcmVxdWlyZWRcIjpcbiAgICAgICAgICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3MgZm9yIGFub255bW91cyB1c2VyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2Vzc2lvbl9zdGF0ZTogZXJyLnNlc3Npb25fc3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX3NpZ25pbihhcmdzLCBoYW5kbGUsIHZlcmlmeVN1Yikge1xuICAgIGNvbnN0IG5hdlJlc3BvbnNlID0gYXdhaXQgdGhpcy5fc2lnbmluU3RhcnQoYXJncywgaGFuZGxlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2lnbmluRW5kKG5hdlJlc3BvbnNlLnVybCwgdmVyaWZ5U3ViKTtcbiAgfVxuICBhc3luYyBfc2lnbmluU3RhcnQoYXJncywgaGFuZGxlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfc2lnbmluU3RhcnRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25pblJlcXVlc3QgPSBhd2FpdCB0aGlzLl9jbGllbnQuY3JlYXRlU2lnbmluUmVxdWVzdChhcmdzKTtcbiAgICAgIGxvZ2dlcjIuZGVidWcoXCJnb3Qgc2lnbmluIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlLm5hdmlnYXRlKHtcbiAgICAgICAgdXJsOiBzaWduaW5SZXF1ZXN0LnVybCxcbiAgICAgICAgc3RhdGU6IHNpZ25pblJlcXVlc3Quc3RhdGUuaWQsXG4gICAgICAgIHJlc3BvbnNlX21vZGU6IHNpZ25pblJlcXVlc3Quc3RhdGUucmVzcG9uc2VfbW9kZSxcbiAgICAgICAgc2NyaXB0T3JpZ2luOiB0aGlzLnNldHRpbmdzLmlmcmFtZVNjcmlwdE9yaWdpblxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiZXJyb3IgYWZ0ZXIgcHJlcGFyaW5nIG5hdmlnYXRvciwgY2xvc2luZyBuYXZpZ2F0b3Igd2luZG93XCIpO1xuICAgICAgaGFuZGxlLmNsb3NlKCk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9zaWduaW5FbmQodXJsLCB2ZXJpZnlTdWIpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWduaW5FbmRcIik7XG4gICAgY29uc3QgZXh0cmFIZWFkZXJzID0ge307XG4gICAgY29uc3Qgc2lnbmluUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jbGllbnQucHJvY2Vzc1NpZ25pblJlc3BvbnNlKHVybCwgZXh0cmFIZWFkZXJzKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHNpZ25pbiByZXNwb25zZVwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5fYnVpbGRVc2VyKHNpZ25pblJlc3BvbnNlLCB2ZXJpZnlTdWIpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIGFzeW5jIF9idWlsZFVzZXIoc2lnbmluUmVzcG9uc2UsIHZlcmlmeVN1Yikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2J1aWxkVXNlclwiKTtcbiAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIoc2lnbmluUmVzcG9uc2UpO1xuICAgIGlmICh2ZXJpZnlTdWIpIHtcbiAgICAgIGlmICh2ZXJpZnlTdWIgIT09IHVzZXIucHJvZmlsZS5zdWIpIHtcbiAgICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImN1cnJlbnQgdXNlciBkb2VzIG5vdCBtYXRjaCB1c2VyIHJldHVybmVkIGZyb20gc2lnbmluLiBzdWIgZnJvbSBzaWduaW46XCIsIHVzZXIucHJvZmlsZS5zdWIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZSh7IC4uLnNpZ25pblJlc3BvbnNlLCBlcnJvcjogXCJsb2dpbl9yZXF1aXJlZFwiIH0pO1xuICAgICAgfVxuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImN1cnJlbnQgdXNlciBtYXRjaGVzIHVzZXIgcmV0dXJuZWQgZnJvbSBzaWduaW5cIik7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuc3RvcmVVc2VyKHVzZXIpO1xuICAgIGxvZ2dlcjIuZGVidWcoXCJ1c2VyIHN0b3JlZFwiKTtcbiAgICBhd2FpdCB0aGlzLl9ldmVudHMubG9hZCh1c2VyKTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlciBhIHJlZGlyZWN0IG9mIHRoZSBjdXJyZW50IHdpbmRvdyB0byB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgc2lnbm91dFJlZGlyZWN0KGFyZ3MgPSB7fSkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFJlZGlyZWN0XCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZGlyZWN0TWV0aG9kLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9ID0gYXJncztcbiAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLl9yZWRpcmVjdE5hdmlnYXRvci5wcmVwYXJlKHsgcmVkaXJlY3RNZXRob2QgfSk7XG4gICAgYXdhaXQgdGhpcy5fc2lnbm91dFN0YXJ0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzbzpyXCIsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IHRoaXMuc2V0dGluZ3MucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpLFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludC5cbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHtAbGluayBVc2VyTWFuYWdlci5zaWdub3V0Q2FsbGJhY2t9IGluc3RlYWQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSBjb250YWluaW5nIHNpZ25vdXQgcmVzcG9uc2VcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbm91dENhbGxiYWNrfVxuICAgKi9cbiAgYXN5bmMgc2lnbm91dFJlZGlyZWN0Q2FsbGJhY2sodXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25vdXRSZWRpcmVjdENhbGxiYWNrXCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fc2lnbm91dEVuZCh1cmwpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgcmVkaXJlY3Qgb2YgYSBwb3B1cCB3aW5kb3cgdG8gdGhlIGVuZCBzZXNzaW9uIGVuZHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICovXG4gIGFzeW5jIHNpZ25vdXRQb3B1cChhcmdzID0ge30pIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInNpZ25vdXRQb3B1cFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBwb3B1cFdpbmRvd0ZlYXR1cmVzLFxuICAgICAgcG9wdXBXaW5kb3dUYXJnZXQsXG4gICAgICBwb3B1cFNpZ25hbCxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5fcG9wdXBOYXZpZ2F0b3IucHJlcGFyZSh7IHBvcHVwV2luZG93RmVhdHVyZXMsIHBvcHVwV2luZG93VGFyZ2V0LCBwb3B1cFNpZ25hbCB9KTtcbiAgICBhd2FpdCB0aGlzLl9zaWdub3V0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzbzpwXCIsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIC8vIHdlJ3JlIHB1dHRpbmcgYSBkdW1teSBlbnRyeSBpbiBoZXJlIGJlY2F1c2Ugd2VcbiAgICAgIC8vIG5lZWQgYSB1bmlxdWUgaWQgZnJvbSB0aGUgc3RhdGUgZm9yIG5vdGlmaWNhdGlvblxuICAgICAgLy8gdG8gdGhlIHBhcmVudCB3aW5kb3csIHdoaWNoIGlzIG5lY2Vzc2FyeSBpZiB3ZVxuICAgICAgLy8gcGxhbiB0byByZXR1cm4gYmFjayB0byB0aGUgY2xpZW50IGFmdGVyIHNpZ25vdXRcbiAgICAgIC8vIGFuZCBzbyB3ZSBjYW4gY2xvc2UgdGhlIHBvcHVwIGFmdGVyIHNpZ25vdXRcbiAgICAgIHN0YXRlOiB1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHt9LFxuICAgICAgLi4ucmVxdWVzdEFyZ3NcbiAgICB9LCBoYW5kbGUpO1xuICAgIGxvZ2dlcjIuaW5mbyhcInN1Y2Nlc3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcmVzcG9uc2UgKGNhbGxiYWNrKSBmcm9tIHRoZSBlbmQgc2Vzc2lvbiBlbmRwb2ludCBmcm9tIGEgcG9wdXAgd2luZG93LlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Uge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25vdXRDYWxsYmFja30gaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwcm9taXNlXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIFVzZXJNYW5hZ2VyLnNpZ25vdXRDYWxsYmFja31cbiAgICovXG4gIGFzeW5jIHNpZ25vdXRQb3B1cENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBrZWVwT3BlbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWdub3V0UG9wdXBDYWxsYmFja1wiKTtcbiAgICBhd2FpdCB0aGlzLl9wb3B1cE5hdmlnYXRvci5jYWxsYmFjayh1cmwsIHsga2VlcE9wZW4gfSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICBhc3luYyBfc2lnbm91dChhcmdzLCBoYW5kbGUpIHtcbiAgICBjb25zdCBuYXZSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3NpZ25vdXRTdGFydChhcmdzLCBoYW5kbGUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWdub3V0RW5kKG5hdlJlc3BvbnNlLnVybCk7XG4gIH1cbiAgYXN5bmMgX3NpZ25vdXRTdGFydChhcmdzID0ge30sIGhhbmRsZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWdub3V0U3RhcnRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImxvYWRlZCBjdXJyZW50IHVzZXIgZnJvbSBzdG9yYWdlXCIpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmV2b2tlVG9rZW5zT25TaWdub3V0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3Jldm9rZUludGVybmFsKHVzZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaWRfdG9rZW4gPSBhcmdzLmlkX3Rva2VuX2hpbnQgfHwgdXNlciAmJiB1c2VyLmlkX3Rva2VuO1xuICAgICAgaWYgKGlkX3Rva2VuKSB7XG4gICAgICAgIGxvZ2dlcjIuZGVidWcoXCJzZXR0aW5nIGlkX3Rva2VuX2hpbnQgaW4gc2lnbm91dCByZXF1ZXN0XCIpO1xuICAgICAgICBhcmdzLmlkX3Rva2VuX2hpbnQgPSBpZF90b2tlbjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMucmVtb3ZlVXNlcigpO1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgcmVtb3ZlZCwgY3JlYXRpbmcgc2lnbm91dCByZXF1ZXN0XCIpO1xuICAgICAgY29uc3Qgc2lnbm91dFJlcXVlc3QgPSBhd2FpdCB0aGlzLl9jbGllbnQuY3JlYXRlU2lnbm91dFJlcXVlc3QoYXJncyk7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwiZ290IHNpZ25vdXQgcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGUubmF2aWdhdGUoe1xuICAgICAgICB1cmw6IHNpZ25vdXRSZXF1ZXN0LnVybCxcbiAgICAgICAgc3RhdGU6IChfYSA9IHNpZ25vdXRSZXF1ZXN0LnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaWQsXG4gICAgICAgIHNjcmlwdE9yaWdpbjogdGhpcy5zZXR0aW5ncy5pZnJhbWVTY3JpcHRPcmlnaW5cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcImVycm9yIGFmdGVyIHByZXBhcmluZyBuYXZpZ2F0b3IsIGNsb3NpbmcgbmF2aWdhdG9yIHdpbmRvd1wiKTtcbiAgICAgIGhhbmRsZS5jbG9zZSgpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBhc3luYyBfc2lnbm91dEVuZCh1cmwpIHtcbiAgICBjb25zdCBsb2dnZXIyID0gdGhpcy5fbG9nZ2VyLmNyZWF0ZShcIl9zaWdub3V0RW5kXCIpO1xuICAgIGNvbnN0IHNpZ25vdXRSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NsaWVudC5wcm9jZXNzU2lnbm91dFJlc3BvbnNlKHVybCk7XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcImdvdCBzaWdub3V0IHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiBzaWdub3V0UmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBzaWxlbnQgcmVxdWVzdCAodmlhIGFuIGlmcmFtZSkgdG8gdGhlIGVuZCBzZXNzaW9uIGVuZHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICovXG4gIGFzeW5jIHNpZ25vdXRTaWxlbnQoYXJncyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic2lnbm91dFNpbGVudFwiKTtcbiAgICBjb25zdCB7XG4gICAgICBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyxcbiAgICAgIC4uLnJlcXVlc3RBcmdzXG4gICAgfSA9IGFyZ3M7XG4gICAgY29uc3QgaWRfdG9rZW5faGludCA9IHRoaXMuc2V0dGluZ3MuaW5jbHVkZUlkVG9rZW5JblNpbGVudFNpZ25vdXQgPyAoX2EgPSBhd2FpdCB0aGlzLl9sb2FkVXNlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaWRfdG9rZW4gOiB2b2lkIDA7XG4gICAgY29uc3QgdXJsID0gdGhpcy5zZXR0aW5ncy5wb3B1cF9wb3N0X2xvZ291dF9yZWRpcmVjdF91cmk7XG4gICAgY29uc3QgaGFuZGxlID0gYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLnByZXBhcmUoeyBzaWxlbnRSZXF1ZXN0VGltZW91dEluU2Vjb25kcyB9KTtcbiAgICBhd2FpdCB0aGlzLl9zaWdub3V0KHtcbiAgICAgIHJlcXVlc3RfdHlwZTogXCJzbzpzXCIsXG4gICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk6IHVybCxcbiAgICAgIGlkX3Rva2VuX2hpbnQsXG4gICAgICAuLi5yZXF1ZXN0QXJnc1xuICAgIH0sIGhhbmRsZSk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICAvKipcbiAgICogTm90aWZ5IHRoZSBwYXJlbnQgd2luZG93IG9mIHJlc3BvbnNlIChjYWxsYmFjaykgZnJvbSB0aGUgZW5kIHNlc3Npb24gZW5kcG9pbnQuXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbm91dENhbGxiYWNrfSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2VcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVXNlck1hbmFnZXIuc2lnbm91dENhbGxiYWNrfVxuICAgKi9cbiAgYXN5bmMgc2lnbm91dFNpbGVudENhbGxiYWNrKHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJzaWdub3V0U2lsZW50Q2FsbGJhY2tcIik7XG4gICAgYXdhaXQgdGhpcy5faWZyYW1lTmF2aWdhdG9yLmNhbGxiYWNrKHVybCk7XG4gICAgbG9nZ2VyMi5pbmZvKFwic3VjY2Vzc1wiKTtcbiAgfVxuICBhc3luYyByZXZva2VUb2tlbnModHlwZXMpIHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5fbG9hZFVzZXIoKTtcbiAgICBhd2FpdCB0aGlzLl9yZXZva2VJbnRlcm5hbCh1c2VyLCB0eXBlcyk7XG4gIH1cbiAgYXN5bmMgX3Jldm9rZUludGVybmFsKHVzZXIsIHR5cGVzID0gdGhpcy5zZXR0aW5ncy5yZXZva2VUb2tlblR5cGVzKSB7XG4gICAgY29uc3QgbG9nZ2VyMiA9IHRoaXMuX2xvZ2dlci5jcmVhdGUoXCJfcmV2b2tlSW50ZXJuYWxcIik7XG4gICAgaWYgKCF1c2VyKSByZXR1cm47XG4gICAgY29uc3QgdHlwZXNQcmVzZW50ID0gdHlwZXMuZmlsdGVyKCh0eXBlKSA9PiB0eXBlb2YgdXNlclt0eXBlXSA9PT0gXCJzdHJpbmdcIik7XG4gICAgaWYgKCF0eXBlc1ByZXNlbnQubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwibm8gbmVlZCB0byByZXZva2UgZHVlIHRvIG5vIHRva2VuKHMpXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXNQcmVzZW50KSB7XG4gICAgICBhd2FpdCB0aGlzLl9jbGllbnQucmV2b2tlVG9rZW4oXG4gICAgICAgIHVzZXJbdHlwZV0sXG4gICAgICAgIHR5cGVcbiAgICAgICk7XG4gICAgICBsb2dnZXIyLmluZm8oYCR7dHlwZX0gcmV2b2tlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgIGlmICh0eXBlICE9PSBcImFjY2Vzc190b2tlblwiKSB7XG4gICAgICAgIHVzZXJbdHlwZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0b3JlVXNlcih1c2VyKTtcbiAgICBsb2dnZXIyLmRlYnVnKFwidXNlciBzdG9yZWRcIik7XG4gICAgYXdhaXQgdGhpcy5fZXZlbnRzLmxvYWQodXNlcik7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgc2lsZW50IHJlbmV3IGZvciB0aGUgYFVzZXJNYW5hZ2VyYC5cbiAgICovXG4gIHN0YXJ0U2lsZW50UmVuZXcoKSB7XG4gICAgdGhpcy5fbG9nZ2VyLmNyZWF0ZShcInN0YXJ0U2lsZW50UmVuZXdcIik7XG4gICAgdm9pZCB0aGlzLl9zaWxlbnRSZW5ld1NlcnZpY2Uuc3RhcnQoKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgc2lsZW50IHJlbmV3IGZvciB0aGUgYFVzZXJNYW5hZ2VyYC5cbiAgICovXG4gIHN0b3BTaWxlbnRSZW5ldygpIHtcbiAgICB0aGlzLl9zaWxlbnRSZW5ld1NlcnZpY2Uuc3RvcCgpO1xuICB9XG4gIGdldCBfdXNlclN0b3JlS2V5KCkge1xuICAgIHJldHVybiBgdXNlcjoke3RoaXMuc2V0dGluZ3MuYXV0aG9yaXR5fToke3RoaXMuc2V0dGluZ3MuY2xpZW50X2lkfWA7XG4gIH1cbiAgYXN5bmMgX2xvYWRVc2VyKCkge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwiX2xvYWRVc2VyXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2VTdHJpbmcgPSBhd2FpdCB0aGlzLnNldHRpbmdzLnVzZXJTdG9yZS5nZXQodGhpcy5fdXNlclN0b3JlS2V5KTtcbiAgICBpZiAoc3RvcmFnZVN0cmluZykge1xuICAgICAgbG9nZ2VyMi5kZWJ1ZyhcInVzZXIgc3RvcmFnZVN0cmluZyBsb2FkZWRcIik7XG4gICAgICByZXR1cm4gVXNlci5mcm9tU3RvcmFnZVN0cmluZyhzdG9yYWdlU3RyaW5nKTtcbiAgICB9XG4gICAgbG9nZ2VyMi5kZWJ1ZyhcIm5vIHVzZXIgc3RvcmFnZVN0cmluZ1wiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBzdG9yZVVzZXIodXNlcikge1xuICAgIGNvbnN0IGxvZ2dlcjIgPSB0aGlzLl9sb2dnZXIuY3JlYXRlKFwic3RvcmVVc2VyXCIpO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICBsb2dnZXIyLmRlYnVnKFwic3RvcmluZyB1c2VyXCIpO1xuICAgICAgY29uc3Qgc3RvcmFnZVN0cmluZyA9IHVzZXIudG9TdG9yYWdlU3RyaW5nKCk7XG4gICAgICBhd2FpdCB0aGlzLnNldHRpbmdzLnVzZXJTdG9yZS5zZXQodGhpcy5fdXNlclN0b3JlS2V5LCBzdG9yYWdlU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKFwicmVtb3ZpbmcgdXNlclwiKTtcbiAgICAgIGF3YWl0IHRoaXMuc2V0dGluZ3MudXNlclN0b3JlLnJlbW92ZSh0aGlzLl91c2VyU3RvcmVLZXkpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZHBvcCkge1xuICAgICAgICBhd2FpdCB0aGlzLnNldHRpbmdzLmRwb3Auc3RvcmUucmVtb3ZlKHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3RhbGUgc3RhdGUgZW50cmllcyBpbiBzdG9yYWdlIGZvciBpbmNvbXBsZXRlIGF1dGhvcml6ZSByZXF1ZXN0cy5cbiAgICovXG4gIGFzeW5jIGNsZWFyU3RhbGVTdGF0ZSgpIHtcbiAgICBhd2FpdCB0aGlzLl9jbGllbnQuY2xlYXJTdGFsZVN0YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIER5bmFtaWNhbGx5IGdlbmVyYXRlcyBhIERQb1AgcHJvb2YgZm9yIGEgZ2l2ZW4gdXNlciwgVVJMIGFuZCBvcHRpb25hbCBIdHRwIG1ldGhvZC5cbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gbWFrZSBhIHJlcXVlc3QgdG8gYSByZXNvdXJjZSBzZXJ2ZXJcbiAgICogd2l0aCBmZXRjaCBvciBzaW1pbGFyLCBhbmQgeW91IG5lZWQgdG8gaW5jbHVkZSBhIERQb1AgcHJvb2YgaW4gYSBEUG9QIGhlYWRlci5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gZ2VuZXJhdGUgdGhlIERQb1AgcHJvb2YgZm9yXG4gICAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIgdG8gZ2VuZXJhdGUgdGhlIERQb1AgcHJvb2YgZm9yXG4gICAqIEBwYXJhbSBodHRwTWV0aG9kIC0gT3B0aW9uYWwsIGRlZmF1bHRzIHRvIFwiR0VUXCJcbiAgICogQHBhcmFtIG5vbmNlIC0gT3B0aW9uYWwgbm9uY2UgcHJvdmlkZWQgYnkgdGhlIHJlc291cmNlIHNlcnZlclxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgY29udGFpbmluZyB0aGUgRFBvUCBwcm9vZiBvciB1bmRlZmluZWQgaWYgRFBvUCBpcyBub3QgZW5hYmxlZC9ubyB1c2VyIGlzIGZvdW5kLlxuICAgKi9cbiAgYXN5bmMgZHBvcFByb29mKHVybCwgdXNlciwgaHR0cE1ldGhvZCwgbm9uY2UpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRwb3BTdGF0ZSA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnNldHRpbmdzLmRwb3ApID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdG9yZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmdldCh0aGlzLnNldHRpbmdzLmNsaWVudF9pZCkpO1xuICAgIGlmIChkcG9wU3RhdGUpIHtcbiAgICAgIHJldHVybiBhd2FpdCBDcnlwdG9VdGlscy5nZW5lcmF0ZURQb1BQcm9vZih7XG4gICAgICAgIHVybCxcbiAgICAgICAgYWNjZXNzVG9rZW46IHVzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZXIuYWNjZXNzX3Rva2VuLFxuICAgICAgICBodHRwTWV0aG9kLFxuICAgICAgICBrZXlQYWlyOiBkcG9wU3RhdGUua2V5cyxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGdlbmVyYXRlRFBvUEprdChkcG9wU2V0dGluZ3MpIHtcbiAgICBsZXQgZHBvcFN0YXRlID0gYXdhaXQgZHBvcFNldHRpbmdzLnN0b3JlLmdldCh0aGlzLnNldHRpbmdzLmNsaWVudF9pZCk7XG4gICAgaWYgKCFkcG9wU3RhdGUpIHtcbiAgICAgIGNvbnN0IGRwb3BLZXlzID0gYXdhaXQgQ3J5cHRvVXRpbHMuZ2VuZXJhdGVEUG9QS2V5cygpO1xuICAgICAgZHBvcFN0YXRlID0gbmV3IERQb1BTdGF0ZShkcG9wS2V5cyk7XG4gICAgICBhd2FpdCBkcG9wU2V0dGluZ3Muc3RvcmUuc2V0KHRoaXMuc2V0dGluZ3MuY2xpZW50X2lkLCBkcG9wU3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgQ3J5cHRvVXRpbHMuZ2VuZXJhdGVEUG9QSmt0KGRwb3BTdGF0ZS5rZXlzKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgdmVyc2lvbiA9IFwiMy4yLjFcIjtcblxuLy8gc3JjL1ZlcnNpb24udHNcbnZhciBWZXJzaW9uID0gdmVyc2lvbjtcblxuLy8gc3JjL0luZGV4ZWREYkRQb1BTdG9yZS50c1xudmFyIEluZGV4ZWREYkRQb1BTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGJOYW1lID0gXCJvaWRjXCI7XG4gICAgdGhpcy5fc3RvcmVOYW1lID0gXCJkcG9wXCI7XG4gIH1cbiAgYXN5bmMgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuY3JlYXRlU3RvcmUodGhpcy5fZGJOYW1lLCB0aGlzLl9zdG9yZU5hbWUpO1xuICAgIGF3YWl0IHN0b3JlKFwicmVhZHdyaXRlXCIsIChzdHIpID0+IHtcbiAgICAgIHN0ci5wdXQodmFsdWUsIGtleSk7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNpZnlSZXF1ZXN0KHN0ci50cmFuc2FjdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0KGtleSkge1xuICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5jcmVhdGVTdG9yZSh0aGlzLl9kYk5hbWUsIHRoaXMuX3N0b3JlTmFtZSk7XG4gICAgcmV0dXJuIGF3YWl0IHN0b3JlKFwicmVhZG9ubHlcIiwgKHN0cikgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzaWZ5UmVxdWVzdChzdHIuZ2V0KGtleSkpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJlbW92ZShrZXkpIHtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IHRoaXMuY3JlYXRlU3RvcmUodGhpcy5fZGJOYW1lLCB0aGlzLl9zdG9yZU5hbWUpO1xuICAgIGF3YWl0IHN0b3JlKFwicmVhZHdyaXRlXCIsIChzdHIpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnByb21pc2lmeVJlcXVlc3Qoc3RyLmRlbGV0ZShrZXkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICBhc3luYyBnZXRBbGxLZXlzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgdGhpcy5jcmVhdGVTdG9yZSh0aGlzLl9kYk5hbWUsIHRoaXMuX3N0b3JlTmFtZSk7XG4gICAgcmV0dXJuIGF3YWl0IHN0b3JlKFwicmVhZG9ubHlcIiwgKHN0cikgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzaWZ5UmVxdWVzdChzdHIuZ2V0QWxsS2V5cygpKTtcbiAgICB9KTtcbiAgfVxuICBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5vbmNvbXBsZXRlID0gcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBjcmVhdGVTdG9yZShkYk5hbWUsIHN0b3JlTmFtZSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihkYk5hbWUpO1xuICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4gcmVxdWVzdC5yZXN1bHQuY3JlYXRlT2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMucHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KTtcbiAgICByZXR1cm4gYXN5bmMgKHR4TW9kZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCB0eE1vZGUpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0eC5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKHN0b3JlKTtcbiAgICB9O1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQWNjZXNzVG9rZW5FdmVudHMsXG4gIENoZWNrU2Vzc2lvbklGcmFtZSxcbiAgRFBvUFN0YXRlLFxuICBFcnJvclJlc3BvbnNlLFxuICBFcnJvclRpbWVvdXQsXG4gIEluTWVtb3J5V2ViU3RvcmFnZSxcbiAgSW5kZXhlZERiRFBvUFN0b3JlLFxuICBMb2csXG4gIExvZ2dlcixcbiAgTWV0YWRhdGFTZXJ2aWNlLFxuICBPaWRjQ2xpZW50LFxuICBPaWRjQ2xpZW50U2V0dGluZ3NTdG9yZSxcbiAgU2Vzc2lvbk1vbml0b3IsXG4gIFNpZ25pblJlc3BvbnNlLFxuICBTaWduaW5TdGF0ZSxcbiAgU2lnbm91dFJlc3BvbnNlLFxuICBTdGF0ZSxcbiAgVXNlcixcbiAgVXNlck1hbmFnZXIsXG4gIFVzZXJNYW5hZ2VyU2V0dGluZ3NTdG9yZSxcbiAgVmVyc2lvbixcbiAgV2ViU3RvcmFnZVN0YXRlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vaWRjLWNsaWVudC10cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react-oidc-context/dist/esm/react-oidc-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-oidc-context/dist/esm/react-oidc-context.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthContext: () => (/* binding */ AuthContext),\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   hasAuthParams: () => (/* binding */ hasAuthParams),\n/* harmony export */   useAuth: () => (/* binding */ useAuth),\n/* harmony export */   useAutoSignin: () => (/* binding */ useAutoSignin),\n/* harmony export */   withAuth: () => (/* binding */ withAuth),\n/* harmony export */   withAuthenticationRequired: () => (/* binding */ withAuthenticationRequired)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var oidc_client_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! oidc-client-ts */ \"(pages-dir-browser)/./node_modules/oidc-client-ts/dist/esm/oidc-client-ts.js\");\n// src/AuthContext.ts\n\nvar AuthContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nAuthContext.displayName = \"AuthContext\";\n\n// src/AuthProvider.tsx\n\n\n\n// src/AuthState.ts\nvar initialAuthState = {\n  isLoading: true,\n  isAuthenticated: false\n};\n\n// src/reducer.ts\nvar reducer = (state, action) => {\n  switch (action.type) {\n    case \"INITIALISED\":\n    case \"USER_LOADED\":\n      return {\n        ...state,\n        user: action.user,\n        isLoading: false,\n        isAuthenticated: action.user ? !action.user.expired : false,\n        error: void 0\n      };\n    case \"USER_SIGNED_OUT\":\n    case \"USER_UNLOADED\":\n      return {\n        ...state,\n        user: void 0,\n        isAuthenticated: false\n      };\n    case \"NAVIGATOR_INIT\":\n      return {\n        ...state,\n        isLoading: true,\n        activeNavigator: action.method\n      };\n    case \"NAVIGATOR_CLOSE\":\n      return {\n        ...state,\n        isLoading: false,\n        activeNavigator: void 0\n      };\n    case \"ERROR\": {\n      const error = action.error;\n      error[\"toString\"] = () => `${error.name}: ${error.message}`;\n      return {\n        ...state,\n        isLoading: false,\n        error\n      };\n    }\n    default: {\n      const innerError = new TypeError(`unknown type ${action[\"type\"]}`);\n      const error = {\n        name: innerError.name,\n        message: innerError.message,\n        innerError,\n        stack: innerError.stack,\n        source: \"unknown\"\n      };\n      error[\"toString\"] = () => `${error.name}: ${error.message}`;\n      return {\n        ...state,\n        isLoading: false,\n        error\n      };\n    }\n  }\n};\n\n// src/utils.ts\nvar hasAuthParams = (location = window.location) => {\n  let searchParams = new URLSearchParams(location.search);\n  if ((searchParams.get(\"code\") || searchParams.get(\"error\")) && searchParams.get(\"state\")) {\n    return true;\n  }\n  searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\n  if ((searchParams.get(\"code\") || searchParams.get(\"error\")) && searchParams.get(\"state\")) {\n    return true;\n  }\n  return false;\n};\nvar signinError = normalizeErrorFn(\"signinCallback\", \"Sign-in failed\");\nvar signoutError = normalizeErrorFn(\"signoutCallback\", \"Sign-out failed\");\nvar renewSilentError = normalizeErrorFn(\"renewSilent\", \"Renew silent failed\");\nfunction normalizeError(error, fallbackMessage) {\n  return {\n    name: stringFieldOf(error, \"name\", () => \"Error\"),\n    message: stringFieldOf(error, \"message\", () => fallbackMessage),\n    stack: stringFieldOf(error, \"stack\", () => new Error().stack),\n    innerError: error\n  };\n}\nfunction normalizeErrorFn(source, fallbackMessage) {\n  return (error) => {\n    return {\n      ...normalizeError(error, fallbackMessage),\n      source\n    };\n  };\n}\nfunction stringFieldOf(element, fieldName, or) {\n  if (element && typeof element === \"object\") {\n    const value = element[fieldName];\n    if (typeof value === \"string\") {\n      return value;\n    }\n  }\n  return or();\n}\n\n// src/AuthProvider.tsx\nvar userManagerContextKeys = [\n  \"clearStaleState\",\n  \"querySessionStatus\",\n  \"revokeTokens\",\n  \"startSilentRenew\",\n  \"stopSilentRenew\"\n];\nvar navigatorKeys = [\n  \"signinPopup\",\n  \"signinSilent\",\n  \"signinRedirect\",\n  \"signinResourceOwnerCredentials\",\n  \"signoutPopup\",\n  \"signoutRedirect\",\n  \"signoutSilent\"\n];\nvar unsupportedEnvironment = (fnName) => () => {\n  throw new Error(\n    `UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`\n  );\n};\nvar UserManagerImpl = typeof window === \"undefined\" ? null : oidc_client_ts__WEBPACK_IMPORTED_MODULE_1__.UserManager;\nvar AuthProvider = (props) => {\n  const {\n    children,\n    onSigninCallback,\n    skipSigninCallback,\n    matchSignoutCallback,\n    onSignoutCallback,\n    onRemoveUser,\n    userManager: userManagerProp = null,\n    ...userManagerSettings\n  } = props;\n  const [userManager] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {\n    return userManagerProp != null ? userManagerProp : UserManagerImpl ? new UserManagerImpl(userManagerSettings) : { settings: userManagerSettings };\n  });\n  const [state, dispatch] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(reducer, initialAuthState);\n  const userManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    () => Object.assign(\n      {\n        settings: userManager.settings,\n        events: userManager.events\n      },\n      Object.fromEntries(\n        userManagerContextKeys.map((key) => {\n          var _a, _b;\n          return [\n            key,\n            (_b = (_a = userManager[key]) == null ? void 0 : _a.bind(userManager)) != null ? _b : unsupportedEnvironment(key)\n          ];\n        })\n      ),\n      Object.fromEntries(\n        navigatorKeys.map((key) => [\n          key,\n          userManager[key] ? async (args) => {\n            dispatch({\n              type: \"NAVIGATOR_INIT\",\n              method: key\n            });\n            try {\n              return await userManager[key](args);\n            } catch (error) {\n              dispatch({\n                type: \"ERROR\",\n                error: {\n                  ...normalizeError(error, `Unknown error while executing ${key}(...).`),\n                  source: key,\n                  args\n                }\n              });\n              return null;\n            } finally {\n              dispatch({ type: \"NAVIGATOR_CLOSE\" });\n            }\n          } : unsupportedEnvironment(key)\n        ])\n      )\n    ),\n    [userManager]\n  );\n  const didInitialize = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!userManager || didInitialize.current) {\n      return;\n    }\n    didInitialize.current = true;\n    void (async () => {\n      try {\n        let user = null;\n        if (hasAuthParams() && !skipSigninCallback) {\n          user = await userManager.signinCallback();\n          if (onSigninCallback) await onSigninCallback(user);\n        }\n        user = !user ? await userManager.getUser() : user;\n        dispatch({ type: \"INITIALISED\", user });\n      } catch (error) {\n        dispatch({\n          type: \"ERROR\",\n          error: signinError(error)\n        });\n      }\n      try {\n        if (matchSignoutCallback && matchSignoutCallback(userManager.settings)) {\n          const resp = await userManager.signoutCallback();\n          if (onSignoutCallback) await onSignoutCallback(resp);\n        }\n      } catch (error) {\n        dispatch({\n          type: \"ERROR\",\n          error: signoutError(error)\n        });\n      }\n    })();\n  }, [userManager, skipSigninCallback, onSigninCallback, onSignoutCallback, matchSignoutCallback]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!userManager) return void 0;\n    const handleUserLoaded = (user) => {\n      dispatch({ type: \"USER_LOADED\", user });\n    };\n    userManager.events.addUserLoaded(handleUserLoaded);\n    const handleUserUnloaded = () => {\n      dispatch({ type: \"USER_UNLOADED\" });\n    };\n    userManager.events.addUserUnloaded(handleUserUnloaded);\n    const handleUserSignedOut = () => {\n      dispatch({ type: \"USER_SIGNED_OUT\" });\n    };\n    userManager.events.addUserSignedOut(handleUserSignedOut);\n    const handleSilentRenewError = (error) => {\n      dispatch({\n        type: \"ERROR\",\n        error: renewSilentError(error)\n      });\n    };\n    userManager.events.addSilentRenewError(handleSilentRenewError);\n    return () => {\n      userManager.events.removeUserLoaded(handleUserLoaded);\n      userManager.events.removeUserUnloaded(handleUserUnloaded);\n      userManager.events.removeUserSignedOut(handleUserSignedOut);\n      userManager.events.removeSilentRenewError(handleSilentRenewError);\n    };\n  }, [userManager]);\n  const removeUser = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {\n    if (!userManager) unsupportedEnvironment(\"removeUser\");\n    await userManager.removeUser();\n    if (onRemoveUser) await onRemoveUser();\n  }, [userManager, onRemoveUser]);\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      ...state,\n      ...userManagerContext,\n      removeUser\n    };\n  }, [state, userManagerContext, removeUser]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthContext.Provider, { value: contextValue }, children);\n};\n\n// src/useAuth.ts\n\nvar useAuth = () => {\n  const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AuthContext);\n  if (!context) {\n    console.warn(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\n  }\n  return context;\n};\n\n// src/useAutoSignin.ts\n\nvar useAutoSignin = ({ signinMethod = \"signinRedirect\" } = {}) => {\n  const auth = useAuth();\n  const [hasTriedSignin, setHasTriedSignin] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  const shouldAttemptSignin = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => !hasAuthParams() && !auth.isAuthenticated && !auth.activeNavigator && !auth.isLoading && !hasTriedSignin, [auth.activeNavigator, auth.isAuthenticated, auth.isLoading, hasTriedSignin]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (shouldAttemptSignin) {\n      switch (signinMethod) {\n        case \"signinPopup\":\n          void auth.signinPopup();\n          break;\n        case \"signinRedirect\":\n        default:\n          void auth.signinRedirect();\n          break;\n      }\n      setHasTriedSignin(true);\n    }\n  }, [auth, hasTriedSignin, shouldAttemptSignin, signinMethod]);\n  return {\n    isLoading: auth.isLoading,\n    isAuthenticated: auth.isAuthenticated,\n    error: auth.error\n  };\n};\n\n// src/withAuth.tsx\n\nfunction withAuth(Component) {\n  const displayName = `withAuth(${Component.displayName || Component.name})`;\n  const C = (props) => {\n    const auth = useAuth();\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, { ...props, auth });\n  };\n  C.displayName = displayName;\n  return C;\n}\n\n// src/withAuthenticationRequired.tsx\n\nvar withAuthenticationRequired = (Component, options = {}) => {\n  const { OnRedirecting = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null), onBeforeSignin, signinRedirectArgs } = options;\n  const displayName = `withAuthenticationRequired(${Component.displayName || Component.name})`;\n  const C = (props) => {\n    const auth = useAuth();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n      if (hasAuthParams() || auth.isLoading || auth.activeNavigator || auth.isAuthenticated) {\n        return;\n      }\n      void (async () => {\n        if (onBeforeSignin) await onBeforeSignin();\n        await auth.signinRedirect(signinRedirectArgs);\n      })();\n    }, [auth.isLoading, auth.isAuthenticated, auth]);\n    return auth.isAuthenticated ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, { ...props }) : OnRedirecting();\n  };\n  C.displayName = displayName;\n  return C;\n};\n\n//# sourceMappingURL=react-oidc-context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1vaWRjLWNvbnRleHQvZGlzdC9lc20vcmVhY3Qtb2lkYy1jb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBCO0FBQzFCLGtCQUFrQixnREFBbUI7QUFDckM7O0FBRUE7QUFDNkM7QUFDbEI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsSUFBSSxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxJQUFJLGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSw2REFBNkQsdURBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0JBQXdCLDJDQUFlO0FBQ3ZDLHNIQUFzSDtBQUN0SCxHQUFHO0FBQ0gsNEJBQTRCLDZDQUFpQjtBQUM3Qyw2QkFBNkIsMENBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxJQUFJO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZCx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUNBQWE7QUFDckMsRUFBRSw0Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUUsNENBQWdCO0FBQ2xCO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsOENBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsMENBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsZ0RBQW9CLHlCQUF5QixxQkFBcUI7QUFDM0Y7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQSxrQkFBa0IsNkNBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0IsdUJBQXVCLGtDQUFrQyxJQUFJO0FBQzdEO0FBQ0EsOENBQThDLDJDQUFlO0FBQzdELDhCQUE4QiwwQ0FBYztBQUM1QyxFQUFFLDRDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0Esa0NBQWtDLHdDQUF3QztBQUMxRTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFvQixjQUFjLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQjtBQUMzQix5REFBeUQ7QUFDekQsVUFBVSxzQ0FBc0MsZ0RBQW9CLENBQUMsMkNBQWUsOENBQThDO0FBQ2xJLG9EQUFvRCx3Q0FBd0M7QUFDNUY7QUFDQTtBQUNBLElBQUksNENBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsa0RBQWtELGdEQUFvQixjQUFjLFVBQVU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFTRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvYmNvbm4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL2NvbX5hcHBsZX5DbG91ZERvY3MvUHJvamVjdHMvVm94UG9wX0FnZW50aWMvdm94cG9wYWkvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3JlYWN0LW9pZGMtY29udGV4dC9kaXN0L2VzbS9yZWFjdC1vaWRjLWNvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL0F1dGhDb250ZXh0LnRzXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgQXV0aENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5BdXRoQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXV0aENvbnRleHRcIjtcblxuLy8gc3JjL0F1dGhQcm92aWRlci50c3hcbmltcG9ydCB7IFVzZXJNYW5hZ2VyIH0gZnJvbSBcIm9pZGMtY2xpZW50LXRzXCI7XG5pbXBvcnQgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvQXV0aFN0YXRlLnRzXG52YXIgaW5pdGlhbEF1dGhTdGF0ZSA9IHtcbiAgaXNMb2FkaW5nOiB0cnVlLFxuICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlXG59O1xuXG4vLyBzcmMvcmVkdWNlci50c1xudmFyIHJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcIklOSVRJQUxJU0VEXCI6XG4gICAgY2FzZSBcIlVTRVJfTE9BREVEXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdXNlcjogYWN0aW9uLnVzZXIsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogYWN0aW9uLnVzZXIgPyAhYWN0aW9uLnVzZXIuZXhwaXJlZCA6IGZhbHNlLFxuICAgICAgICBlcnJvcjogdm9pZCAwXG4gICAgICB9O1xuICAgIGNhc2UgXCJVU0VSX1NJR05FRF9PVVRcIjpcbiAgICBjYXNlIFwiVVNFUl9VTkxPQURFRFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHVzZXI6IHZvaWQgMCxcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICBjYXNlIFwiTkFWSUdBVE9SX0lOSVRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgIGFjdGl2ZU5hdmlnYXRvcjogYWN0aW9uLm1ldGhvZFxuICAgICAgfTtcbiAgICBjYXNlIFwiTkFWSUdBVE9SX0NMT1NFXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgYWN0aXZlTmF2aWdhdG9yOiB2b2lkIDBcbiAgICAgIH07XG4gICAgY2FzZSBcIkVSUk9SXCI6IHtcbiAgICAgIGNvbnN0IGVycm9yID0gYWN0aW9uLmVycm9yO1xuICAgICAgZXJyb3JbXCJ0b1N0cmluZ1wiXSA9ICgpID0+IGAke2Vycm9yLm5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgaW5uZXJFcnJvciA9IG5ldyBUeXBlRXJyb3IoYHVua25vd24gdHlwZSAke2FjdGlvbltcInR5cGVcIl19YCk7XG4gICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgbmFtZTogaW5uZXJFcnJvci5uYW1lLFxuICAgICAgICBtZXNzYWdlOiBpbm5lckVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGlubmVyRXJyb3IsXG4gICAgICAgIHN0YWNrOiBpbm5lckVycm9yLnN0YWNrLFxuICAgICAgICBzb3VyY2U6IFwidW5rbm93blwiXG4gICAgICB9O1xuICAgICAgZXJyb3JbXCJ0b1N0cmluZ1wiXSA9ICgpID0+IGAke2Vycm9yLm5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIGhhc0F1dGhQYXJhbXMgPSAobG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24pID0+IHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKTtcbiAgaWYgKChzZWFyY2hQYXJhbXMuZ2V0KFwiY29kZVwiKSB8fCBzZWFyY2hQYXJhbXMuZ2V0KFwiZXJyb3JcIikpICYmIHNlYXJjaFBhcmFtcy5nZXQoXCJzdGF0ZVwiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uaGFzaC5yZXBsYWNlKFwiI1wiLCBcIj9cIikpO1xuICBpZiAoKHNlYXJjaFBhcmFtcy5nZXQoXCJjb2RlXCIpIHx8IHNlYXJjaFBhcmFtcy5nZXQoXCJlcnJvclwiKSkgJiYgc2VhcmNoUGFyYW1zLmdldChcInN0YXRlXCIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBzaWduaW5FcnJvciA9IG5vcm1hbGl6ZUVycm9yRm4oXCJzaWduaW5DYWxsYmFja1wiLCBcIlNpZ24taW4gZmFpbGVkXCIpO1xudmFyIHNpZ25vdXRFcnJvciA9IG5vcm1hbGl6ZUVycm9yRm4oXCJzaWdub3V0Q2FsbGJhY2tcIiwgXCJTaWduLW91dCBmYWlsZWRcIik7XG52YXIgcmVuZXdTaWxlbnRFcnJvciA9IG5vcm1hbGl6ZUVycm9yRm4oXCJyZW5ld1NpbGVudFwiLCBcIlJlbmV3IHNpbGVudCBmYWlsZWRcIik7XG5mdW5jdGlvbiBub3JtYWxpemVFcnJvcihlcnJvciwgZmFsbGJhY2tNZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogc3RyaW5nRmllbGRPZihlcnJvciwgXCJuYW1lXCIsICgpID0+IFwiRXJyb3JcIiksXG4gICAgbWVzc2FnZTogc3RyaW5nRmllbGRPZihlcnJvciwgXCJtZXNzYWdlXCIsICgpID0+IGZhbGxiYWNrTWVzc2FnZSksXG4gICAgc3RhY2s6IHN0cmluZ0ZpZWxkT2YoZXJyb3IsIFwic3RhY2tcIiwgKCkgPT4gbmV3IEVycm9yKCkuc3RhY2spLFxuICAgIGlubmVyRXJyb3I6IGVycm9yXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVFcnJvckZuKHNvdXJjZSwgZmFsbGJhY2tNZXNzYWdlKSB7XG4gIHJldHVybiAoZXJyb3IpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubm9ybWFsaXplRXJyb3IoZXJyb3IsIGZhbGxiYWNrTWVzc2FnZSksXG4gICAgICBzb3VyY2VcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gc3RyaW5nRmllbGRPZihlbGVtZW50LCBmaWVsZE5hbWUsIG9yKSB7XG4gIGlmIChlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgdmFsdWUgPSBlbGVtZW50W2ZpZWxkTmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3IoKTtcbn1cblxuLy8gc3JjL0F1dGhQcm92aWRlci50c3hcbnZhciB1c2VyTWFuYWdlckNvbnRleHRLZXlzID0gW1xuICBcImNsZWFyU3RhbGVTdGF0ZVwiLFxuICBcInF1ZXJ5U2Vzc2lvblN0YXR1c1wiLFxuICBcInJldm9rZVRva2Vuc1wiLFxuICBcInN0YXJ0U2lsZW50UmVuZXdcIixcbiAgXCJzdG9wU2lsZW50UmVuZXdcIlxuXTtcbnZhciBuYXZpZ2F0b3JLZXlzID0gW1xuICBcInNpZ25pblBvcHVwXCIsXG4gIFwic2lnbmluU2lsZW50XCIsXG4gIFwic2lnbmluUmVkaXJlY3RcIixcbiAgXCJzaWduaW5SZXNvdXJjZU93bmVyQ3JlZGVudGlhbHNcIixcbiAgXCJzaWdub3V0UG9wdXBcIixcbiAgXCJzaWdub3V0UmVkaXJlY3RcIixcbiAgXCJzaWdub3V0U2lsZW50XCJcbl07XG52YXIgdW5zdXBwb3J0ZWRFbnZpcm9ubWVudCA9IChmbk5hbWUpID0+ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBVc2VyTWFuYWdlciMke2ZuTmFtZX0gd2FzIGNhbGxlZCBmcm9tIGFuIHVuc3VwcG9ydGVkIGNvbnRleHQuIElmIHRoaXMgaXMgYSBzZXJ2ZXItcmVuZGVyZWQgcGFnZSwgZGVmZXIgdGhpcyBjYWxsIHdpdGggdXNlRWZmZWN0KCkgb3IgcGFzcyBhIGN1c3RvbSBVc2VyTWFuYWdlciBpbXBsZW1lbnRhdGlvbi5gXG4gICk7XG59O1xudmFyIFVzZXJNYW5hZ2VySW1wbCA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogVXNlck1hbmFnZXI7XG52YXIgQXV0aFByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBvblNpZ25pbkNhbGxiYWNrLFxuICAgIHNraXBTaWduaW5DYWxsYmFjayxcbiAgICBtYXRjaFNpZ25vdXRDYWxsYmFjayxcbiAgICBvblNpZ25vdXRDYWxsYmFjayxcbiAgICBvblJlbW92ZVVzZXIsXG4gICAgdXNlck1hbmFnZXI6IHVzZXJNYW5hZ2VyUHJvcCA9IG51bGwsXG4gICAgLi4udXNlck1hbmFnZXJTZXR0aW5nc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFt1c2VyTWFuYWdlcl0gPSBSZWFjdDIudXNlU3RhdGUoKCkgPT4ge1xuICAgIHJldHVybiB1c2VyTWFuYWdlclByb3AgIT0gbnVsbCA/IHVzZXJNYW5hZ2VyUHJvcCA6IFVzZXJNYW5hZ2VySW1wbCA/IG5ldyBVc2VyTWFuYWdlckltcGwodXNlck1hbmFnZXJTZXR0aW5ncykgOiB7IHNldHRpbmdzOiB1c2VyTWFuYWdlclNldHRpbmdzIH07XG4gIH0pO1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IFJlYWN0Mi51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBdXRoU3RhdGUpO1xuICBjb25zdCB1c2VyTWFuYWdlckNvbnRleHQgPSBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBzZXR0aW5nczogdXNlck1hbmFnZXIuc2V0dGluZ3MsXG4gICAgICAgIGV2ZW50czogdXNlck1hbmFnZXIuZXZlbnRzXG4gICAgICB9LFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICB1c2VyTWFuYWdlckNvbnRleHRLZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgKF9iID0gKF9hID0gdXNlck1hbmFnZXJba2V5XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJpbmQodXNlck1hbmFnZXIpKSAhPSBudWxsID8gX2IgOiB1bnN1cHBvcnRlZEVudmlyb25tZW50KGtleSlcbiAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgbmF2aWdhdG9yS2V5cy5tYXAoKGtleSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICB1c2VyTWFuYWdlcltrZXldID8gYXN5bmMgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJOQVZJR0FUT1JfSU5JVFwiLFxuICAgICAgICAgICAgICBtZXRob2Q6IGtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdXNlck1hbmFnZXJba2V5XShhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkVSUk9SXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgIC4uLm5vcm1hbGl6ZUVycm9yKGVycm9yLCBgVW5rbm93biBlcnJvciB3aGlsZSBleGVjdXRpbmcgJHtrZXl9KC4uLikuYCksXG4gICAgICAgICAgICAgICAgICBzb3VyY2U6IGtleSxcbiAgICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJOQVZJR0FUT1JfQ0xPU0VcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDogdW5zdXBwb3J0ZWRFbnZpcm9ubWVudChrZXkpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKSxcbiAgICBbdXNlck1hbmFnZXJdXG4gICk7XG4gIGNvbnN0IGRpZEluaXRpYWxpemUgPSBSZWFjdDIudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1c2VyTWFuYWdlciB8fCBkaWRJbml0aWFsaXplLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkSW5pdGlhbGl6ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICB2b2lkIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdXNlciA9IG51bGw7XG4gICAgICAgIGlmIChoYXNBdXRoUGFyYW1zKCkgJiYgIXNraXBTaWduaW5DYWxsYmFjaykge1xuICAgICAgICAgIHVzZXIgPSBhd2FpdCB1c2VyTWFuYWdlci5zaWduaW5DYWxsYmFjaygpO1xuICAgICAgICAgIGlmIChvblNpZ25pbkNhbGxiYWNrKSBhd2FpdCBvblNpZ25pbkNhbGxiYWNrKHVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHVzZXIgPSAhdXNlciA/IGF3YWl0IHVzZXJNYW5hZ2VyLmdldFVzZXIoKSA6IHVzZXI7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJJTklUSUFMSVNFRFwiLCB1c2VyIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IFwiRVJST1JcIixcbiAgICAgICAgICBlcnJvcjogc2lnbmluRXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG1hdGNoU2lnbm91dENhbGxiYWNrICYmIG1hdGNoU2lnbm91dENhbGxiYWNrKHVzZXJNYW5hZ2VyLnNldHRpbmdzKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB1c2VyTWFuYWdlci5zaWdub3V0Q2FsbGJhY2soKTtcbiAgICAgICAgICBpZiAob25TaWdub3V0Q2FsbGJhY2spIGF3YWl0IG9uU2lnbm91dENhbGxiYWNrKHJlc3ApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogXCJFUlJPUlwiLFxuICAgICAgICAgIGVycm9yOiBzaWdub3V0RXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH0sIFt1c2VyTWFuYWdlciwgc2tpcFNpZ25pbkNhbGxiYWNrLCBvblNpZ25pbkNhbGxiYWNrLCBvblNpZ25vdXRDYWxsYmFjaywgbWF0Y2hTaWdub3V0Q2FsbGJhY2tdKTtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1c2VyTWFuYWdlcikgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBoYW5kbGVVc2VyTG9hZGVkID0gKHVzZXIpID0+IHtcbiAgICAgIGRpc3BhdGNoKHsgdHlwZTogXCJVU0VSX0xPQURFRFwiLCB1c2VyIH0pO1xuICAgIH07XG4gICAgdXNlck1hbmFnZXIuZXZlbnRzLmFkZFVzZXJMb2FkZWQoaGFuZGxlVXNlckxvYWRlZCk7XG4gICAgY29uc3QgaGFuZGxlVXNlclVubG9hZGVkID0gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIlVTRVJfVU5MT0FERURcIiB9KTtcbiAgICB9O1xuICAgIHVzZXJNYW5hZ2VyLmV2ZW50cy5hZGRVc2VyVW5sb2FkZWQoaGFuZGxlVXNlclVubG9hZGVkKTtcbiAgICBjb25zdCBoYW5kbGVVc2VyU2lnbmVkT3V0ID0gKCkgPT4ge1xuICAgICAgZGlzcGF0Y2goeyB0eXBlOiBcIlVTRVJfU0lHTkVEX09VVFwiIH0pO1xuICAgIH07XG4gICAgdXNlck1hbmFnZXIuZXZlbnRzLmFkZFVzZXJTaWduZWRPdXQoaGFuZGxlVXNlclNpZ25lZE91dCk7XG4gICAgY29uc3QgaGFuZGxlU2lsZW50UmVuZXdFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIkVSUk9SXCIsXG4gICAgICAgIGVycm9yOiByZW5ld1NpbGVudEVycm9yKGVycm9yKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB1c2VyTWFuYWdlci5ldmVudHMuYWRkU2lsZW50UmVuZXdFcnJvcihoYW5kbGVTaWxlbnRSZW5ld0Vycm9yKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdXNlck1hbmFnZXIuZXZlbnRzLnJlbW92ZVVzZXJMb2FkZWQoaGFuZGxlVXNlckxvYWRlZCk7XG4gICAgICB1c2VyTWFuYWdlci5ldmVudHMucmVtb3ZlVXNlclVubG9hZGVkKGhhbmRsZVVzZXJVbmxvYWRlZCk7XG4gICAgICB1c2VyTWFuYWdlci5ldmVudHMucmVtb3ZlVXNlclNpZ25lZE91dChoYW5kbGVVc2VyU2lnbmVkT3V0KTtcbiAgICAgIHVzZXJNYW5hZ2VyLmV2ZW50cy5yZW1vdmVTaWxlbnRSZW5ld0Vycm9yKGhhbmRsZVNpbGVudFJlbmV3RXJyb3IpO1xuICAgIH07XG4gIH0sIFt1c2VyTWFuYWdlcl0pO1xuICBjb25zdCByZW1vdmVVc2VyID0gUmVhY3QyLnVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXVzZXJNYW5hZ2VyKSB1bnN1cHBvcnRlZEVudmlyb25tZW50KFwicmVtb3ZlVXNlclwiKTtcbiAgICBhd2FpdCB1c2VyTWFuYWdlci5yZW1vdmVVc2VyKCk7XG4gICAgaWYgKG9uUmVtb3ZlVXNlcikgYXdhaXQgb25SZW1vdmVVc2VyKCk7XG4gIH0sIFt1c2VyTWFuYWdlciwgb25SZW1vdmVVc2VyXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0Mi51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi51c2VyTWFuYWdlckNvbnRleHQsXG4gICAgICByZW1vdmVVc2VyXG4gICAgfTtcbiAgfSwgW3N0YXRlLCB1c2VyTWFuYWdlckNvbnRleHQsIHJlbW92ZVVzZXJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChBdXRoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKTtcbn07XG5cbi8vIHNyYy91c2VBdXRoLnRzXG5pbXBvcnQgUmVhY3QzIGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUF1dGggPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdDMudXNlQ29udGV4dChBdXRoQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIGNvbnNvbGUud2FybihcIkF1dGhQcm92aWRlciBjb250ZXh0IGlzIHVuZGVmaW5lZCwgcGxlYXNlIHZlcmlmeSB5b3UgYXJlIGNhbGxpbmcgdXNlQXV0aCgpIGFzIGNoaWxkIG9mIGEgPEF1dGhQcm92aWRlcj4gY29tcG9uZW50LlwiKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8vIHNyYy91c2VBdXRvU2lnbmluLnRzXG5pbXBvcnQgUmVhY3Q0IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUF1dG9TaWduaW4gPSAoeyBzaWduaW5NZXRob2QgPSBcInNpZ25pblJlZGlyZWN0XCIgfSA9IHt9KSA9PiB7XG4gIGNvbnN0IGF1dGggPSB1c2VBdXRoKCk7XG4gIGNvbnN0IFtoYXNUcmllZFNpZ25pbiwgc2V0SGFzVHJpZWRTaWduaW5dID0gUmVhY3Q0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3Qgc2hvdWxkQXR0ZW1wdFNpZ25pbiA9IFJlYWN0NC51c2VNZW1vKCgpID0+ICFoYXNBdXRoUGFyYW1zKCkgJiYgIWF1dGguaXNBdXRoZW50aWNhdGVkICYmICFhdXRoLmFjdGl2ZU5hdmlnYXRvciAmJiAhYXV0aC5pc0xvYWRpbmcgJiYgIWhhc1RyaWVkU2lnbmluLCBbYXV0aC5hY3RpdmVOYXZpZ2F0b3IsIGF1dGguaXNBdXRoZW50aWNhdGVkLCBhdXRoLmlzTG9hZGluZywgaGFzVHJpZWRTaWduaW5dKTtcbiAgUmVhY3Q0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNob3VsZEF0dGVtcHRTaWduaW4pIHtcbiAgICAgIHN3aXRjaCAoc2lnbmluTWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJzaWduaW5Qb3B1cFwiOlxuICAgICAgICAgIHZvaWQgYXV0aC5zaWduaW5Qb3B1cCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2lnbmluUmVkaXJlY3RcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2b2lkIGF1dGguc2lnbmluUmVkaXJlY3QoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNldEhhc1RyaWVkU2lnbmluKHRydWUpO1xuICAgIH1cbiAgfSwgW2F1dGgsIGhhc1RyaWVkU2lnbmluLCBzaG91bGRBdHRlbXB0U2lnbmluLCBzaWduaW5NZXRob2RdKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGF1dGguaXNMb2FkaW5nLFxuICAgIGlzQXV0aGVudGljYXRlZDogYXV0aC5pc0F1dGhlbnRpY2F0ZWQsXG4gICAgZXJyb3I6IGF1dGguZXJyb3JcbiAgfTtcbn07XG5cbi8vIHNyYy93aXRoQXV0aC50c3hcbmltcG9ydCBSZWFjdDUgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB3aXRoQXV0aChDb21wb25lbnQpIHtcbiAgY29uc3QgZGlzcGxheU5hbWUgPSBgd2l0aEF1dGgoJHtDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWV9KWA7XG4gIGNvbnN0IEMgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBhdXRoID0gdXNlQXV0aCgpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IC4uLnByb3BzLCBhdXRoIH0pO1xuICB9O1xuICBDLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIHJldHVybiBDO1xufVxuXG4vLyBzcmMvd2l0aEF1dGhlbnRpY2F0aW9uUmVxdWlyZWQudHN4XG5pbXBvcnQgUmVhY3Q2IGZyb20gXCJyZWFjdFwiO1xudmFyIHdpdGhBdXRoZW50aWNhdGlvblJlcXVpcmVkID0gKENvbXBvbmVudCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgT25SZWRpcmVjdGluZyA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDYuY3JlYXRlRWxlbWVudChSZWFjdDYuRnJhZ21lbnQsIG51bGwpLCBvbkJlZm9yZVNpZ25pbiwgc2lnbmluUmVkaXJlY3RBcmdzIH0gPSBvcHRpb25zO1xuICBjb25zdCBkaXNwbGF5TmFtZSA9IGB3aXRoQXV0aGVudGljYXRpb25SZXF1aXJlZCgke0NvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZX0pYDtcbiAgY29uc3QgQyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGF1dGggPSB1c2VBdXRoKCk7XG4gICAgUmVhY3Q2LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoaGFzQXV0aFBhcmFtcygpIHx8IGF1dGguaXNMb2FkaW5nIHx8IGF1dGguYWN0aXZlTmF2aWdhdG9yIHx8IGF1dGguaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZvaWQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKG9uQmVmb3JlU2lnbmluKSBhd2FpdCBvbkJlZm9yZVNpZ25pbigpO1xuICAgICAgICBhd2FpdCBhdXRoLnNpZ25pblJlZGlyZWN0KHNpZ25pblJlZGlyZWN0QXJncyk7XG4gICAgICB9KSgpO1xuICAgIH0sIFthdXRoLmlzTG9hZGluZywgYXV0aC5pc0F1dGhlbnRpY2F0ZWQsIGF1dGhdKTtcbiAgICByZXR1cm4gYXV0aC5pc0F1dGhlbnRpY2F0ZWQgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IC4uLnByb3BzIH0pIDogT25SZWRpcmVjdGluZygpO1xuICB9O1xuICBDLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIHJldHVybiBDO1xufTtcbmV4cG9ydCB7XG4gIEF1dGhDb250ZXh0LFxuICBBdXRoUHJvdmlkZXIsXG4gIGhhc0F1dGhQYXJhbXMsXG4gIHVzZUF1dGgsXG4gIHVzZUF1dG9TaWduaW4sXG4gIHdpdGhBdXRoLFxuICB3aXRoQXV0aGVudGljYXRpb25SZXF1aXJlZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LW9pZGMtY29udGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react-oidc-context/dist/esm/react-oidc-context.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    {\n      if (hasOwnProperty.call(props, 'key')) {\n        var componentName = getComponentNameFromType(type);\n        var keys = Object.keys(props).filter(function (k) {\n          return k !== 'key';\n        });\n        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n        if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n          error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n          didWarnAboutKeySpread[componentName + beforeExample] = true;\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLGdFQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDJEQUEyRCxVQUFVO0FBQ3JFLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsR0FBRztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnREFBZ0QsZ0RBQWdELE1BQU0sYUFBYTs7QUFFbkg7QUFDQSxpREFBaUQsa0NBQWtDLE9BQU87O0FBRTFGLHlHQUF5RyxjQUFjLFVBQVUsZ0dBQWdHLGtCQUFrQixVQUFVLFVBQVU7O0FBRXZRO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiL1VzZXJzL2Jjb25uL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9jb21+YXBwbGV+Q2xvdWREb2NzL1Byb2plY3RzL1ZveFBvcF9BZ2VudGljL3ZveHBvcGFpL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYmVmb3JlRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7a2V5OiBzb21lS2V5LCAnICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7a2V5OiBzb21lS2V5fSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgICAgZXJyb3IoJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIHsuLi5wcm9wc30gLz5cXG4nICsgJ1JlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsIGJlZm9yZUV4YW1wbGUsIGNvbXBvbmVudE5hbWUsIGFmdGVyRXhhbXBsZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(pages-dir-browser)/./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDJLQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsiL1VzZXJzL2Jjb25uL0xpYnJhcnkvTW9iaWxlIERvY3VtZW50cy9jb21+YXBwbGV+Q2xvdWREb2NzL1Byb2plY3RzL1ZveFBvcF9BZ2VudGljL3ZveHBvcGFpL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/components/AuthStatusBar.tsx":
/*!******************************************!*\
  !*** ./src/components/AuthStatusBar.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AuthStatusBar)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_oidc_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-oidc-context */ \"(pages-dir-browser)/./node_modules/react-oidc-context/dist/esm/react-oidc-context.js\");\n\nvar _s = $RefreshSig$();\n\n\nfunction AuthStatusBar() {\n    var _auth_user;\n    _s();\n    const auth = (0,react_oidc_context__WEBPACK_IMPORTED_MODULE_2__.useAuth)();\n    var _process_env_NEXT_PUBLIC_COGNITO_CLIENT_ID;\n    const clientId = (_process_env_NEXT_PUBLIC_COGNITO_CLIENT_ID = \"7idgmap2mv7acc6bame3rommal\") !== null && _process_env_NEXT_PUBLIC_COGNITO_CLIENT_ID !== void 0 ? _process_env_NEXT_PUBLIC_COGNITO_CLIENT_ID : \"\";\n    var _process_env_NEXT_PUBLIC_COGNITO_DOMAIN;\n    const cognitoDomain = (_process_env_NEXT_PUBLIC_COGNITO_DOMAIN = \"https://ap-southeast-2ofbo55m16.auth.ap-southeast-2.amazoncognito.com\") !== null && _process_env_NEXT_PUBLIC_COGNITO_DOMAIN !== void 0 ? _process_env_NEXT_PUBLIC_COGNITO_DOMAIN : \"\";\n    const logoutUri =  true ? window.location.origin : 0;\n    const signOutRedirect = ()=>{\n        if (!cognitoDomain || !clientId) {\n            // Fallback: clear local session only\n            auth.removeUser();\n            window.location.href = logoutUri;\n            return;\n        }\n        auth.removeUser();\n        window.location.href = \"\".concat(cognitoDomain, \"/logout?client_id=\").concat(clientId, \"&logout_uri=\").concat(encodeURIComponent(logoutUri));\n    };\n    const barStyle = {\n        width: \"100%\",\n        padding: \"0.5rem 1rem\",\n        backgroundColor: \"#f5f5f5\",\n        borderBottom: \"1px solid #e2e8f0\",\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"space-between\",\n        fontFamily: \"sans-serif\",\n        fontSize: \"0.9rem\"\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: barStyle,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                children: auth.isAuthenticated ? \"Signed in as \".concat((_auth_user = auth.user) === null || _auth_user === void 0 ? void 0 : _auth_user.profile.email) : \"Not signed in\"\n            }, void 0, false, {\n                fileName: \"/Users/bconn/Library/Mobile Documents/com~apple~CloudDocs/Projects/VoxPop_Agentic/voxpopai/frontend/src/components/AuthStatusBar.tsx\",\n                lineNumber: 36,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: auth.isAuthenticated ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: signOutRedirect,\n                    style: {\n                        padding: \"0.25rem 0.75rem\"\n                    },\n                    children: \"Sign out\"\n                }, void 0, false, {\n                    fileName: \"/Users/bconn/Library/Mobile Documents/com~apple~CloudDocs/Projects/VoxPop_Agentic/voxpopai/frontend/src/components/AuthStatusBar.tsx\",\n                    lineNumber: 41,\n                    columnNumber: 11\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: ()=>auth.signinRedirect(),\n                    style: {\n                        padding: \"0.25rem 0.75rem\"\n                    },\n                    children: \"Sign in\"\n                }, void 0, false, {\n                    fileName: \"/Users/bconn/Library/Mobile Documents/com~apple~CloudDocs/Projects/VoxPop_Agentic/voxpopai/frontend/src/components/AuthStatusBar.tsx\",\n                    lineNumber: 45,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/bconn/Library/Mobile Documents/com~apple~CloudDocs/Projects/VoxPop_Agentic/voxpopai/frontend/src/components/AuthStatusBar.tsx\",\n                lineNumber: 39,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/bconn/Library/Mobile Documents/com~apple~CloudDocs/Projects/VoxPop_Agentic/voxpopai/frontend/src/components/AuthStatusBar.tsx\",\n        lineNumber: 35,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthStatusBar, \"YuJWYXaKIY31b1y7U6yy3IXSxQA=\", false, function() {\n    return [\n        react_oidc_context__WEBPACK_IMPORTED_MODULE_2__.useAuth\n    ];\n});\n_c = AuthStatusBar;\nvar _c;\n$RefreshReg$(_c, \"AuthStatusBar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0F1dGhTdGF0dXNCYXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ21CO0FBRTlCLFNBQVNFO1FBaUN3QkM7O0lBaEM5QyxNQUFNQSxPQUFPRiwyREFBT0E7UUFFSEc7SUFBakIsTUFBTUMsV0FBV0QsQ0FBQUEsNkNBQUFBLDRCQUF5QyxjQUF6Q0Esd0RBQUFBLDZDQUE2QztRQUN4Q0E7SUFBdEIsTUFBTUksZ0JBQWdCSixDQUFBQSwwQ0FBQUEsdUVBQXNDLGNBQXRDQSxxREFBQUEsMENBQTBDO0lBQ2hFLE1BQU1NLFlBQVksS0FBNkIsR0FBR0MsT0FBT0MsUUFBUSxDQUFDQyxNQUFNLEdBQUcsQ0FBdUI7SUFFbEcsTUFBTUMsa0JBQWtCO1FBQ3RCLElBQUksQ0FBQ04saUJBQWlCLENBQUNILFVBQVU7WUFDL0IscUNBQXFDO1lBQ3JDRixLQUFLWSxVQUFVO1lBQ2ZKLE9BQU9DLFFBQVEsQ0FBQ0ksSUFBSSxHQUFHTjtZQUN2QjtRQUNGO1FBQ0FQLEtBQUtZLFVBQVU7UUFDZkosT0FBT0MsUUFBUSxDQUFDSSxJQUFJLEdBQUcsR0FBcUNYLE9BQWxDRyxlQUFjLHNCQUEyQ1MsT0FBdkJaLFVBQVMsZ0JBQTRDLE9BQTlCWSxtQkFBbUJQO0lBQ3hHO0lBRUEsTUFBTVEsV0FBZ0M7UUFDcENDLE9BQU87UUFDUEMsU0FBUztRQUNUQyxpQkFBaUI7UUFDakJDLGNBQWM7UUFDZEMsU0FBUztRQUNUQyxZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsWUFBWTtRQUNaQyxVQUFVO0lBQ1o7SUFFQSxxQkFDRSw4REFBQ0M7UUFBSUMsT0FBT1g7OzBCQUNWLDhEQUFDWTswQkFDRTNCLEtBQUs0QixlQUFlLEdBQUcsZ0JBQXlDLFFBQXpCNUIsYUFBQUEsS0FBSzZCLElBQUksY0FBVDdCLGlDQUFBQSxXQUFXOEIsT0FBTyxDQUFDQyxLQUFLLElBQUs7Ozs7OzswQkFFdkUsOERBQUNOOzBCQUNFekIsS0FBSzRCLGVBQWUsaUJBQ25CLDhEQUFDSTtvQkFBT0MsU0FBU3RCO29CQUFpQmUsT0FBTzt3QkFBRVQsU0FBUztvQkFBa0I7OEJBQUc7Ozs7O3lDQUl6RSw4REFBQ2U7b0JBQU9DLFNBQVMsSUFBTWpDLEtBQUtrQyxjQUFjO29CQUFJUixPQUFPO3dCQUFFVCxTQUFTO29CQUFrQjs4QkFBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPL0Y7R0FoRHdCbEI7O1FBQ1RELHVEQUFPQTs7O0tBREVDIiwic291cmNlcyI6WyIvVXNlcnMvYmNvbm4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL2NvbX5hcHBsZX5DbG91ZERvY3MvUHJvamVjdHMvVm94UG9wX0FnZW50aWMvdm94cG9wYWkvZnJvbnRlbmQvc3JjL2NvbXBvbmVudHMvQXV0aFN0YXR1c0Jhci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gXCJyZWFjdC1vaWRjLWNvbnRleHRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXV0aFN0YXR1c0JhcigpIHtcbiAgY29uc3QgYXV0aCA9IHVzZUF1dGgoKTtcblxuICBjb25zdCBjbGllbnRJZCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPR05JVE9fQ0xJRU5UX0lEID8/IFwiXCI7XG4gIGNvbnN0IGNvZ25pdG9Eb21haW4gPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DT0dOSVRPX0RPTUFJTiA/PyBcIlwiO1xuICBjb25zdCBsb2dvdXRVcmkgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmxvY2F0aW9uLm9yaWdpbiA6IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCI7XG5cbiAgY29uc3Qgc2lnbk91dFJlZGlyZWN0ID0gKCkgPT4ge1xuICAgIGlmICghY29nbml0b0RvbWFpbiB8fCAhY2xpZW50SWQpIHtcbiAgICAgIC8vIEZhbGxiYWNrOiBjbGVhciBsb2NhbCBzZXNzaW9uIG9ubHlcbiAgICAgIGF1dGgucmVtb3ZlVXNlcigpO1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBsb2dvdXRVcmk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF1dGgucmVtb3ZlVXNlcigpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYCR7Y29nbml0b0RvbWFpbn0vbG9nb3V0P2NsaWVudF9pZD0ke2NsaWVudElkfSZsb2dvdXRfdXJpPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGxvZ291dFVyaSl9YDtcbiAgfTtcblxuICBjb25zdCBiYXJTdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcyA9IHtcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgcGFkZGluZzogXCIwLjVyZW0gMXJlbVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCAjZTJlOGYwXCIsXG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gICAgZm9udFNpemU6IFwiMC45cmVtXCIsXG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHN0eWxlPXtiYXJTdHlsZX0+XG4gICAgICA8c3Bhbj5cbiAgICAgICAge2F1dGguaXNBdXRoZW50aWNhdGVkID8gYFNpZ25lZCBpbiBhcyAke2F1dGgudXNlcj8ucHJvZmlsZS5lbWFpbH1gIDogXCJOb3Qgc2lnbmVkIGluXCJ9XG4gICAgICA8L3NwYW4+XG4gICAgICA8ZGl2PlxuICAgICAgICB7YXV0aC5pc0F1dGhlbnRpY2F0ZWQgPyAoXG4gICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtzaWduT3V0UmVkaXJlY3R9IHN0eWxlPXt7IHBhZGRpbmc6IFwiMC4yNXJlbSAwLjc1cmVtXCIgfX0+XG4gICAgICAgICAgICBTaWduIG91dFxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApIDogKFxuICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gYXV0aC5zaWduaW5SZWRpcmVjdCgpfSBzdHlsZT17eyBwYWRkaW5nOiBcIjAuMjVyZW0gMC43NXJlbVwiIH19PlxuICAgICAgICAgICAgU2lnbiBpblxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUF1dGgiLCJBdXRoU3RhdHVzQmFyIiwiYXV0aCIsInByb2Nlc3MiLCJjbGllbnRJZCIsImVudiIsIk5FWFRfUFVCTElDX0NPR05JVE9fQ0xJRU5UX0lEIiwiY29nbml0b0RvbWFpbiIsIk5FWFRfUFVCTElDX0NPR05JVE9fRE9NQUlOIiwibG9nb3V0VXJpIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJzaWduT3V0UmVkaXJlY3QiLCJyZW1vdmVVc2VyIiwiaHJlZiIsImVuY29kZVVSSUNvbXBvbmVudCIsImJhclN0eWxlIiwid2lkdGgiLCJwYWRkaW5nIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQm90dG9tIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImRpdiIsInN0eWxlIiwic3BhbiIsImlzQXV0aGVudGljYXRlZCIsInVzZXIiLCJwcm9maWxlIiwiZW1haWwiLCJidXR0b24iLCJvbkNsaWNrIiwic2lnbmluUmVkaXJlY3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/AuthStatusBar.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/pages/_app.tsx":
/*!****************************!*\
  !*** ./src/pages/_app.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_oidc_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-oidc-context */ \"(pages-dir-browser)/./node_modules/react-oidc-context/dist/esm/react-oidc-context.js\");\n/* harmony import */ var _components_AuthStatusBar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/AuthStatusBar */ \"(pages-dir-browser)/./src/components/AuthStatusBar.tsx\");\n// index.js\n\n\n\n\nvar _process_env_NEXT_PUBLIC_COGNITO_POOL_ID;\n// Build config from environment variables set in .env.local\nconst poolId = (_process_env_NEXT_PUBLIC_COGNITO_POOL_ID = \"ap-southeast-2_OFbO55m16\") !== null && _process_env_NEXT_PUBLIC_COGNITO_POOL_ID !== void 0 ? _process_env_NEXT_PUBLIC_COGNITO_POOL_ID : \"\"; // e.g. ap-southeast-2_XXXXXXXXX\nconst region = poolId.split(\"_\")[0] || \"ap-southeast-2\";\nvar _process_env_NEXT_PUBLIC_COGNITO_CLIENT_ID;\nconst cognitoAuthConfig = {\n    authority: \"https://cognito-idp.\".concat(region, \".amazonaws.com/\").concat(poolId),\n    client_id: (_process_env_NEXT_PUBLIC_COGNITO_CLIENT_ID = \"7idgmap2mv7acc6bame3rommal\") !== null && _process_env_NEXT_PUBLIC_COGNITO_CLIENT_ID !== void 0 ? _process_env_NEXT_PUBLIC_COGNITO_CLIENT_ID : \"\",\n    redirect_uri:  true ? window.location.origin : 0,\n    response_type: \"code\",\n    scope: \"openid email phone\",\n    post_logout_redirect_uri:  true ? window.location.origin : 0\n};\nfunction MyApp(param) {\n    let { Component, pageProps } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_oidc_context__WEBPACK_IMPORTED_MODULE_2__.AuthProvider, {\n        ...cognitoAuthConfig,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_AuthStatusBar__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/bconn/Library/Mobile Documents/com~apple~CloudDocs/Projects/VoxPop_Agentic/voxpopai/frontend/src/pages/_app.tsx\",\n                lineNumber: 23,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                ...pageProps\n            }, void 0, false, {\n                fileName: \"/Users/bconn/Library/Mobile Documents/com~apple~CloudDocs/Projects/VoxPop_Agentic/voxpopai/frontend/src/pages/_app.tsx\",\n                lineNumber: 24,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/bconn/Library/Mobile Documents/com~apple~CloudDocs/Projects/VoxPop_Agentic/voxpopai/frontend/src/pages/_app.tsx\",\n        lineNumber: 22,\n        columnNumber: 5\n    }, this);\n}\n_c = MyApp;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9wYWdlcy9fYXBwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsV0FBVzs7QUFDZTtBQUV3QjtBQUNNO0lBR3pDRztBQURmLDREQUE0RDtBQUM1RCxNQUFNQyxTQUFTRCxDQUFBQSwyQ0FBQUEsMEJBQXVDLGNBQXZDQSxzREFBQUEsMkNBQTJDLElBQUksZ0NBQWdDO0FBQzlGLE1BQU1JLFNBQVNILE9BQU9JLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJO0lBSTFCTDtBQUZiLE1BQU1NLG9CQUFvQjtJQUN4QkMsV0FBVyx1QkFBK0NOLE9BQXhCRyxRQUFPLG1CQUF3QixPQUFQSDtJQUMxRE8sV0FBV1IsQ0FBQUEsNkNBQUFBLDRCQUF5QyxjQUF6Q0Esd0RBQUFBLDZDQUE2QztJQUN4RFUsY0FBYyxLQUE2QixHQUFHQyxPQUFPQyxRQUFRLENBQUNDLE1BQU0sR0FBRyxDQUF1QjtJQUM5RkMsZUFBZTtJQUNmQyxPQUFPO0lBQ1BDLDBCQUEwQixLQUE2QixHQUFHTCxPQUFPQyxRQUFRLENBQUNDLE1BQU0sR0FBRyxDQUF1QjtBQUM1RztBQUVBLFNBQVNJLE1BQU0sS0FBa0M7UUFBbEMsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQVksR0FBbEM7SUFDYixxQkFDRSw4REFBQ3JCLDREQUFZQTtRQUFFLEdBQUdRLGlCQUFpQjs7MEJBQ2pDLDhEQUFDUCxpRUFBYUE7Ozs7OzBCQUNkLDhEQUFDbUI7Z0JBQVcsR0FBR0MsU0FBUzs7Ozs7Ozs7Ozs7O0FBRzlCO0tBUFNGO0FBU1QsaUVBQWVBLEtBQUtBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9iY29ubi9MaWJyYXJ5L01vYmlsZSBEb2N1bWVudHMvY29tfmFwcGxlfkNsb3VkRG9jcy9Qcm9qZWN0cy9Wb3hQb3BfQWdlbnRpYy92b3hwb3BhaS9mcm9udGVuZC9zcmMvcGFnZXMvX2FwcC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW5kZXguanNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgQXBwUHJvcHMgfSBmcm9tIFwibmV4dC9hcHBcIjtcbmltcG9ydCB7IEF1dGhQcm92aWRlciB9IGZyb20gXCJyZWFjdC1vaWRjLWNvbnRleHRcIjtcbmltcG9ydCBBdXRoU3RhdHVzQmFyIGZyb20gXCIuLi9jb21wb25lbnRzL0F1dGhTdGF0dXNCYXJcIjtcblxuLy8gQnVpbGQgY29uZmlnIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzIHNldCBpbiAuZW52LmxvY2FsXG5jb25zdCBwb29sSWQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DT0dOSVRPX1BPT0xfSUQgPz8gXCJcIjsgLy8gZS5nLiBhcC1zb3V0aGVhc3QtMl9YWFhYWFhYWFhcbmNvbnN0IHJlZ2lvbiA9IHBvb2xJZC5zcGxpdChcIl9cIilbMF0gfHwgXCJhcC1zb3V0aGVhc3QtMlwiO1xuXG5jb25zdCBjb2duaXRvQXV0aENvbmZpZyA9IHtcbiAgYXV0aG9yaXR5OiBgaHR0cHM6Ly9jb2duaXRvLWlkcC4ke3JlZ2lvbn0uYW1hem9uYXdzLmNvbS8ke3Bvb2xJZH1gLFxuICBjbGllbnRfaWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPR05JVE9fQ0xJRU5UX0lEID8/IFwiXCIsXG4gIHJlZGlyZWN0X3VyaTogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiLFxuICByZXNwb25zZV90eXBlOiBcImNvZGVcIixcbiAgc2NvcGU6IFwib3BlbmlkIGVtYWlsIHBob25lXCIsXG4gIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiLFxufTtcblxuZnVuY3Rpb24gTXlBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9OiBBcHBQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxBdXRoUHJvdmlkZXIgey4uLmNvZ25pdG9BdXRoQ29uZmlnfT5cbiAgICAgIDxBdXRoU3RhdHVzQmFyIC8+XG4gICAgICA8Q29tcG9uZW50IHsuLi5wYWdlUHJvcHN9IC8+XG4gICAgPC9BdXRoUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE15QXBwOyJdLCJuYW1lcyI6WyJSZWFjdCIsIkF1dGhQcm92aWRlciIsIkF1dGhTdGF0dXNCYXIiLCJwcm9jZXNzIiwicG9vbElkIiwiZW52IiwiTkVYVF9QVUJMSUNfQ09HTklUT19QT09MX0lEIiwicmVnaW9uIiwic3BsaXQiLCJjb2duaXRvQXV0aENvbmZpZyIsImF1dGhvcml0eSIsImNsaWVudF9pZCIsIk5FWFRfUFVCTElDX0NPR05JVE9fQ0xJRU5UX0lEIiwicmVkaXJlY3RfdXJpIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJyZXNwb25zZV90eXBlIiwic2NvcGUiLCJwb3N0X2xvZ291dF9yZWRpcmVjdF91cmkiLCJNeUFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/pages/_app.tsx\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main"], () => (__webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/client/router.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);